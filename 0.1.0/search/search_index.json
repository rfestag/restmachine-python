{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RestMachine","text":"<p>A lightweight REST framework with pytest-style dependency injection and webmachine-inspired state machine</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>RestMachine is a modern Python REST framework that makes building APIs straightforward:</p> <ul> <li>Easy to learn - Familiar Flask-like decorators and intuitive patterns</li> <li>Share resources cleanly - Pass database connections, configs, and services to handlers without globals</li> <li>HTTP done right - Automatic content negotiation, proper status codes, and standards compliance</li> <li>Flexible validation - Use Pydantic when you need it, skip it when you don't</li> <li>Deploy anywhere - Same code runs on Uvicorn, Hypercorn, or AWS Lambda</li> <li>Start simple - Zero required dependencies, add features as you need them</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from restmachine import RestApplication, Request\n\napp = RestApplication()\n\n@app.get('/hello/{name}')\ndef hello(request: Request):\n    name = request.path_params['name']\n    return {\"message\": f\"Hello, {name}!\"}\n\n# Run with ASGI\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n</code></pre> <p>Deploy with any ASGI server:</p> <pre><code>uvicorn app:asgi_app --reload\n</code></pre> <p>Or deploy to AWS Lambda:</p> <pre><code>from restmachine_aws import AwsApiGatewayAdapter\n\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#share-resources-easily","title":"Share Resources Easily","text":"<p>Pass database connections, configs, and services to your handlers automatically:</p> <pre><code>@app.on_startup\ndef database():\n    \"\"\"Initialize database connection at startup.\"\"\"\n    return create_db_connection()\n\n@app.resource_exists\ndef user(database, path_params):\n    user_id = path_params['user_id']\n    return database.get_user(user_id)  # Returns None if not found\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    return user  # 404 handled automatically if None\n</code></pre>"},{"location":"#request-validation","title":"Request Validation","text":"<p>Optional Pydantic integration for type-safe validation:</p> <pre><code>from pydantic import BaseModel\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\n@app.validates\ndef user_create(request: Request) -&gt; UserCreate:\n    import json\n    return UserCreate.model_validate(json.loads(request.body))\n\n@app.post('/users')\ndef create_user(user_create: UserCreate):\n    return {\"created\": user_create.model_dump()}\n</code></pre>"},{"location":"#serve-multiple-formats","title":"Serve Multiple Formats","text":"<p>Automatically serve JSON, XML, or custom formats based on what clients request:</p> <pre><code>@app.get('/data')\ndef get_data():\n    return {\"message\": \"Hello\", \"timestamp\": \"2024-01-01\"}\n\n@app.provides(\"text/html\")\ndef render_html(get_data):\n    data = get_data\n    return f\"&lt;h1&gt;{data['message']}&lt;/h1&gt;&lt;p&gt;Time: {data['timestamp']}&lt;/p&gt;\"\n\n@app.provides(\"text/xml\")\ndef render_xml(get_data):\n    data = get_data\n    return f\"&lt;result&gt;&lt;message&gt;{data['message']}&lt;/message&gt;&lt;/result&gt;\"\n</code></pre>"},{"location":"#automatic-openapi-documentation","title":"Automatic OpenAPI Documentation","text":"<p>Generate OpenAPI 3.0 specifications automatically from your code:</p> <pre><code># Generate OpenAPI spec\nopenapi_json = app.generate_openapi_json(\n    title=\"My API\",\n    version=\"1.0.0\"\n)\n\n# Or save to file for Swagger UI, client SDK generation, etc.\napp.save_openapi_json(filename=\"openapi.json\")\n</code></pre>"},{"location":"#manage-resources-cleanly","title":"Manage Resources Cleanly","text":"<p>Set up and tear down resources like database connections automatically:</p> <pre><code>@app.on_startup\ndef database():\n    print(\"Opening database connection...\")\n    return create_db_connection()\n\n@app.on_shutdown\ndef close_database(database):\n    print(\"Closing database connection...\")\n    database.close()\n</code></pre>"},{"location":"#installation","title":"Installation","text":"BasicWith ValidationWith AWS Lambda <pre><code>pip install restmachine\n</code></pre> <pre><code>pip install restmachine[validation]\n</code></pre> <pre><code>pip install restmachine restmachine-aws\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started \u2192 - Learn the basics</li> <li>Quick Start \u2192 - Build your first API</li> <li>User Guide \u2192 - Comprehensive tutorials</li> <li>API Reference \u2192 - Detailed API documentation</li> </ul>"},{"location":"#why-restmachine","title":"Why RestMachine?","text":"<p>RestMachine makes building REST APIs easier by handling the tricky parts of HTTP for you:</p> <ul> <li> <p>Easy to learn - If you know Flask or FastAPI, you already know RestMachine. Familiar decorator syntax, intuitive patterns.</p> </li> <li> <p>Smart HTTP handling - RestMachine understands HTTP semantics and automatically handles content negotiation, conditional requests (ETags), and proper status codes. You focus on your business logic.</p> </li> <li> <p>Clean, testable code - Share resources like database connections across handlers without global state. pytest-style dependency injection makes testing straightforward.</p> </li> <li> <p>Deploy anywhere - Start developing locally with any ASGI server (Uvicorn, Hypercorn), then deploy to AWS Lambda with zero code changes. Same application code, different deployment targets.</p> </li> <li> <p>Start simple, grow gradually - Begin with just Python 3.9+, no required dependencies. Add validation (Pydantic), template rendering (Jinja2), or other features only when you need them.</p> </li> <li> <p>Transparent behavior - The state machine surfaces HTTP request details (content types, cache headers, auth status) as simple facts you can inspect and extend. No hidden magic, just clear control flow.</p> </li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: rfestag/restmachine-python</li> <li>Issues: Report bugs or request features</li> <li>Security: See Security Policy</li> </ul>"},{"location":"#license","title":"License","text":"<p>RestMachine is released under the MIT License.</p>"},{"location":"metrics/","title":"Metrics &amp; Observability","text":"<p>RestMachine provides a lightweight, platform-agnostic metrics collection system for monitoring application performance and tracking business metrics.</p>"},{"location":"metrics/#overview","title":"Overview","text":"<p>The metrics system is designed to be:</p> <ul> <li>Platform-agnostic - Core collection works anywhere</li> <li>Auto-configured for AWS Lambda - CloudWatch EMF enabled automatically when using <code>AwsApiGatewayAdapter</code></li> <li>Extensible - Easy to add publishers for any metrics platform</li> <li>Zero-overhead when disabled - Metrics collection can be bypassed</li> <li>Dependency-injected - Access via standard DI pattern</li> </ul>"},{"location":"metrics/#platform-support","title":"Platform Support","text":"Platform Auto-Detection Support Documentation AWS Lambda \u2705 Automatic CloudWatch EMF enabled by default AWS Metrics Guide ASGI on AWS \u2705 Automatic CloudWatch EMF enabled when AWS detected ASGI Integration ASGI (Non-AWS) \u274c Manual Custom publisher required ASGI Integration Other \u274c Manual Custom publisher required Custom Publishers"},{"location":"metrics/#quick-start","title":"Quick Start","text":""},{"location":"metrics/#aws-lambda-auto-configured","title":"AWS Lambda (Auto-configured)","text":"<p>When running on AWS Lambda, metrics are automatically enabled and published to CloudWatch using EMF (Embedded Metric Format). No additional configuration is required.</p> <p>The <code>AwsApiGatewayAdapter</code> automatically detects that it's running in an AWS Lambda environment and:</p> <ul> <li>\u2705 Creates a CloudWatch EMF publisher by default</li> <li>\u2705 Configures logging to output EMF-formatted metrics</li> <li>\u2705 Uses your Lambda function name as the service dimension</li> <li>\u2705 Publishes metrics after each request</li> </ul> <pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\n\napp = RestApplication()\n\n@app.get(\"/users/{id}\")\ndef get_user(id: str, metrics):\n    # Add custom metrics\n    metrics.add_metric(\"users.fetched\", 1, unit=\"Count\")\n    return {\"user\": id}\n\n# Metrics automatically enabled with CloudWatch EMF\n# No explicit configuration needed!\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre> <p>To customize the configuration or disable metrics, see AWS CloudWatch Metrics Guide.</p>"},{"location":"metrics/#other-platforms","title":"Other Platforms","text":"<p>For non-AWS platforms, implement a custom publisher:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine.metrics import MetricsPublisher\n\nclass MyPublisher(MetricsPublisher):\n    def is_enabled(self) -&gt; bool:\n        return True\n\n    def publish(self, collector, request=None, response=None, context=None):\n        # Send metrics to your platform\n        for name, values in collector.metrics.items():\n            for metric_value in values:\n                print(f\"{name}: {metric_value.value}\")\n\n# Use custom publisher\npublisher = MyPublisher()\n# Integration depends on platform - see Custom Publishers section\n</code></pre>"},{"location":"metrics/#core-concepts","title":"Core Concepts","text":""},{"location":"metrics/#metricscollector","title":"MetricsCollector","text":"<p>The <code>MetricsCollector</code> is injected as a dependency and provides methods to record metrics:</p> <pre><code>@app.get(\"/endpoint\")\ndef handler(metrics):\n    # Add metrics\n    metrics.add_metric(\"requests\", 1, unit=\"Count\")\n\n    # Add dimensions (low-cardinality grouping)\n    metrics.add_dimension(\"environment\", \"production\")\n\n    # Add metadata (high-cardinality context)\n    metrics.add_metadata(\"request_id\", request_id)\n\n    # Time operations\n    metrics.start_timer(\"operation\")\n    do_work()\n    metrics.stop_timer(\"operation\")\n\n    return {\"ok\": True}\n</code></pre>"},{"location":"metrics/#metricspublisher","title":"MetricsPublisher","text":"<p>The abstract base class for publishing metrics to any platform:</p> <pre><code>from restmachine.metrics import MetricsPublisher\n\nclass MyPublisher(MetricsPublisher):\n    def is_enabled(self) -&gt; bool:\n        \"\"\"Return True if publishing is enabled.\"\"\"\n        return True\n\n    def publish(self, collector, request=None, response=None, context=None):\n        \"\"\"Publish collected metrics.\"\"\"\n        # collector.metrics - Dict[str, List[MetricValue]]\n        # collector.get_all_dimensions() - Dict[str, str]\n        # collector.metadata - Dict[str, Any]\n        pass\n</code></pre>"},{"location":"metrics/#adding-metrics","title":"Adding Metrics","text":""},{"location":"metrics/#basic-metrics","title":"Basic Metrics","text":"<pre><code>@app.get(\"/orders\")\ndef list_orders(metrics):\n    # Count metrics\n    metrics.add_metric(\"orders.listed\", 1, unit=\"Count\")\n\n    # Value metrics\n    metrics.add_metric(\"orders.total_value\", 1250.00, unit=\"None\")\n\n    # Size metrics\n    metrics.add_metric(\"response.size\", 1024, unit=\"Bytes\")\n\n    return orders\n</code></pre>"},{"location":"metrics/#using-timers","title":"Using Timers","text":"<pre><code>@app.get(\"/data\")\ndef fetch_data(metrics):\n    metrics.start_timer(\"database.query\")\n    data = db.query(\"SELECT * FROM users\")\n    metrics.stop_timer(\"database.query\")  # Adds metric in milliseconds\n\n    return data\n</code></pre>"},{"location":"metrics/#multiple-values-aggregation","title":"Multiple Values (Aggregation)","text":"<pre><code>@app.get(\"/batch\")\ndef process_batch(metrics):\n    for item in items:\n        # Each call adds to the metric\n        metrics.add_metric(\"items.processed\", 1, unit=\"Count\")\n        metrics.add_metric(\"processing.time\", process(item), unit=\"Milliseconds\")\n\n    # Publisher receives all values for aggregation\n    return {\"processed\": len(items)}\n</code></pre>"},{"location":"metrics/#dimensions-vs-metadata","title":"Dimensions vs Metadata","text":"<p>Dimensions are for grouping/filtering (low-cardinality):</p> <pre><code># Good - few unique values\nmetrics.add_dimension(\"environment\", \"production\")  # ~3-5 values\nmetrics.add_dimension(\"region\", \"us-east-1\")        # ~10-20 values\nmetrics.add_dimension(\"user_type\", \"premium\")       # ~3-10 values\n</code></pre> <p>Metadata is for context/debugging (high-cardinality):</p> <pre><code># Good - many unique values\nmetrics.add_metadata(\"user_id\", \"12345\")           # Thousands of values\nmetrics.add_metadata(\"request_id\", \"abc-def-...\")  # Unique per request\nmetrics.add_metadata(\"order_id\", order_id)         # Unique identifiers\n</code></pre> <p>\u26a0\ufe0f Some platforms (like CloudWatch) limit dimensions (max 30). Use metadata for high-cardinality data.</p>"},{"location":"metrics/#metric-units","title":"Metric Units","text":"<p>Available units from the <code>MetricUnit</code> enum:</p> <pre><code>from restmachine.metrics import MetricUnit\n\n# Time\nMetricUnit.Seconds\nMetricUnit.Milliseconds\nMetricUnit.Microseconds\n\n# Bytes\nMetricUnit.Bytes\nMetricUnit.Kilobytes\nMetricUnit.Megabytes\nMetricUnit.Gigabytes\n\n# Count\nMetricUnit.Count\n\n# Rates\nMetricUnit.CountPerSecond\nMetricUnit.BytesPerSecond\n\n# Other\nMetricUnit.Percent\nMetricUnit.None\n</code></pre> <p>Usage:</p> <pre><code>metrics.add_metric(\"api.latency\", 45.2, unit=MetricUnit.Milliseconds)\nmetrics.add_metric(\"requests\", 1, unit=MetricUnit.Count)\nmetrics.add_metric(\"response.size\", 2048, unit=MetricUnit.Bytes)\n</code></pre>"},{"location":"metrics/#default-dimensions","title":"Default Dimensions","text":"<p>Set dimensions that apply to all metrics in a request:</p> <pre><code>@app.get(\"/endpoint\")\ndef handler(metrics):\n    # Apply to all metrics\n    metrics.set_default_dimensions(\n        environment=\"production\",\n        version=\"v2\"\n    )\n\n    metrics.add_metric(\"requests\", 1)\n    # Includes: environment=production, version=v2\n\n    return {\"ok\": True}\n</code></pre> <p>Clear defaults if needed:</p> <pre><code>metrics.clear_default_dimensions()\n</code></pre>"},{"location":"metrics/#isolated-metrics-advanced","title":"Isolated Metrics (Advanced)","text":"<p>Use <code>EphemeralMetrics</code> for isolated metric collection:</p> <pre><code>from restmachine.metrics import EphemeralMetrics\n\n@app.get(\"/data\")\ndef get_data(metrics, tenant_id: str):\n    # Main request metrics\n    metrics.add_metric(\"api.requests\", 1)\n\n    # Isolated tenant metrics (no shared dimensions)\n    tenant_metrics = EphemeralMetrics()\n    tenant_metrics.add_dimension(\"tenant_id\", tenant_id)\n    tenant_metrics.add_metric(\"tenant.requests\", 1)\n\n    # EphemeralMetrics won't be auto-published\n    # Use for custom processing\n\n    return data\n</code></pre>"},{"location":"metrics/#custom-publishers","title":"Custom Publishers","text":"<p>Create publishers for any metrics platform.</p>"},{"location":"metrics/#publisher-interface","title":"Publisher Interface","text":"<pre><code>from restmachine.metrics import MetricsPublisher, MetricsCollector\n\nclass MyPublisher(MetricsPublisher):\n    def is_enabled(self) -&gt; bool:\n        \"\"\"Return True if publishing is enabled.\"\"\"\n        return True\n\n    def publish(self, collector: MetricsCollector,\n               request=None, response=None, context=None):\n        \"\"\"Publish collected metrics.\n\n        Args:\n            collector: MetricsCollector with metrics/dimensions/metadata\n            request: Optional Request object\n            response: Optional Response object\n            context: Optional platform context\n        \"\"\"\n        # Access metrics\n        for name, values in collector.metrics.items():\n            for metric_value in values:\n                # metric_value.value - The numeric value\n                # metric_value.unit - MetricUnit enum\n                pass\n\n        # Access dimensions\n        dimensions = collector.get_all_dimensions()\n\n        # Access metadata\n        metadata = collector.metadata\n</code></pre>"},{"location":"metrics/#example-datadog","title":"Example: Datadog","text":"<pre><code>from restmachine.metrics import MetricsPublisher\nimport datadog\n\nclass DatadogPublisher(MetricsPublisher):\n    def __init__(self, api_key: str):\n        datadog.initialize(api_key=api_key)\n\n    def is_enabled(self) -&gt; bool:\n        return True\n\n    def publish(self, collector, request=None, response=None, context=None):\n        dimensions = collector.get_all_dimensions()\n        tags = [f\"{k}:{v}\" for k, v in dimensions.items()]\n\n        for name, values in collector.metrics.items():\n            for metric_value in values:\n                datadog.api.Metric.send(\n                    metric=name,\n                    points=[(int(time.time()), metric_value.value)],\n                    tags=tags\n                )\n</code></pre>"},{"location":"metrics/#example-prometheus","title":"Example: Prometheus","text":"<pre><code>from restmachine.metrics import MetricsPublisher\nfrom prometheus_client import Counter, Histogram\n\nclass PrometheusPublisher(MetricsPublisher):\n    def __init__(self):\n        self.counters = {}\n        self.histograms = {}\n\n    def is_enabled(self) -&gt; bool:\n        return True\n\n    def publish(self, collector, request=None, response=None, context=None):\n        dimensions = collector.get_all_dimensions()\n        label_names = list(dimensions.keys())\n\n        for name, values in collector.metrics.items():\n            if 'time' in name or 'latency' in name:\n                # Use Histogram for timing\n                if name not in self.histograms:\n                    self.histograms[name] = Histogram(\n                        name.replace('.', '_'),\n                        f'Metric {name}',\n                        label_names\n                    )\n                for value in values:\n                    self.histograms[name].labels(**dimensions).observe(value.value)\n            else:\n                # Use Counter for counts\n                if name not in self.counters:\n                    self.counters[name] = Counter(\n                        name.replace('.', '_'),\n                        f'Metric {name}',\n                        label_names\n                    )\n                for value in values:\n                    self.counters[name].labels(**dimensions).inc(value.value)\n</code></pre>"},{"location":"metrics/#example-multi-publisher","title":"Example: Multi-Publisher","text":"<p>Publish to multiple backends simultaneously:</p> <pre><code>from restmachine.metrics import MetricsPublisher\n\nclass MultiPublisher(MetricsPublisher):\n    def __init__(self, *publishers):\n        self.publishers = publishers\n\n    def is_enabled(self) -&gt; bool:\n        return any(p.is_enabled() for p in self.publishers)\n\n    def publish(self, collector, request=None, response=None, context=None):\n        for publisher in self.publishers:\n            if publisher.is_enabled():\n                try:\n                    publisher.publish(collector, request, response, context)\n                except Exception as e:\n                    logging.error(f\"Publisher {publisher} failed: {e}\")\n</code></pre>"},{"location":"metrics/#asgi-integration","title":"ASGI Integration","text":"<p>The ASGI adapter automatically detects AWS environments and enables CloudWatch EMF metrics!</p> <p>When the <code>ASGIAdapter</code> detects it's running on AWS (via environment variables like <code>AWS_REGION</code>, <code>AWS_EXECUTION_ENV</code>, or ECS metadata), it automatically configures CloudWatch EMF metrics - just like the Lambda adapter.</p>"},{"location":"metrics/#aws-auto-detection-ecs-app-runner-ec2-etc","title":"AWS Auto-Detection (ECS, App Runner, EC2, etc.)","text":"<p>If running on AWS infrastructure, metrics are automatically enabled with CloudWatch EMF:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine.adapters import create_asgi_app\n\napp = RestApplication()\n\n@app.get(\"/users/{id}\")\ndef get_user(id: str, metrics):\n    # Metrics automatically available!\n    metrics.add_metric(\"users.fetched\", 1, unit=\"Count\")\n    return {\"user\": id}\n\n# Auto-detects AWS and enables CloudWatch EMF\n# Works on: ECS, App Runner, EC2, Lambda (via ASGI), etc.\nasgi_app = create_asgi_app(app)\n\n# Run with uvicorn, hypercorn, etc.\n# uvicorn module:asgi_app\n</code></pre> <p>The adapter automatically detects AWS by checking for: - <code>AWS_REGION</code> environment variable - <code>AWS_EXECUTION_ENV</code> environment variable (Lambda) - <code>ECS_CONTAINER_METADATA_URI</code> (ECS/Fargate) - <code>AWS_DEFAULT_REGION</code> environment variable</p> <p>When AWS is detected: - \u2705 CloudWatch EMF publisher is automatically configured - \u2705 Metrics are published to CloudWatch via logs - \u2705 Service name defaults to <code>asgi-app</code> (customizable) - \u2705 Namespace defaults to <code>RestMachine</code> (customizable)</p>"},{"location":"metrics/#customizing-aws-configuration","title":"Customizing AWS Configuration","text":"<pre><code>from restmachine.adapters import create_asgi_app\n\n# Custom namespace and service name\nasgi_app = create_asgi_app(\n    app,\n    namespace=\"MyApp/Production\",\n    service_name=\"user-api\"\n)\n\n# High-resolution metrics (1-second)\nasgi_app = create_asgi_app(\n    app,\n    namespace=\"MyApp/API\",\n    metrics_resolution=1\n)\n</code></pre>"},{"location":"metrics/#environment-variables","title":"Environment Variables","text":"<p>Configure via environment variables (useful for different environments):</p> Variable Description Default <code>RESTMACHINE_METRICS_ENABLED</code> Force enable/disable metrics Auto-detect AWS <code>RESTMACHINE_METRICS_NAMESPACE</code> CloudWatch namespace <code>RestMachine</code> <code>RESTMACHINE_SERVICE_NAME</code> Service name dimension <code>asgi-app</code> <code>RESTMACHINE_METRICS_RESOLUTION</code> Resolution (1 or 60 seconds) <code>60</code>"},{"location":"metrics/#non-aws-environments","title":"Non-AWS Environments","text":"<p>For non-AWS platforms (local dev, GCP, Azure, on-prem), provide a custom publisher:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine.adapters import create_asgi_app\nfrom restmachine.metrics import MetricsPublisher\n\n# Example: Prometheus publisher\nclass PrometheusPublisher(MetricsPublisher):\n    def is_enabled(self) -&gt; bool:\n        return True\n\n    def publish(self, collector, request=None, response=None, context=None):\n        # Publish to Prometheus\n        pass\n\n# Explicit custom publisher\nasgi_app = create_asgi_app(app, metrics_publisher=PrometheusPublisher())\n</code></pre>"},{"location":"metrics/#disabling-metrics","title":"Disabling Metrics","text":"<pre><code># Explicitly disable (overrides auto-detection)\nasgi_app = create_asgi_app(app, enable_metrics=False)\n\n# Or via environment variable\n# RESTMACHINE_METRICS_ENABLED=false\n</code></pre>"},{"location":"metrics/#priority-order","title":"Priority Order","text":"<p>The adapter determines metrics configuration in this priority:</p> <ol> <li>Explicit <code>enable_metrics</code> parameter - Overrides everything</li> <li><code>RESTMACHINE_METRICS_ENABLED</code> env var - Overrides auto-detection</li> <li>AWS auto-detection - Enables EMF if AWS detected</li> <li>Default: disabled - No metrics if not in AWS</li> </ol>"},{"location":"metrics/#using-with-server-drivers","title":"Using with Server Drivers","text":"<p>The auto-detection also works when using RestMachine's server drivers (Uvicorn, Hypercorn):</p> <pre><code>from restmachine import RestApplication\nfrom restmachine.servers import serve\n\napp = RestApplication()\n\n@app.get(\"/data\")\ndef get_data(metrics):\n    metrics.add_metric(\"requests\", 1)\n    return {\"data\": \"value\"}\n\n# Auto-detects AWS and enables EMF\n# Metrics parameters passed through to ASGIAdapter\nserve(\n    app,\n    server=\"uvicorn\",\n    host=\"0.0.0.0\",\n    port=8000,\n    namespace=\"MyApp/API\",  # Passed to ASGIAdapter\n    service_name=\"api-server\"\n)\n</code></pre>"},{"location":"metrics/#best-practices","title":"Best Practices","text":""},{"location":"metrics/#1-use-descriptive-metric-names","title":"1. Use Descriptive Metric Names","text":"<pre><code># Good\nmetrics.add_metric(\"users.created\", 1)\nmetrics.add_metric(\"db.query.latency\", query_time)\n\n# Avoid\nmetrics.add_metric(\"count\", 1)\nmetrics.add_metric(\"time\", query_time)\n</code></pre>"},{"location":"metrics/#2-consistent-dimensions","title":"2. Consistent Dimensions","text":"<pre><code># Good - consistent dimensions across metrics\nmetrics.add_dimension(\"environment\", env)\nmetrics.add_dimension(\"region\", region)\n</code></pre>"},{"location":"metrics/#3-appropriate-units","title":"3. Appropriate Units","text":"<pre><code># Correct units for clarity\nmetrics.add_metric(\"api.latency\", 45.2, unit=MetricUnit.Milliseconds)\nmetrics.add_metric(\"db.connections\", 5, unit=MetricUnit.Count)\nmetrics.add_metric(\"response.size\", 1024, unit=MetricUnit.Bytes)\n</code></pre>"},{"location":"metrics/#4-timer-pattern","title":"4. Timer Pattern","text":"<pre><code>@app.get(\"/data\")\ndef fetch_data(metrics):\n    metrics.start_timer(\"operation.total\")\n\n    metrics.start_timer(\"operation.step1\")\n    step1()\n    metrics.stop_timer(\"operation.step1\")\n\n    metrics.start_timer(\"operation.step2\")\n    step2()\n    metrics.stop_timer(\"operation.step2\")\n\n    metrics.stop_timer(\"operation.total\")\n    return result\n</code></pre>"},{"location":"metrics/#5-dont-over-dimension","title":"5. Don't Over-dimension","text":"<pre><code># Avoid - too many dimensions\nfor key, value in request.headers.items():\n    metrics.add_dimension(key, value)\n\n# Better - selective dimensions + metadata\nmetrics.add_dimension(\"user_type\", user.type)\nmetrics.add_metadata(\"user_id\", user.id)\n</code></pre>"},{"location":"metrics/#disabling-metrics_1","title":"Disabling Metrics","text":"<p>When metrics are disabled, the collector is still created but publishing is skipped:</p> <pre><code># Disable via publisher\nadapter = AwsApiGatewayAdapter(app, enable_metrics=False)\n\n# Handler code works unchanged\n@app.get(\"/test\")\ndef handler(metrics):\n    # Metrics collected but not published\n    metrics.add_metric(\"requests\", 1)\n    return {\"ok\": True}\n</code></pre> <p>This allows you to keep metrics in code and control publishing via configuration.</p>"},{"location":"metrics/#platform-specific-documentation","title":"Platform-Specific Documentation","text":"<ul> <li>AWS CloudWatch (EMF) - Auto-configured CloudWatch metrics for Lambda</li> <li>Logging Configuration - Custom logging setup</li> <li>Performance Optimization - Metrics overhead and optimization</li> </ul>"},{"location":"metrics/#logging-configuration","title":"Logging Configuration","text":"<p>Metrics use a custom <code>METRICS</code> log level (25, between INFO and WARNING).</p>"},{"location":"metrics/#custom-log-level","title":"Custom Log Level","text":"<pre><code>import logging\nfrom restmachine.metrics import METRICS\n\n# METRICS = 25 (between INFO=20 and WARNING=30)\n</code></pre>"},{"location":"metrics/#manual-configuration","title":"Manual Configuration","text":"<pre><code>import logging\nfrom restmachine.metrics import METRICS\n\n# Configure metrics logger\nmetrics_logger = logging.getLogger(\"restmachine.metrics.emf\")\nmetrics_logger.setLevel(METRICS)\n\n# Add handler\nhandler = logging.StreamHandler()\nhandler.setLevel(METRICS)\nmetrics_logger.addHandler(handler)\n</code></pre>"},{"location":"metrics/#control-metrics-output","title":"Control Metrics Output","text":"<pre><code># Disable metrics logging\nlogging.getLogger(\"restmachine.metrics.emf\").setLevel(logging.WARNING)\n\n# Re-enable\nlogging.getLogger(\"restmachine.metrics.emf\").setLevel(METRICS)\n</code></pre>"},{"location":"metrics/#environment-specific","title":"Environment-Specific","text":"<pre><code>import os\n\nif os.environ.get(\"ENV\") == \"production\":\n    logging.getLogger(\"restmachine.metrics.emf\").setLevel(METRICS)\nelse:\n    # Disable in development\n    logging.getLogger(\"restmachine.metrics.emf\").setLevel(logging.CRITICAL)\n</code></pre>"},{"location":"metrics/#examples","title":"Examples","text":""},{"location":"metrics/#e-commerce-api","title":"E-commerce API","text":"<pre><code>@app.post(\"/orders\")\ndef create_order(order_data, metrics):\n    # Dimensions for grouping\n    metrics.add_dimension(\"order_type\", order_data.type)\n    metrics.add_dimension(\"payment_method\", order_data.payment)\n\n    # Time validation\n    metrics.start_timer(\"order.validation\")\n    validate(order_data)\n    metrics.stop_timer(\"order.validation\")\n\n    # Time creation\n    metrics.start_timer(\"order.creation\")\n    order = db.create_order(order_data)\n    metrics.stop_timer(\"order.creation\")\n\n    # Business metrics\n    metrics.add_metric(\"orders.created\", 1, unit=MetricUnit.Count)\n    metrics.add_metric(\"order.total\", order.total, unit=MetricUnit.None)\n\n    # Context metadata\n    metrics.add_metadata(\"order_id\", order.id)\n    metrics.add_metadata(\"customer_id\", order.customer_id)\n\n    return order\n</code></pre>"},{"location":"metrics/#multi-region-api","title":"Multi-Region API","text":"<pre><code>@app.get(\"/data\")\ndef get_data(metrics, region: str):\n    # Add region dimension\n    metrics.add_dimension(\"region\", region)\n\n    # Track by region\n    metrics.start_timer(f\"data.fetch.{region}\")\n    data = fetch_from_region(region)\n    metrics.stop_timer(f\"data.fetch.{region}\")\n\n    # Count and size\n    metrics.add_metric(\"data.fetched\", len(data), unit=MetricUnit.Count)\n    metrics.add_metric(\"data.size\", sys.getsizeof(data), unit=MetricUnit.Bytes)\n\n    return data\n</code></pre>"},{"location":"metrics/#troubleshooting","title":"Troubleshooting","text":""},{"location":"metrics/#metrics-dependency-is-none","title":"Metrics dependency is None","text":"<p>The metrics dependency is always available. If you're getting None:</p> <ol> <li>Check that your platform adapter is properly configured</li> <li>Verify the dependency injection is working</li> </ol>"},{"location":"metrics/#publisher-not-being-called","title":"Publisher not being called","text":"<ol> <li>Check <code>publisher.is_enabled()</code> returns True</li> <li>Verify publisher is passed to adapter</li> <li>Check logging configuration</li> </ol>"},{"location":"metrics/#performance-concerns","title":"Performance concerns","text":"<ul> <li>Metrics collection is lightweight (~0.1-0.5ms per request)</li> <li>Publishing happens after response is sent (non-blocking)</li> <li>Disable in development to reduce noise</li> </ul>"},{"location":"metrics/#related-documentation","title":"Related Documentation","text":"<ul> <li>AWS CloudWatch Metrics - CloudWatch EMF configuration</li> <li>Performance Optimization - Overhead and optimization</li> <li>Dependency Injection - Understanding DI in RestMachine</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"Unreleased","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>CORS Origin Reflection for Development: New <code>reflect_any_origin</code> parameter for credentials with wildcard origins</li> <li>Allows <code>origins=\"*\"</code> with <code>credentials=True</code> by reflecting the request's Origin header</li> <li>Useful for development environments with multiple frontend origins (localhost ports, emulators)</li> <li>Bypasses the security restriction preventing wildcard + credentials</li> <li>Includes validation: requires explicit <code>reflect_any_origin=True</code> flag</li> <li>Comprehensive documentation with security warnings (development-only feature)</li> <li>Full test coverage with 3 new tests in <code>TestCORSOriginReflection</code></li> <li>Works with both preflight (OPTIONS) and actual requests</li> <li>Available on <code>app.cors()</code>, <code>router.cors()</code>, and route-level <code>@app.cors()</code> decorator</li> <li>ASGI Adapter Support: Built-in ASGI 3.0 adapter for deployment with any ASGI server</li> <li>New <code>ASGIAdapter</code> class for creating ASGI applications</li> <li><code>create_asgi_app()</code> convenience function</li> <li>Full ASGI 3.0 protocol support (scope, receive, send)</li> <li>Works with Uvicorn, Hypercorn, Daphne, and other ASGI servers</li> <li>Proper async handling for HTTP request/response lifecycle</li> <li>Header normalization to lowercase (ASGI standard)</li> <li>UTF-8 with latin-1 fallback for body encoding</li> <li>Imported directly from main package: <code>from restmachine import ASGIAdapter, create_asgi_app</code></li> <li>Deploy with: <code>uvicorn app:asgi_app</code> or <code>hypercorn app:asgi_app</code></li> <li>Production-ready with Gunicorn workers: <code>gunicorn app:asgi_app -k uvicorn.workers.UvicornWorker</code></li> <li>ASGI Lifespan Protocol Support: Startup and shutdown event handlers</li> <li><code>@app.on_startup</code> decorator for registering startup handlers</li> <li><code>@app.on_shutdown</code> decorator for registering shutdown handlers</li> <li>Support for both sync and async handlers</li> <li>Multiple handlers can be registered and run in order</li> <li>Automatic integration with ASGI lifespan protocol</li> <li>Perfect for opening/closing database connections, loading models, etc.</li> <li>Startup failures properly reported to ASGI server</li> <li>Shutdown errors logged but don't prevent graceful shutdown</li> <li>Startup handlers automatically registered as session-scoped dependencies: Return values from startup handlers can be injected into route handlers and other dependencies</li> <li>Shutdown handlers support dependency injection: Shutdown handlers can inject session-scoped dependencies (like database connections from startup handlers) for proper cleanup</li> <li>Startup dependencies are cached across all requests (session scope) for optimal performance</li> <li>Startup handlers execute exactly once during ASGI lifespan startup, with return values immediately cached to prevent re-execution on first request</li> <li>Multiple startup handlers fully supported (e.g., database connection + API client initialization)</li> <li>ASGI TLS Extension Support: Full support for TLS/SSL connection information</li> <li><code>request.tls</code> boolean indicating whether connection uses TLS (HTTPS)</li> <li><code>request.client_cert</code> dictionary containing client certificate information for mutual TLS (mTLS)</li> <li>ASGI adapter automatically extracts TLS info from <code>scope[\"scheme\"]</code> and <code>scope[\"extensions\"][\"tls\"]</code></li> <li>AWS adapter always sets <code>tls=True</code> (API Gateway/ALB use HTTPS) and extracts mTLS client certificates</li> <li>API Gateway: Extracts from <code>requestContext.identity.clientCert</code></li> <li>ALB: Supports both verify mode (parsed headers) and passthrough mode (PEM certificate)</li> <li>Client certificate includes subject, issuer, serial number, and validity information</li> <li>Perfect for implementing certificate-based authentication and authorization</li> <li>Full ASGI 3.0 TLS extension compliance</li> <li>AWS Application Load Balancer (ALB) Support: Full support for ALB Lambda target groups</li> <li>Automatic detection of ALB vs API Gateway events</li> <li>Support for ALB multi-value headers and query parameters</li> <li>ALB mTLS verify mode: Certificate fields in <code>x-amzn-mtls-clientcert-subject</code>, <code>x-amzn-mtls-clientcert-issuer</code>, <code>x-amzn-mtls-clientcert-serial-number</code> headers</li> <li>ALB mTLS passthrough mode: Full PEM certificate in <code>x-amzn-mtls-clientcert</code> header</li> <li>Single adapter (<code>AwsApiGatewayAdapter</code>) handles both API Gateway and ALB events</li> <li>Separate internal parsing methods for clean separation of concerns</li> <li>AWS API Gateway HTTP API (v2) Support: Full support for both v1 (REST API) and v2 (HTTP API) payload formats</li> <li>Single <code>AwsApiGatewayAdapter</code> handles both v1 and v2 event formats</li> <li>Automatic version detection based on <code>version</code> field in event</li> <li>v1 (REST API): Uses <code>httpMethod</code>, <code>path</code>, <code>requestContext.identity.clientCert</code></li> <li>v2 (HTTP API): Uses <code>requestContext.http.method</code>, <code>rawPath</code>, <code>requestContext.authentication.clientCert</code>, <code>cookies</code> array</li> <li>Cookies from v2 events automatically combined into Cookie header</li> <li>Full feature parity between v1 and v2 (path params, query params, body, mTLS)</li> <li>Lambda Function URLs use v2 format and work seamlessly</li> <li>AWS Lambda Startup Support: Startup handlers now execute automatically during Lambda cold start</li> <li><code>AwsApiGatewayAdapter</code> automatically calls <code>app.startup_sync()</code> during initialization</li> <li>Enables database connections, API clients, and other resources to be initialized once per container</li> <li>Return values cached as session-scoped dependencies and reused across warm invocations</li> <li>Added <code>startup_sync()</code> and <code>shutdown_sync()</code> methods for synchronous startup/shutdown execution</li> <li>AWS Lambda Shutdown Support: Ready-to-use Lambda Extension for automatic shutdown handler execution</li> <li><code>ShutdownExtension</code> class for creating Lambda Extensions</li> <li>CLI command: <code>python -m restmachine_aws create-extension</code> generates ready-to-deploy extension</li> <li>Extension automatically calls <code>app.shutdown_sync()</code> when Lambda container terminates</li> <li>Enables proper cleanup of database connections, API clients, and other resources</li> <li>Environment variable customization: <code>RESTMACHINE_HANDLER_MODULE</code>, <code>RESTMACHINE_APP_NAME</code>, <code>RESTMACHINE_LOG_LEVEL</code></li> <li>Comprehensive tests and examples included</li> <li>Zero code changes required in handler - extension works automatically</li> <li>Multi-Value Headers: Full HTTP spec compliance for headers that can appear multiple times</li> <li>New <code>MultiValueHeaders</code> class replacing <code>CaseInsensitiveDict</code></li> <li>Support for multiple values per header name (Set-Cookie, Accept, Vary, etc.)</li> <li><code>.add(name, value)</code> method to append header values</li> <li><code>.get(name)</code> returns first value (backward compatible)</li> <li><code>.get_all(name)</code> returns all values for a header</li> <li><code>.items_all()</code> returns all (name, value) pairs including duplicates</li> <li>Case-insensitive header lookups per RFC 7230</li> <li>Dict-like interface for backward compatibility</li> <li>Proper header precedence: <code>.update()</code> replaces headers (not appends)</li> <li>Backward compatibility alias: <code>CaseInsensitiveDict = MultiValueHeaders</code></li> <li>Jinja2 Template Rendering Support: Rails-like template rendering with Jinja2</li> <li>New <code>render()</code> helper function for template rendering</li> <li>Support for file-based templates from <code>views</code> directory</li> <li>Support for inline template strings</li> <li>Template inheritance and all Jinja2 features (filters, macros, includes)</li> <li>Configurable template package/directory location</li> <li>XSS protection with autoescape enabled by default</li> <li>Optional <code>unsafe</code> parameter for trusted HTML content</li> <li>Comprehensive documentation with examples</li> <li>Example Templates: Professional starter templates included</li> <li><code>views/base.html</code> - Base layout with template inheritance</li> <li><code>views/user_detail.html</code> - User profile template</li> <li><code>views/post_detail.html</code> - Blog post template</li> <li><code>views/list.html</code> - Generic list rendering template</li> <li>Examples demonstrate inheritance, loops, conditionals, and filters</li> <li>Template Testing: Comprehensive test coverage for template rendering</li> <li>33 unit tests covering all rendering scenarios</li> <li>Tests for inline and file-based templates</li> <li>Security tests for XSS prevention</li> <li>Integration tests with RestApplication</li> <li>Template inheritance and Jinja2 feature tests</li> <li>Versioning Documentation: Complete guides for package versioning and releases</li> <li><code>docs/VERSIONING_AND_RELEASES.md</code> - Comprehensive versioning strategies</li> <li><code>docs/MONOREPO_VERSIONING.md</code> - Python monorepo versioning guide</li> <li><code>docs/VERSIONING_QUICK_START.md</code> - Quick start with ready-to-use examples</li> <li>Coverage of setuptools_scm, semantic-release, and CI/CD automation</li> <li>Tag-based, conventional commits, and manual release strategies</li> <li>Automatic Content-Length Header Injection: HTTP responses now automatically include Content-Length headers based on body size</li> <li>204 responses exclude Content-Length header (per HTTP spec)</li> <li>200 responses with body include correct byte length</li> <li>200 responses without body set Content-Length to 0</li> <li>Proper UTF-8 encoding support for Unicode content</li> <li>Automatic Vary Header Support: Responses automatically include Vary headers for proper caching behavior</li> <li><code>Vary: Authorization</code> when request contains Authorization header</li> <li><code>Vary: Accept</code> when endpoint supports multiple content types</li> <li>Combined as <code>Vary: Authorization, Accept</code> when both conditions apply</li> <li>Integrated with existing content negotiation system</li> <li>default_headers Decorator: New decorator for customizing response headers with dependency injection</li> <li>Global headers applied to all routes</li> <li>Route-specific headers for individual endpoints</li> <li>Full dependency injection support (request, body, query_params, etc.)</li> <li>Headers calculated per-request with proper scoping</li> <li>Vary header negotiated first and provided to header functions</li> <li>Error handling ensures failed header functions don't break responses</li> <li>Support for both in-place modification and return-based header updates</li> <li>Adapter System: New adapter architecture for deploying REST applications to different platforms</li> <li>Abstract <code>Adapter</code> base class for implementing platform-specific adapters</li> <li><code>AwsApiGatewayAdapter</code> for AWS Lambda + API Gateway deployment</li> <li>Automatic conversion between platform events and internal Request/Response objects</li> <li>Support for path parameters, query parameters, headers, and request bodies</li> <li>Base64 encoding/decoding support for binary content</li> <li>Robust handling of platform-specific edge cases (null values, missing fields)</li> <li>Comprehensive test coverage and example implementations</li> <li>Dependency Scopes: Support for request and session-scoped dependencies</li> <li><code>scope=\"request\"</code> (default): Dependencies are evaluated once per request and cleared between requests</li> <li><code>scope=\"session\"</code>: Dependencies are evaluated once and cached across all requests (perfect for database connections, API clients, etc.)</li> <li>All dependency decorators now support scope parameter: <code>@app.dependency()</code>, <code>@app.resource_exists()</code>, <code>@app.authorized()</code>, <code>@app.validates()</code>, etc.</li> <li>Separate caching for request and session scopes</li> <li>Request cache automatically cleared between requests, session cache persists</li> <li>Full backward compatibility - existing code uses default request scope</li> <li>Example: <code>@app.dependency(name=\"db\", scope=\"session\")</code> for reusable database connections</li> <li>Comprehensive test coverage with 20 new tests covering all scope behaviors</li> <li>Code Quality and Complexity Checks: Integrated Radon for automated maintainability analysis</li> <li>New <code>tox -e complexity</code> environment enforcing quality standards</li> <li>Cyclomatic Complexity monitoring (target: B or better, \u226410 per function)</li> <li>Maintainability Index tracking (target: B or better, \u226510 per file)</li> <li>Raw metrics reporting (LOC, LLOC, SLOC, comments)</li> <li>Current project average complexity: A (3.59) - excellent</li> <li>Total codebase: 7,501 LOC with 9% comment coverage</li> <li>Detailed documentation in <code>docs/CODE_QUALITY_STANDARDS.md</code></li> <li>JSON report generation available via <code>tox -e complexity-report</code></li> </ul>"},{"location":"about/changelog/#changed","title":"Changed","text":"<ul> <li>AWS Adapter Alignment: Updated AWS Lambda adapter to align with ASGI patterns</li> <li>Headers normalized to lowercase (matching ASGI standard)</li> <li>Consistent query parameter parsing with ASGI adapter</li> <li>Improved error handling with latin-1 fallback</li> <li>Uses <code>MultiValueHeaders</code> internally for proper multi-value header support</li> <li>Automatic Content-Type header for JSON responses</li> <li>No breaking changes for existing Lambda functions</li> <li>ASGI Adapter Architecture: Moved ASGI adapter to core package</li> <li><code>ASGIAdapter</code> moved from <code>server.py</code> to <code>adapters.py</code></li> <li>Clear separation: <code>Adapter</code> (sync for Lambda/Azure) vs <code>ASGIAdapter</code> (async for HTTP servers)</li> <li>Backward compatibility maintained via re-exports in <code>server.py</code></li> <li>Updated main package exports to include <code>ASGIAdapter</code> and <code>create_asgi_app</code></li> <li>Comprehensive documentation in <code>docs/ASGI_REFACTORING.md</code></li> <li>Router Architecture: Unified all routing through a single root router (PERFORMANCE)</li> <li>All routes now go through <code>RestApplication._root_router</code> (previously had dual storage with <code>_routes</code> list)</li> <li><code>@app.get()</code>, <code>@app.post()</code>, etc. now forward to the root router transparently</li> <li><code>app.mount()</code> forwards to <code>_root_router.mount()</code></li> <li>Eliminated duplicate route storage and matching logic (~100 lines removed)</li> <li>No breaking changes - all existing code works unchanged</li> <li>Route Matching: Implemented trie/tree-based routing for O(k) lookup performance (PERFORMANCE)</li> <li>Replaced O(n) regex matching with O(k) trie lookup (k = number of path segments, typically 2-5)</li> <li>Routes added to trie immediately during initialization (no lazy building, no runtime overhead)</li> <li>Static path segments use dict lookup, dynamic segments (<code>{id}</code>) handled separately</li> <li>Prioritizes static matches over parameter matches for correct precedence</li> <li>Dramatic performance improvement for applications with many routes</li> <li>No breaking changes - same route syntax and behavior</li> <li>Dependency System: Simplified to global-only dependency registration</li> <li>All dependencies are now registered globally and injected based on parameter names</li> <li>Removed brittle \"attach to most recent route\" pattern</li> <li>Dependencies automatically resolved by inspecting route handler parameters</li> <li>All dependency decorators (<code>@app.dependency</code>, <code>@app.validates</code>, <code>@app.accepts</code>, etc.) register globally</li> <li>Route-specific dependency dictionaries kept for backward compatibility but unused</li> <li>Cleaner mental model: define dependencies once, use anywhere</li> <li>No breaking changes - existing code continues to work</li> <li>Built-in Dependency Registration: Refactored built-in dependencies to use the same registration mechanism as user-defined dependencies</li> <li>Built-in dependencies (<code>request</code>, <code>body</code>, <code>exception</code>, <code>request_id</code>, <code>trace_id</code>, etc.) now registered during application initialization</li> <li>Removed separate code paths for built-in vs. custom dependencies (~70 lines of special-case logic eliminated)</li> <li>Simplified dependency resolution with unified handling for all dependency types</li> <li>Makes it trivial to add new built-in dependencies (just add one line to <code>_register_builtin_dependencies()</code>)</li> <li>No breaking changes - all existing functionality preserved</li> <li>Improved type safety with explicit type annotations</li> <li>Terminology Change: Renamed \"driver\" to \"adapter\" for platform adapters (BREAKING CHANGE)</li> <li><code>Driver</code> class renamed to <code>Adapter</code></li> <li><code>AwsApiGatewayDriver</code> renamed to <code>AwsApiGatewayAdapter</code></li> <li><code>restmachine/drivers.py</code> renamed to <code>restmachine/adapters.py</code></li> <li>Test framework drivers retain \"driver\" terminology (they implement a different pattern)</li> <li>Updated all imports, exports, and examples</li> <li>Migration: Replace <code>AwsApiGatewayDriver</code> with <code>AwsApiGatewayAdapter</code> and <code>from restmachine.drivers</code> with <code>from restmachine.adapters</code></li> <li>HTMLRenderer: Updated to use Jinja2 for template rendering</li> <li>Maintains backward compatibility with pre-rendered HTML strings</li> <li>Default templates now use Jinja2 for better structure and escaping</li> <li>Improved HTML generation for dictionaries and lists</li> <li>Integrated with new <code>render()</code> helper function</li> <li>Package Configuration: Migrated from setup.py to modern pyproject.toml (PEP 621)</li> <li>All metadata now in declarative pyproject.toml format</li> <li>Dependencies managed in <code>[project.dependencies]</code> and <code>[project.optional-dependencies]</code></li> <li>Removed setup.py (no longer needed with modern pip)</li> <li>Updated to use SPDX license identifier (\"MIT\")</li> <li>Added migration documentation in <code>docs/MIGRATION_TO_PYPROJECT.md</code></li> <li>Response Class Enhancement: Enhanced Response model to support pre-calculated headers</li> <li>Added <code>pre_calculated_headers</code> parameter for advanced header management</li> <li>Maintains backward compatibility with existing header logic</li> <li>Improved header precedence: pre-calculated \u2192 content-type \u2192 automatic (Content-Length, Vary)</li> <li>State Machine Integration: Updated request processing to handle header dependencies</li> <li>Headers dependencies processed before main handler execution</li> <li>Integrated with existing dependency injection and caching system</li> <li>Consistent error handling across all dependency types</li> <li>Enhanced Dependency Resolution: Improved dependency injection to support individual path parameters</li> <li>Path parameters can now be injected directly by name (e.g., <code>user_id</code> from <code>/users/{user_id}</code>)</li> <li>Maintains backward compatibility with existing <code>path_params</code> dictionary injection</li> <li>Automatic caching and resolution of path parameter values</li> </ul>"},{"location":"about/changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Nothing yet</li> </ul>"},{"location":"about/changelog/#removed","title":"Removed","text":"<ul> <li>restmachine-uvicorn and restmachine-hypercorn packages: Removed separate server packages</li> <li>No longer necessary with built-in ASGI adapter</li> <li>Users should use <code>ASGIAdapter</code> directly with their preferred ASGI server</li> <li>Simpler architecture: one core package with ASGI support built-in</li> <li>To migrate: Replace <code>restmachine-uvicorn</code> with <code>restmachine</code> and use <code>ASGIAdapter(app)</code></li> <li>Deploy directly: <code>uvicorn app:asgi_app</code> or <code>hypercorn app:asgi_app</code></li> <li>No functionality lost - all ASGI servers still supported via the adapter</li> <li>setup.py: Removed in favor of pyproject.toml-only configuration</li> <li>Modern pip (&gt;=21.3) works perfectly with just pyproject.toml</li> <li>No functionality lost, cleaner project structure</li> <li>See <code>docs/MIGRATION_TO_PYPROJECT.md</code> for details</li> </ul>"},{"location":"about/changelog/#fixed","title":"Fixed","text":"<ul> <li>Multi-Value Headers: Fixed HTTP spec violation where duplicate headers only kept last value</li> <li>Previous dict-based implementation only retained last value for duplicate header names</li> <li>Now properly supports headers that can appear multiple times per RFC 7230</li> <li>Critical for Set-Cookie, Accept, Vary, and other multi-value headers</li> <li><code>.update()</code> now properly replaces headers instead of accumulating them</li> <li>Fixed header precedence issues when merging default headers with response headers</li> <li>All 535 tests passing with full backward compatibility</li> <li>Type Checking: Enhanced type safety with stricter mypy checks</li> <li>Added <code>--check-untyped-defs</code> flag to catch more type errors</li> <li>Fixed type annotations in error_models.py for dict construction</li> <li>Added runtime validation for route_handler state</li> <li>All type checks now pass with stricter validation</li> <li>Type Checking: Fixed mypy type errors in template_helpers.py</li> <li>Added proper type annotations for Jinja2 loaders</li> <li>Used <code>Optional[BaseLoader]</code> for flexible loader types</li> <li>All type checks now pass without errors</li> <li>Security Issues: Resolved bandit security warnings</li> <li>Replaced <code>assert</code> with proper <code>if/raise</code> checks (prevents removal with Python -O flag)</li> <li>Replaced broad <code>except Exception</code> with specific exceptions</li> <li>Added <code># nosec B701</code> comment for intentional autoescape control</li> <li>Documented security considerations for <code>unsafe</code> parameter</li> <li>All security scans now pass</li> </ul>"},{"location":"about/changelog/#security","title":"Security","text":"<ul> <li>Template XSS Protection: Jinja2 templates have autoescape enabled by default</li> <li>Prevents XSS attacks in template rendering</li> <li><code>unsafe</code> parameter available for trusted content only</li> <li>Documented security best practices in template documentation</li> <li>Comprehensive security tests validate XSS prevention</li> </ul>"},{"location":"about/changelog/#010-2025-01-21","title":"0.1.0 - 2025-01-21","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of REST Framework</li> <li>Core application class with route registration</li> <li>HTTP method decorators (GET, POST, PUT, DELETE, PATCH)</li> <li>Dependency injection system with automatic caching</li> <li>Webmachine-inspired state machine for request processing</li> <li>Content negotiation with JSON, HTML, and plain text renderers</li> <li>Optional Pydantic integration for request/response validation</li> <li>State machine callbacks for service availability, authorization, etc.</li> <li>Resource existence checking with automatic 404 responses</li> <li>Custom content renderers for specific routes</li> <li>Comprehensive test suite</li> <li>Documentation and examples</li> </ul>"},{"location":"about/changelog/#features","title":"Features","text":"<ul> <li>Route Handlers: Simple decorator-based route registration</li> <li>Dependency Injection: pytest-style dependency injection</li> <li>State Machine States:</li> <li>B13: Route exists</li> <li>B12: Service available</li> <li>B11: Known method</li> <li>B10: URI too long</li> <li>B9: Method allowed</li> <li>B8: Malformed request</li> <li>B7: Authorized</li> <li>B6: Forbidden</li> <li>B5: Content headers valid</li> <li>G7: Resource exists</li> <li>C3: Content types provided</li> <li>C4: Content types accepted</li> <li>Content Negotiation: Automatic content type selection</li> <li>Validation: Automatic Pydantic model validation with 422 error responses</li> <li>Error Handling: Comprehensive HTTP status code handling</li> </ul>"},{"location":"about/changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Jinja2 (&gt;=3.0.0) - Required for template rendering</li> <li>anyio (&gt;=3.0.0) - Required for async/sync bridge in startup/shutdown handlers</li> <li>Optional Pydantic dependency for validation features</li> </ul>"},{"location":"about/changelog/#supported-python-versions","title":"Supported Python Versions","text":"<ul> <li>Python 3.8+</li> <li>Python 3.9</li> <li>Python 3.10  </li> <li>Python 3.11</li> <li>Python 3.12</li> </ul>"},{"location":"about/license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2025 REST Framework Contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"advanced/headers/","title":"Multi-Value Headers","text":"<p>RestMachine provides complete support for HTTP headers, including proper handling of multi-value headers according to the HTTP specification. This guide covers single and multi-value headers, cookies, caching, and best practices.</p>"},{"location":"advanced/headers/#understanding-multi-value-headers","title":"Understanding Multi-Value Headers","text":""},{"location":"advanced/headers/#http-specification","title":"HTTP Specification","text":"<p>The HTTP specification allows headers to have multiple values in two forms:</p> <ol> <li> <p>Multiple header lines with the same name: <pre><code>Set-Cookie: session_id=abc123; HttpOnly\nSet-Cookie: user_pref=dark_mode; Path=/\n</code></pre></p> </li> <li> <p>Comma-separated values in a single header: <pre><code>Accept: text/html, application/json\nCache-Control: no-cache, no-store, must-revalidate\n</code></pre></p> </li> </ol> <p>RestMachine handles both forms correctly and provides APIs for working with multi-value headers.</p>"},{"location":"advanced/headers/#reading-headers","title":"Reading Headers","text":""},{"location":"advanced/headers/#single-value-headers","title":"Single-Value Headers","text":"<p>Access most headers as single values:</p> <pre><code>from restmachine import RestApplication, Request\n\napp = RestApplication()\n\n@app.get('/api/data')\ndef get_data(request: Request):\n    \"\"\"Access single-value headers.\"\"\"\n    # Get content type\n    content_type = request.headers.get('content-type', 'application/json')\n\n    # Get authorization header\n    auth = request.headers.get('authorization')\n\n    # Get user agent\n    user_agent = request.headers.get('user-agent')\n\n    # Check if header exists\n    has_api_key = 'x-api-key' in request.headers\n\n    return {\n        \"content_type\": content_type,\n        \"has_auth\": auth is not None,\n        \"user_agent\": user_agent\n    }\n</code></pre>"},{"location":"advanced/headers/#multi-value-headers_1","title":"Multi-Value Headers","text":"<p>Some headers can have multiple values:</p> <pre><code>@app.get('/api/negotiation')\ndef content_negotiation(request: Request):\n    \"\"\"Handle multi-value Accept header.\"\"\"\n    # Accept header may have multiple values\n    accept = request.headers.get('accept', '*/*')\n\n    # Parse comma-separated values\n    accepted_types = [\n        t.strip().split(';')[0]  # Remove quality parameters\n        for t in accept.split(',')\n    ]\n\n    # Select appropriate format\n    if 'application/json' in accepted_types:\n        return {\"format\": \"json\"}\n    elif 'text/html' in accepted_types:\n        return \"&lt;html&gt;&lt;body&gt;HTML Response&lt;/body&gt;&lt;/html&gt;\", 200, {\n            'Content-Type': 'text/html'\n        }\n    else:\n        return {\"format\": \"default\"}\n</code></pre>"},{"location":"advanced/headers/#reading-all-headers","title":"Reading All Headers","text":"<p>Access all headers as a dictionary:</p> <pre><code>@app.get('/debug/headers')\ndef show_headers(request: Request):\n    \"\"\"Show all request headers.\"\"\"\n    # Get all headers as dict\n    all_headers = dict(request.headers)\n\n    # Filter sensitive headers\n    safe_headers = {\n        k: v for k, v in all_headers.items()\n        if k.lower() not in ['authorization', 'cookie']\n    }\n\n    return {\n        \"headers\": safe_headers,\n        \"count\": len(all_headers)\n    }\n</code></pre>"},{"location":"advanced/headers/#setting-response-headers","title":"Setting Response Headers","text":""},{"location":"advanced/headers/#single-headers","title":"Single Headers","text":"<p>Set single-value response headers:</p> <pre><code>@app.get('/api/data')\ndef get_data():\n    \"\"\"Return data with custom headers.\"\"\"\n    data = {\"message\": \"Hello\"}\n\n    headers = {\n        'Content-Type': 'application/json',\n        'X-API-Version': '1.0',\n        'X-Request-ID': 'abc-123-def'\n    }\n\n    return data, 200, headers\n</code></pre>"},{"location":"advanced/headers/#multi-value-headers_2","title":"Multi-Value Headers","text":"<p>Set headers that appear multiple times:</p> <pre><code>@app.get('/api/multi-header')\ndef multi_header_example():\n    \"\"\"Demonstrate multi-value headers.\"\"\"\n    # For Set-Cookie and other multi-value headers,\n    # use MultiValueHeaders\n    from restmachine.models import MultiValueHeaders\n\n    headers = MultiValueHeaders()\n\n    # Add multiple Set-Cookie headers\n    headers.append('Set-Cookie', 'session_id=abc123; HttpOnly; SameSite=Lax')\n    headers.append('Set-Cookie', 'user_pref=dark; Path=/')\n    headers.append('Set-Cookie', 'lang=en; Max-Age=31536000')\n\n    # Add single-value headers\n    headers['Content-Type'] = 'application/json'\n    headers['X-Custom'] = 'value'\n\n    return {\"status\": \"ok\"}, 200, headers\n</code></pre>"},{"location":"advanced/headers/#working-with-cookies","title":"Working with Cookies","text":""},{"location":"advanced/headers/#setting-cookies","title":"Setting Cookies","text":"<p>Set cookies with proper attributes:</p> <pre><code>from datetime import datetime, timedelta\n\n@app.post('/auth/login')\ndef login(request: Request):\n    \"\"\"Set authentication cookies.\"\"\"\n    from restmachine.models import MultiValueHeaders\n\n    headers = MultiValueHeaders()\n\n    # Session cookie (expires when browser closes)\n    headers.append(\n        'Set-Cookie',\n        'session_id=abc123; HttpOnly; Secure; SameSite=Strict; Path=/'\n    )\n\n    # Persistent cookie (expires in 7 days)\n    max_age = 7 * 24 * 60 * 60  # 7 days in seconds\n    headers.append(\n        'Set-Cookie',\n        f'remember_token=xyz789; HttpOnly; Secure; SameSite=Lax; '\n        f'Max-Age={max_age}; Path=/'\n    )\n\n    # Preferences cookie (not sensitive)\n    headers.append(\n        'Set-Cookie',\n        'theme=dark; SameSite=Lax; Max-Age=31536000; Path=/'\n    )\n\n    return {\"message\": \"Logged in\"}, 200, headers\n</code></pre>"},{"location":"advanced/headers/#reading-cookies","title":"Reading Cookies","text":"<p>Parse cookies from request:</p> <pre><code>@app.dependency()\ndef parse_cookies(request: Request) -&gt; dict:\n    \"\"\"Parse cookies from Cookie header.\"\"\"\n    cookie_header = request.headers.get('cookie', '')\n\n    cookies = {}\n    for cookie in cookie_header.split(';'):\n        cookie = cookie.strip()\n        if '=' in cookie:\n            name, value = cookie.split('=', 1)\n            cookies[name] = value\n\n    return cookies\n\n@app.get('/api/profile')\ndef get_profile(parse_cookies: dict):\n    \"\"\"Access user profile using session cookie.\"\"\"\n    session_id = parse_cookies.get('session_id')\n\n    if not session_id:\n        from restmachine import Response\n        return Response(401, '{\"error\": \"Not authenticated\"}')\n\n    return {\n        \"session_id\": session_id,\n        \"theme\": parse_cookies.get('theme', 'light')\n    }\n</code></pre>"},{"location":"advanced/headers/#deleting-cookies","title":"Deleting Cookies","text":"<p>Delete cookies by setting Max-Age=0:</p> <pre><code>@app.post('/auth/logout')\ndef logout():\n    \"\"\"Clear authentication cookies.\"\"\"\n    from restmachine.models import MultiValueHeaders\n\n    headers = MultiValueHeaders()\n\n    # Delete cookies by setting Max-Age=0\n    headers.append(\n        'Set-Cookie',\n        'session_id=; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=0'\n    )\n\n    headers.append(\n        'Set-Cookie',\n        'remember_token=; HttpOnly; Secure; SameSite=Lax; Path=/; Max-Age=0'\n    )\n\n    return {\"message\": \"Logged out\"}, 200, headers\n</code></pre>"},{"location":"advanced/headers/#caching-headers","title":"Caching Headers","text":""},{"location":"advanced/headers/#cache-control","title":"Cache-Control","text":"<p>Set appropriate cache control headers:</p> <pre><code>@app.get('/api/static-data')\ndef static_data():\n    \"\"\"Cacheable static data.\"\"\"\n    data = {\"version\": \"1.0\", \"data\": [...]}\n\n    headers = {\n        'Cache-Control': 'public, max-age=3600',  # Cache for 1 hour\n        'ETag': '\"abc123\"',\n        'Vary': 'Accept-Encoding'\n    }\n\n    return data, 200, headers\n\n@app.get('/api/dynamic-data')\ndef dynamic_data():\n    \"\"\"Non-cacheable dynamic data.\"\"\"\n    data = {\"timestamp\": datetime.now().isoformat()}\n\n    headers = {\n        'Cache-Control': 'no-cache, no-store, must-revalidate',\n        'Pragma': 'no-cache',\n        'Expires': '0'\n    }\n\n    return data, 200, headers\n\n@app.get('/api/user-data')\ndef user_data():\n    \"\"\"Private user data (cache per user).\"\"\"\n    data = {\"user\": \"alice\", \"data\": [...]}\n\n    headers = {\n        'Cache-Control': 'private, max-age=300',  # Cache for 5 minutes\n        'Vary': 'Authorization'\n    }\n\n    return data, 200, headers\n</code></pre>"},{"location":"advanced/headers/#etags-for-conditional-requests","title":"ETags for Conditional Requests","text":"<p>Implement ETags for efficient caching:</p> <pre><code>import hashlib\nimport json\n\n@app.dependency()\ndef database():\n    return {\n        \"users\": [\n            {\"id\": \"1\", \"name\": \"Alice\", \"updated_at\": \"2024-01-01T10:00:00\"}\n        ]\n    }\n\n@app.get('/api/users/{user_id}')\ndef get_user(request: Request, database):\n    \"\"\"Get user with ETag support.\"\"\"\n    user_id = request.path_params['user_id']\n    user = next((u for u in database['users'] if u['id'] == user_id), None)\n\n    if not user:\n        from restmachine import Response\n        return Response(404, '{\"error\": \"User not found\"}')\n\n    # Calculate ETag from user data\n    user_json = json.dumps(user, sort_keys=True)\n    etag = hashlib.md5(user_json.encode()).hexdigest()\n    etag_header = f'\"{etag}\"'\n\n    # Check If-None-Match header\n    if_none_match = request.headers.get('if-none-match')\n    if if_none_match == etag_header:\n        # Resource unchanged\n        return '', 304, {'ETag': etag_header}\n\n    # Resource changed or first request\n    headers = {\n        'ETag': etag_header,\n        'Cache-Control': 'private, must-revalidate'\n    }\n\n    return user, 200, headers\n</code></pre>"},{"location":"advanced/headers/#cors-headers","title":"CORS Headers","text":""},{"location":"advanced/headers/#basic-cors","title":"Basic CORS","text":"<p>Handle Cross-Origin Resource Sharing:</p> <pre><code>@app.dependency()\ndef add_cors_headers():\n    \"\"\"CORS headers dependency.\"\"\"\n    return {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n        'Access-Control-Max-Age': '86400'  # 24 hours\n    }\n\n@app.options('/api/users')\ndef users_options(add_cors_headers):\n    \"\"\"Handle preflight request.\"\"\"\n    return '', 204, add_cors_headers\n\n@app.get('/api/users')\ndef list_users(database, add_cors_headers):\n    \"\"\"List users with CORS.\"\"\"\n    return database['users'], 200, add_cors_headers\n</code></pre>"},{"location":"advanced/headers/#conditional-cors","title":"Conditional CORS","text":"<p>Allow specific origins only:</p> <pre><code>ALLOWED_ORIGINS = [\n    'https://example.com',\n    'https://app.example.com',\n    'http://localhost:3000'\n]\n\n@app.dependency()\ndef cors_headers(request: Request):\n    \"\"\"Generate CORS headers based on origin.\"\"\"\n    origin = request.headers.get('origin')\n\n    if origin in ALLOWED_ORIGINS:\n        return {\n            'Access-Control-Allow-Origin': origin,\n            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',\n            'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n            'Access-Control-Allow-Credentials': 'true',\n            'Access-Control-Max-Age': '86400'\n        }\n\n    return {}\n\n@app.get('/api/data')\ndef get_data(cors_headers):\n    \"\"\"Return data with CORS if origin allowed.\"\"\"\n    return {\"data\": [...]}, 200, cors_headers\n</code></pre>"},{"location":"advanced/headers/#security-headers","title":"Security Headers","text":""},{"location":"advanced/headers/#common-security-headers","title":"Common Security Headers","text":"<p>Set security headers to protect your application:</p> <pre><code>@app.dependency()\ndef security_headers():\n    \"\"\"Common security headers.\"\"\"\n    return {\n        'X-Content-Type-Options': 'nosniff',\n        'X-Frame-Options': 'DENY',\n        'X-XSS-Protection': '1; mode=block',\n        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\n        'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline'\",\n        'Referrer-Policy': 'strict-origin-when-cross-origin'\n    }\n\n@app.get('/api/secure-data')\ndef secure_data(security_headers):\n    \"\"\"Return data with security headers.\"\"\"\n    return {\"data\": \"sensitive\"}, 200, security_headers\n</code></pre>"},{"location":"advanced/headers/#content-security-policy","title":"Content Security Policy","text":"<p>Set detailed CSP headers:</p> <pre><code>@app.get('/app')\ndef web_app():\n    \"\"\"Serve web app with CSP.\"\"\"\n    html = \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;&lt;title&gt;Secure App&lt;/title&gt;&lt;/head&gt;\n    &lt;body&gt;&lt;h1&gt;Secure Application&lt;/h1&gt;&lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    csp_directives = [\n        \"default-src 'self'\",\n        \"script-src 'self' https://cdn.example.com\",\n        \"style-src 'self' 'unsafe-inline'\",\n        \"img-src 'self' data: https:\",\n        \"font-src 'self' https://fonts.googleapis.com\",\n        \"connect-src 'self' https://api.example.com\",\n        \"frame-ancestors 'none'\",\n        \"base-uri 'self'\",\n        \"form-action 'self'\"\n    ]\n\n    headers = {\n        'Content-Type': 'text/html',\n        'Content-Security-Policy': '; '.join(csp_directives)\n    }\n\n    return html, 200, headers\n</code></pre>"},{"location":"advanced/headers/#custom-headers","title":"Custom Headers","text":""},{"location":"advanced/headers/#request-id-tracking","title":"Request ID Tracking","text":"<p>Track requests with unique IDs:</p> <pre><code>import uuid\n\n@app.dependency()\ndef request_id(request: Request) -&gt; str:\n    \"\"\"Get or generate request ID.\"\"\"\n    return request.headers.get('x-request-id', str(uuid.uuid4()))\n\n@app.get('/api/data')\ndef get_data(request_id: str):\n    \"\"\"Return data with request ID.\"\"\"\n    data = {\"message\": \"Hello\"}\n\n    headers = {\n        'X-Request-ID': request_id\n    }\n\n    return data, 200, headers\n</code></pre>"},{"location":"advanced/headers/#rate-limit-headers","title":"Rate Limit Headers","text":"<p>Communicate rate limits to clients:</p> <pre><code>from datetime import datetime, timedelta\n\n@app.dependency()\ndef rate_limit_headers(request: Request):\n    \"\"\"Calculate rate limit headers.\"\"\"\n    # Simplified rate limiting\n    limit = 100\n    remaining = 75\n    reset_time = datetime.now() + timedelta(hours=1)\n\n    return {\n        'X-RateLimit-Limit': str(limit),\n        'X-RateLimit-Remaining': str(remaining),\n        'X-RateLimit-Reset': str(int(reset_time.timestamp()))\n    }\n\n@app.get('/api/data')\ndef get_data(rate_limit_headers):\n    \"\"\"Return data with rate limit info.\"\"\"\n    return {\"data\": [...]}, 200, rate_limit_headers\n</code></pre>"},{"location":"advanced/headers/#header-middleware-pattern","title":"Header Middleware Pattern","text":""},{"location":"advanced/headers/#global-header-injection","title":"Global Header Injection","text":"<p>Add headers to all responses:</p> <pre><code>@app.dependency()\ndef common_headers(request: Request):\n    \"\"\"Headers added to all responses.\"\"\"\n    headers = {\n        'X-API-Version': '1.0',\n        'X-Powered-By': 'RestMachine',\n        'X-Request-Time': datetime.now().isoformat()\n    }\n\n    # Add security headers\n    headers.update({\n        'X-Content-Type-Options': 'nosniff',\n        'X-Frame-Options': 'DENY'\n    })\n\n    return headers\n\n# Include common_headers in all routes\n@app.get('/api/users')\ndef list_users(database, common_headers):\n    return database['users'], 200, common_headers\n\n@app.get('/api/posts')\ndef list_posts(database, common_headers):\n    return database['posts'], 200, common_headers\n</code></pre>"},{"location":"advanced/headers/#complete-example","title":"Complete Example","text":"<p>Here's a complete example with comprehensive header handling:</p> <pre><code>from restmachine import RestApplication, Request\nfrom restmachine.models import MultiValueHeaders\nfrom datetime import datetime, timedelta\nimport hashlib\nimport json\nimport uuid\n\napp = RestApplication()\n\n# Database\n@app.on_startup\ndef database():\n    return {\n        \"users\": [\n            {\"id\": \"1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n        ]\n    }\n\n# Common dependencies\n@app.dependency()\ndef request_id(request: Request) -&gt; str:\n    \"\"\"Get or generate request ID.\"\"\"\n    return request.headers.get('x-request-id', str(uuid.uuid4()))\n\n@app.dependency()\ndef security_headers():\n    \"\"\"Security headers for all responses.\"\"\"\n    return {\n        'X-Content-Type-Options': 'nosniff',\n        'X-Frame-Options': 'DENY',\n        'Strict-Transport-Security': 'max-age=31536000'\n    }\n\n@app.dependency()\ndef cors_headers(request: Request):\n    \"\"\"CORS headers.\"\"\"\n    origin = request.headers.get('origin', '')\n\n    if origin.endswith('.example.com') or origin == 'http://localhost:3000':\n        return {\n            'Access-Control-Allow-Origin': origin,\n            'Access-Control-Allow-Credentials': 'true'\n        }\n\n    return {}\n\n# Routes with caching\n@app.get('/api/users/{user_id}')\ndef get_user(request: Request, database, security_headers):\n    \"\"\"Get user with ETag caching.\"\"\"\n    user_id = request.path_params['user_id']\n    user = next((u for u in database['users'] if u['id'] == user_id), None)\n\n    if not user:\n        from restmachine import Response\n        return Response(404, '{\"error\": \"Not found\"}')\n\n    # Calculate ETag\n    user_json = json.dumps(user, sort_keys=True)\n    etag = f'\"{hashlib.md5(user_json.encode()).hexdigest()}\"'\n\n    # Check If-None-Match\n    if request.headers.get('if-none-match') == etag:\n        headers = {**security_headers, 'ETag': etag}\n        return '', 304, headers\n\n    # Return user with caching headers\n    headers = {\n        **security_headers,\n        'ETag': etag,\n        'Cache-Control': 'private, max-age=300',\n        'Vary': 'Accept-Encoding'\n    }\n\n    return user, 200, headers\n\n# Routes with cookies\n@app.post('/auth/login')\ndef login(security_headers):\n    \"\"\"Login with cookies.\"\"\"\n    headers = MultiValueHeaders()\n\n    # Add security headers\n    for key, value in security_headers.items():\n        headers[key] = value\n\n    # Set authentication cookies\n    headers.append(\n        'Set-Cookie',\n        'session_id=abc123; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=3600'\n    )\n\n    headers.append(\n        'Set-Cookie',\n        'csrf_token=xyz789; SameSite=Strict; Path=/; Max-Age=3600'\n    )\n\n    return {\"message\": \"Logged in\"}, 200, headers\n\n@app.post('/auth/logout')\ndef logout(security_headers):\n    \"\"\"Logout and clear cookies.\"\"\"\n    headers = MultiValueHeaders()\n\n    for key, value in security_headers.items():\n        headers[key] = value\n\n    # Clear cookies\n    headers.append(\n        'Set-Cookie',\n        'session_id=; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=0'\n    )\n\n    headers.append(\n        'Set-Cookie',\n        'csrf_token=; SameSite=Strict; Path=/; Max-Age=0'\n    )\n\n    return {\"message\": \"Logged out\"}, 200, headers\n\n# CORS preflight\n@app.options('/api/users')\ndef users_options(cors_headers, security_headers):\n    \"\"\"Handle CORS preflight.\"\"\"\n    headers = {\n        **cors_headers,\n        **security_headers,\n        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n        'Access-Control-Max-Age': '86400'\n    }\n\n    return '', 204, headers\n\n# ASGI\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n</code></pre>"},{"location":"advanced/headers/#best-practices","title":"Best Practices","text":""},{"location":"advanced/headers/#1-use-secure-cookie-attributes","title":"1. Use Secure Cookie Attributes","text":"<p>Always set secure attributes for cookies:</p> <pre><code># Good: Secure cookie\nheaders.append(\n    'Set-Cookie',\n    'session_id=abc; HttpOnly; Secure; SameSite=Strict; Path=/'\n)\n\n# Bad: Insecure cookie\nheaders.append('Set-Cookie', 'session_id=abc')\n</code></pre>"},{"location":"advanced/headers/#2-set-appropriate-cache-headers","title":"2. Set Appropriate Cache Headers","text":"<p>Cache static content, not dynamic:</p> <pre><code># Cache static data\n@app.get('/api/config')\ndef get_config():\n    return config, 200, {'Cache-Control': 'public, max-age=86400'}\n\n# Don't cache user-specific data\n@app.get('/api/profile')\ndef get_profile(current_user):\n    return profile, 200, {'Cache-Control': 'private, no-cache'}\n</code></pre>"},{"location":"advanced/headers/#3-use-security-headers","title":"3. Use Security Headers","text":"<p>Always include security headers:</p> <pre><code>security_headers = {\n    'X-Content-Type-Options': 'nosniff',\n    'X-Frame-Options': 'DENY',\n    'Strict-Transport-Security': 'max-age=31536000'\n}\n</code></pre>"},{"location":"advanced/headers/#4-handle-cors-properly","title":"4. Handle CORS Properly","text":"<p>Validate origins for CORS:</p> <pre><code># Good: Validate origin\nif origin in ALLOWED_ORIGINS:\n    headers['Access-Control-Allow-Origin'] = origin\n\n# Bad: Allow all origins with credentials\nheaders['Access-Control-Allow-Origin'] = '*'\nheaders['Access-Control-Allow-Credentials'] = 'true'  # Invalid!\n</code></pre>"},{"location":"advanced/headers/#5-use-multivalueheaders-for-set-cookie","title":"5. Use MultiValueHeaders for Set-Cookie","text":"<p>Use MultiValueHeaders for headers that can appear multiple times:</p> <pre><code>from restmachine.models import MultiValueHeaders\n\nheaders = MultiValueHeaders()\nheaders.append('Set-Cookie', 'session=abc')\nheaders.append('Set-Cookie', 'theme=dark')\n</code></pre>"},{"location":"advanced/headers/#next-steps","title":"Next Steps","text":"<ul> <li>TLS \u2192 - Secure communications with TLS</li> <li>Authentication \u2192 - Use headers for auth</li> <li>Caching \u2192 - Advanced caching strategies</li> <li>Testing \u2192 - Test header handling</li> </ul>"},{"location":"advanced/lifecycle/","title":"Startup &amp; Shutdown Handlers","text":"<p>RestMachine provides lifecycle hooks to manage application startup and shutdown events. These handlers are useful for initializing resources (database connections, caches, etc.) and cleaning them up when the application stops.</p>"},{"location":"advanced/lifecycle/#overview","title":"Overview","text":"<p>Lifecycle handlers allow you to:</p> <ul> <li>Initialize resources once when the application starts</li> <li>Share initialized resources across all requests via dependency injection</li> <li>Clean up resources when the application shuts down</li> <li>Execute async or sync initialization/cleanup code</li> </ul>"},{"location":"advanced/lifecycle/#startup-handlers","title":"Startup Handlers","text":"<p>Startup handlers run when the application starts and can return values that are automatically registered as dependencies.</p>"},{"location":"advanced/lifecycle/#basic-usage","title":"Basic Usage","text":"<pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.on_startup\ndef database():\n    print(\"Connecting to database...\")\n    return create_database_connection()\n\n@app.get(\"/users\")\ndef get_users(database):  # database from startup is injected\n    return database.query(\"SELECT * FROM users\")\n</code></pre>"},{"location":"advanced/lifecycle/#key-features","title":"Key Features","text":"<p>Automatic Dependency Injection - Startup handler return values are automatically registered as dependencies - Available to all route handlers by parameter name - Session-scoped (cached for the lifetime of the application)</p> <p>Sync and Async Support <pre><code>@app.on_startup\nasync def async_database():\n    conn = await asyncpg.connect(DATABASE_URL)\n    return conn\n\n@app.on_startup\ndef sync_cache():\n    return redis.Redis(host='localhost', port=6379)\n</code></pre></p>"},{"location":"advanced/lifecycle/#multiple-startup-handlers","title":"Multiple Startup Handlers","text":"<p>You can register multiple startup handlers, and all their return values will be available as dependencies:</p> <pre><code>@app.on_startup\ndef database():\n    return create_database_connection()\n\n@app.on_startup\ndef cache():\n    return create_redis_connection()\n\n@app.on_startup\ndef config():\n    return load_configuration()\n\n@app.get(\"/status\")\ndef status(database, cache, config):\n    return {\n        \"db\": database.is_connected(),\n        \"cache\": cache.ping(),\n        \"config\": config.version\n    }\n</code></pre>"},{"location":"advanced/lifecycle/#startup-handlers-with-dependencies","title":"Startup Handlers with Dependencies","text":"<p>Startup handlers can depend on other startup handlers that were registered earlier:</p> <pre><code>@app.on_startup\ndef config():\n    return {\n        \"db_url\": \"postgresql://localhost/mydb\",\n        \"cache_url\": \"redis://localhost:6379\"\n    }\n\n@app.on_startup\ndef database(config):  # Depends on config startup handler\n    return connect_database(config[\"db_url\"])\n\n@app.on_startup\ndef cache(config):  # Also depends on config\n    return connect_redis(config[\"cache_url\"])\n</code></pre>"},{"location":"advanced/lifecycle/#shutdown-handlers","title":"Shutdown Handlers","text":"<p>Shutdown handlers run when the application stops, allowing you to clean up resources properly.</p>"},{"location":"advanced/lifecycle/#basic-usage_1","title":"Basic Usage","text":"<pre><code>@app.on_shutdown\ndef cleanup():\n    print(\"Closing connections...\")\n    # Close database, cache, etc.\n</code></pre>"},{"location":"advanced/lifecycle/#cleanup-with-dependencies","title":"Cleanup with Dependencies","text":"<p>Shutdown handlers can access startup handler dependencies to properly close resources:</p> <pre><code>@app.on_startup\ndef database():\n    return create_database_connection()\n\n@app.on_shutdown\ndef close_database(database):  # Receives database from startup\n    print(\"Closing database connection...\")\n    database.close()\n</code></pre>"},{"location":"advanced/lifecycle/#multiple-shutdown-handlers","title":"Multiple Shutdown Handlers","text":"<pre><code>@app.on_shutdown\ndef close_database(database):\n    database.close()\n\n@app.on_shutdown\ndef close_cache(cache):\n    cache.disconnect()\n\n@app.on_shutdown\nasync def cleanup_temp_files():\n    await remove_temp_files()\n</code></pre>"},{"location":"advanced/lifecycle/#shutdown-order","title":"Shutdown Order","text":"<p>Shutdown handlers run in the order they were registered. If you need specific cleanup order, register handlers accordingly:</p> <pre><code># This runs first\n@app.on_shutdown\ndef close_sessions():\n    session_manager.close_all()\n\n# This runs second\n@app.on_shutdown\ndef close_database():\n    database.disconnect()\n</code></pre>"},{"location":"advanced/lifecycle/#complete-example","title":"Complete Example","text":"<p>Here's a complete example with database connection pooling and proper cleanup:</p> <pre><code>from restmachine import RestApplication\nimport psycopg2.pool\n\napp = RestApplication()\n\n@app.on_startup\ndef database_pool():\n    \"\"\"Create a connection pool at startup.\"\"\"\n    print(\"Creating database connection pool...\")\n    pool = psycopg2.pool.ThreadedConnectionPool(\n        minconn=5,\n        maxconn=20,\n        host='localhost',\n        database='mydb',\n        user='user',\n        password='password'\n    )\n    return pool\n\n@app.dependency()\ndef database_connection(database_pool):\n    \"\"\"Get a connection from the pool for each request.\"\"\"\n    conn = database_pool.getconn()\n    try:\n        yield conn\n    finally:\n        database_pool.putconn(conn)\n\n@app.on_shutdown\ndef close_database_pool(database_pool):\n    \"\"\"Close all connections when shutting down.\"\"\"\n    print(\"Closing database connection pool...\")\n    database_pool.closeall()\n\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int, database_connection):\n    cursor = database_connection.cursor()\n    cursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n    user = cursor.fetchone()\n    cursor.close()\n    return {\"id\": user[0], \"name\": user[1]} if user else None\n</code></pre>"},{"location":"advanced/lifecycle/#asgi-lifecycle-integration","title":"ASGI Lifecycle Integration","text":"<p>When running with an ASGI server, lifecycle handlers are integrated with ASGI lifespan events:</p>"},{"location":"advanced/lifecycle/#uvicorn","title":"Uvicorn","text":"<pre><code># app.py\nfrom restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n@app.on_startup\nasync def startup():\n    print(\"Application starting...\")\n    # Initialize resources\n\n@app.on_shutdown\nasync def shutdown():\n    print(\"Application shutting down...\")\n    # Cleanup resources\n\n# Run with:\n# uvicorn app:asgi_app\nasgi_app = ASGIAdapter(app)\n</code></pre>"},{"location":"advanced/lifecycle/#hypercorn","title":"Hypercorn","text":"<pre><code># Works the same with Hypercorn\n# hypercorn app:asgi_app\n</code></pre>"},{"location":"advanced/lifecycle/#aws-lambda","title":"AWS Lambda","text":"<p>In Lambda, startup handlers run once per container initialization (cold start), and shutdown handlers run when the Lambda execution environment is terminated:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.on_startup\ndef init_resources():\n    # Runs once per Lambda container initialization\n    return expensive_resource()\n\n@app.get(\"/process\")\ndef process(init_resources):\n    # Reuses the same resource across warm invocations\n    return init_resources.process()\n\n# Lambda handler - use restmachine-aws package for Lambda support\n# from restmachine_aws import LambdaAdapter\n# handler = LambdaAdapter(app)\n</code></pre>"},{"location":"advanced/lifecycle/#best-practices","title":"Best Practices","text":""},{"location":"advanced/lifecycle/#1-use-startup-handlers-for-expensive-initialization","title":"1. Use Startup Handlers for Expensive Initialization","text":"<pre><code>@app.on_startup\ndef ml_model():\n    \"\"\"Load ML model once at startup, not per request.\"\"\"\n    return load_large_model()\n\n@app.post(\"/predict\")\ndef predict(data: dict, ml_model):\n    return {\"prediction\": ml_model.predict(data)}\n</code></pre>"},{"location":"advanced/lifecycle/#2-always-clean-up-resources","title":"2. Always Clean Up Resources","text":"<pre><code>@app.on_startup\ndef file_handle():\n    return open('data.txt', 'r')\n\n@app.on_shutdown\ndef close_file(file_handle):\n    file_handle.close()  # Always close files\n</code></pre>"},{"location":"advanced/lifecycle/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>@app.on_startup\ndef database():\n    try:\n        return connect_to_database()\n    except ConnectionError as e:\n        print(f\"Failed to connect to database: {e}\")\n        return None  # Return None or a mock\n\n@app.get(\"/users\")\ndef get_users(database):\n    if database is None:\n        return {\"error\": \"Database unavailable\"}, 503\n    return database.query_users()\n</code></pre>"},{"location":"advanced/lifecycle/#4-use-async-for-io-operations","title":"4. Use Async for I/O Operations","text":"<pre><code>@app.on_startup\nasync def async_resources():\n    \"\"\"Use async for I/O-bound initialization.\"\"\"\n    async with aiohttp.ClientSession() as session:\n        config = await fetch_remote_config(session)\n    return config\n</code></pre>"},{"location":"advanced/lifecycle/#testing-with-lifecycle-handlers","title":"Testing with Lifecycle Handlers","text":"<p>When testing, startup and shutdown handlers are automatically invoked:</p> <pre><code>from restmachine import Request, HTTPMethod\n\ndef test_with_lifecycle():\n    app = RestApplication()\n\n    @app.on_startup\n    def test_db():\n        return {\"users\": []}\n\n    @app.get(\"/users\")\n    def get_users(test_db):\n        return test_db[\"users\"]\n\n    # Startup handler runs automatically\n    request = Request(method=HTTPMethod.GET, path=\"/users\")\n    response = app.execute(request)\n    assert response.status_code == 200\n</code></pre>"},{"location":"advanced/lifecycle/#comparison-with-other-frameworks","title":"Comparison with Other Frameworks","text":"Feature RestMachine FastAPI Flask Startup handlers <code>@app.on_startup</code> <code>@app.on_event(\"startup\")</code> <code>@app.before_first_request</code> Shutdown handlers <code>@app.on_shutdown</code> <code>@app.on_event(\"shutdown\")</code> <code>@app.teardown_appcontext</code> Auto dependency injection \u2713 \u2717 \u2717 Async support \u2713 \u2713 Limited ASGI lifespan \u2713 \u2713 \u2717"},{"location":"advanced/lifecycle/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Performance Optimization with caching strategies</li> <li>Explore Lambda Extensions for AWS-specific lifecycle hooks</li> <li>Read about Dependency Injection for advanced patterns</li> </ul>"},{"location":"advanced/performance/","title":"Performance Optimization","text":"<p>RestMachine is designed for high performance with minimal overhead. This guide covers optimization techniques, caching strategies, and best practices for building fast APIs.</p>"},{"location":"advanced/performance/#dependency-caching","title":"Dependency Caching","text":""},{"location":"advanced/performance/#understanding-dependency-scope","title":"Understanding Dependency Scope","text":"<p>RestMachine caches dependencies per request by default:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.dependency()\ndef expensive_computation():\n    \"\"\"Cached per request.\"\"\"\n    import time\n    print(\"Computing...\")\n    time.sleep(0.1)  # Simulate expensive operation\n    return {\"result\": \"value\"}\n\n@app.dependency()\ndef uses_computation(expensive_computation):\n    \"\"\"Reuses cached computation.\"\"\"\n    return {\"data\": expensive_computation[\"result\"]}\n\n@app.get('/api/data')\ndef get_data(expensive_computation, uses_computation):\n    \"\"\"Both dependencies use same cached computation.\"\"\"\n    # expensive_computation only runs once per request\n    return {\n        \"direct\": expensive_computation,\n        \"indirect\": uses_computation\n    }\n</code></pre>"},{"location":"advanced/performance/#session-scoped-dependencies","title":"Session-Scoped Dependencies","text":"<p>Use session scope for expensive resources:</p> <pre><code>@app.on_startup\ndef database_pool():\n    \"\"\"Created once at startup, reused across all requests.\"\"\"\n    import psycopg2.pool\n    return psycopg2.pool.SimpleConnectionPool(\n        minconn=1,\n        maxconn=20,\n        host='localhost',\n        database='mydb'\n    )\n\n@app.on_shutdown\ndef close_pool(database_pool):\n    \"\"\"Clean up on shutdown.\"\"\"\n    database_pool.closeall()\n\n@app.dependency()\ndef database_connection(database_pool):\n    \"\"\"Get connection from pool (per request).\"\"\"\n    conn = database_pool.getconn()\n    try:\n        yield conn\n    finally:\n        database_pool.putconn(conn)\n\n@app.get('/users')\ndef list_users(database_connection):\n    \"\"\"Use pooled connection.\"\"\"\n    with database_connection.cursor() as cur:\n        cur.execute(\"SELECT * FROM users\")\n        return {\"users\": cur.fetchall()}\n</code></pre>"},{"location":"advanced/performance/#state-machine-optimization","title":"State Machine Optimization","text":""},{"location":"advanced/performance/#bypass-state-machine-for-simple-routes","title":"Bypass State Machine for Simple Routes","text":"<p>For high-performance endpoints, consider bypassing the state machine:</p> <pre><code># Standard route (with state machine)\n@app.get('/api/data')\ndef get_data():\n    return {\"message\": \"Hello\"}\n\n# Direct route (bypass state machine for maximum performance)\n@app.get('/api/fast', bypass_state_machine=True)\ndef fast_endpoint():\n    \"\"\"Ultra-fast endpoint without state machine overhead.\"\"\"\n    return {\"message\": \"Fast!\"}, 200, {'Content-Type': 'application/json'}\n</code></pre>"},{"location":"advanced/performance/#optimize-state-machine-decorators","title":"Optimize State Machine Decorators","text":"<p>Minimize state machine processing by using specific decorators:</p> <pre><code>from restmachine.decorators import (\n    skip_content_negotiation,\n    skip_auth_check,\n    cache_response\n)\n\n@app.get('/api/public-data')\n@skip_content_negotiation  # Only return JSON\n@skip_auth_check  # No authentication needed\n@cache_response(max_age=3600)  # Cache for 1 hour\ndef public_data():\n    \"\"\"Optimized public endpoint.\"\"\"\n    return {\"data\": [...]}\n</code></pre>"},{"location":"advanced/performance/#asgi-server-tuning","title":"ASGI Server Tuning","text":""},{"location":"advanced/performance/#uvicorn-configuration","title":"Uvicorn Configuration","text":"<p>Optimize Uvicorn for production:</p> <pre><code># Production configuration\nuvicorn app:asgi_app \\\n  --host 0.0.0.0 \\\n  --port 8000 \\\n  --workers 4 \\\n  --loop uvloop \\\n  --http httptools \\\n  --log-level warning \\\n  --no-access-log \\\n  --limit-concurrency 1000 \\\n  --backlog 2048\n</code></pre> <p>Python configuration:</p> <pre><code># uvicorn_config.py\nimport multiprocessing\n\nbind = \"0.0.0.0:8000\"\nworkers = multiprocessing.cpu_count() * 2 + 1\nworker_class = \"uvicorn.workers.UvicornWorker\"\nloop = \"uvloop\"\nhttp = \"httptools\"\nlog_level = \"warning\"\naccess_log = False\nlimit_concurrency = 1000\nbacklog = 2048\n</code></pre> <p>Run with config:</p> <pre><code>uvicorn app:asgi_app --config uvicorn_config.py\n</code></pre>"},{"location":"advanced/performance/#hypercorn-configuration","title":"Hypercorn Configuration","text":"<p>Optimize Hypercorn for high performance:</p> <pre><code># hypercorn_config.toml\nbind = [\"0.0.0.0:8000\"]\nworkers = 4\nworker_class = \"uvloop\"\nkeep_alive = 5\ngraceful_timeout = 10\n\n# Performance tuning\nbacklog = 2048\nh11_max_incomplete_size = 16384\n\n# Logging\naccesslog = \"-\"\nerrorlog = \"-\"\nloglevel = \"warning\"\n</code></pre>"},{"location":"advanced/performance/#connection-pooling","title":"Connection Pooling","text":""},{"location":"advanced/performance/#database-connection-pool","title":"Database Connection Pool","text":"<p>Use connection pooling for databases:</p> <pre><code>from contextlib import contextmanager\nimport psycopg2.pool\n\n@app.on_startup\ndef db_pool():\n    \"\"\"Create connection pool.\"\"\"\n    return psycopg2.pool.ThreadedConnectionPool(\n        minconn=5,\n        maxconn=20,\n        host='localhost',\n        database='mydb',\n        user='user',\n        password='password',\n        connect_timeout=3\n    )\n\n@contextmanager\ndef get_db_connection(db_pool):\n    \"\"\"Get connection from pool with context manager.\"\"\"\n    conn = db_pool.getconn()\n    try:\n        yield conn\n        conn.commit()\n    except Exception:\n        conn.rollback()\n        raise\n    finally:\n        db_pool.putconn(conn)\n\n@app.get('/users')\ndef list_users(db_pool):\n    \"\"\"Use pooled connection efficiently.\"\"\"\n    with get_db_connection(db_pool) as conn:\n        with conn.cursor() as cur:\n            cur.execute(\"SELECT * FROM users LIMIT 100\")\n            return {\"users\": cur.fetchall()}\n</code></pre>"},{"location":"advanced/performance/#http-client-pooling","title":"HTTP Client Pooling","text":"<p>Reuse HTTP connections:</p> <pre><code>import httpx\n\n@app.on_startup\ndef http_client():\n    \"\"\"Create persistent HTTP client.\"\"\"\n    return httpx.AsyncClient(\n        timeout=10.0,\n        limits=httpx.Limits(\n            max_keepalive_connections=20,\n            max_connections=100\n        )\n    )\n\n@app.on_shutdown\nasync def close_http_client(http_client):\n    \"\"\"Close HTTP client.\"\"\"\n    await http_client.aclose()\n\n@app.get('/api/external')\nasync def call_external_api(http_client):\n    \"\"\"Use pooled HTTP client.\"\"\"\n    response = await http_client.get('https://api.example.com/data')\n    return response.json()\n</code></pre>"},{"location":"advanced/performance/#caching-strategies","title":"Caching Strategies","text":""},{"location":"advanced/performance/#in-memory-caching","title":"In-Memory Caching","text":"<p>Implement simple in-memory cache:</p> <pre><code>from functools import lru_cache\nfrom datetime import datetime, timedelta\n\n# LRU cache for expensive computations\n@lru_cache(maxsize=1000)\ndef expensive_function(param: str):\n    \"\"\"Cached with LRU eviction.\"\"\"\n    # Expensive computation\n    return {\"result\": param.upper()}\n\n# Time-based cache\nCACHE = {}\nCACHE_TTL = timedelta(minutes=5)\n\n@app.dependency()\ndef get_cached_data():\n    \"\"\"Data cached with TTL.\"\"\"\n    now = datetime.now()\n\n    # Check cache\n    if 'data' in CACHE:\n        cached_at, value = CACHE['data']\n        if now - cached_at &lt; CACHE_TTL:\n            return value\n\n    # Fetch fresh data\n    data = fetch_expensive_data()\n    CACHE['data'] = (now, data)\n\n    return data\n\n@app.get('/api/cached')\ndef cached_endpoint(get_cached_data):\n    return get_cached_data\n</code></pre>"},{"location":"advanced/performance/#redis-caching","title":"Redis Caching","text":"<p>Use Redis for distributed caching:</p> <pre><code>import redis\nimport json\nfrom datetime import timedelta\n\n@app.on_startup\ndef redis_client():\n    \"\"\"Create Redis connection pool.\"\"\"\n    return redis.Redis(\n        host='localhost',\n        port=6379,\n        db=0,\n        decode_responses=True,\n        max_connections=20\n    )\n\n@app.dependency()\ndef cache(redis_client):\n    \"\"\"Cache operations.\"\"\"\n    class Cache:\n        def __init__(self, client):\n            self.client = client\n\n        def get(self, key: str):\n            value = self.client.get(key)\n            return json.loads(value) if value else None\n\n        def set(self, key: str, value, ttl: int = 300):\n            self.client.setex(\n                key,\n                ttl,\n                json.dumps(value)\n            )\n\n        def delete(self, key: str):\n            self.client.delete(key)\n\n    return Cache(redis_client)\n\n@app.get('/users/{user_id}')\ndef get_user(request, cache, database):\n    \"\"\"Get user with caching.\"\"\"\n    user_id = request.path_params['user_id']\n    cache_key = f\"user:{user_id}\"\n\n    # Try cache first\n    cached = cache.get(cache_key)\n    if cached:\n        return cached\n\n    # Fetch from database\n    user = database.get_user(user_id)\n\n    # Cache for 5 minutes\n    cache.set(cache_key, user, ttl=300)\n\n    return user\n</code></pre>"},{"location":"advanced/performance/#response-compression","title":"Response Compression","text":""},{"location":"advanced/performance/#enable-compression-in-asgi-server","title":"Enable Compression in ASGI Server","text":"<p>Configure compression in Uvicorn/Hypercorn:</p> <pre><code># With middleware\nfrom starlette.middleware.gzip import GZipMiddleware\n\napp = RestApplication()\n\n# Add compression middleware to ASGI app\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\nasgi_app = GZipMiddleware(asgi_app, minimum_size=1000)\n</code></pre> <p>Or configure in reverse proxy (Nginx):</p> <pre><code># nginx.conf\nhttp {\n    gzip on;\n    gzip_vary on;\n    gzip_min_length 1000;\n    gzip_types\n        text/plain\n        text/css\n        text/javascript\n        application/json\n        application/javascript\n        application/xml+rss;\n}\n</code></pre>"},{"location":"advanced/performance/#async-operations","title":"Async Operations","text":""},{"location":"advanced/performance/#async-dependencies","title":"Async Dependencies","text":"<p>Use async for I/O-bound operations:</p> <pre><code>import asyncio\nimport httpx\n\n@app.on_startup\nasync def async_http_client():\n    \"\"\"Async HTTP client.\"\"\"\n    return httpx.AsyncClient(timeout=10.0)\n\n@app.dependency()\nasync def fetch_user_data(async_http_client, request):\n    \"\"\"Async dependency.\"\"\"\n    user_id = request.path_params['user_id']\n\n    # Parallel requests\n    user_response, posts_response = await asyncio.gather(\n        async_http_client.get(f'https://api.example.com/users/{user_id}'),\n        async_http_client.get(f'https://api.example.com/users/{user_id}/posts')\n    )\n\n    return {\n        \"user\": user_response.json(),\n        \"posts\": posts_response.json()\n    }\n\n@app.get('/users/{user_id}/profile')\nasync def user_profile(fetch_user_data):\n    \"\"\"Async endpoint.\"\"\"\n    return fetch_user_data\n</code></pre>"},{"location":"advanced/performance/#background-tasks","title":"Background Tasks","text":"<p>Offload work to background:</p> <pre><code>from concurrent.futures import ThreadPoolExecutor\nimport threading\n\n@app.on_startup\ndef executor():\n    \"\"\"Thread pool for background tasks.\"\"\"\n    return ThreadPoolExecutor(max_workers=10)\n\n@app.dependency()\ndef background_tasks(executor):\n    \"\"\"Background task runner.\"\"\"\n    tasks = []\n\n    def add_task(func, *args, **kwargs):\n        future = executor.submit(func, *args, **kwargs)\n        tasks.append(future)\n\n    def wait_all():\n        for future in tasks:\n            future.result()\n\n    return add_task, wait_all\n\n@app.post('/users')\ndef create_user(validate_user, database, background_tasks):\n    \"\"\"Create user with background email.\"\"\"\n    add_task, wait_all = background_tasks\n\n    # Create user\n    user = database.create_user(validate_user.model_dump())\n\n    # Send email in background\n    add_task(send_welcome_email, user['email'])\n\n    # Don't wait for background tasks\n    return user, 201\n</code></pre>"},{"location":"advanced/performance/#query-optimization","title":"Query Optimization","text":""},{"location":"advanced/performance/#efficient-database-queries","title":"Efficient Database Queries","text":"<p>Optimize database access:</p> <pre><code>@app.get('/users')\ndef list_users(request, database):\n    \"\"\"Optimized user listing.\"\"\"\n    # Use query parameters for filtering\n    limit = min(int(request.query_params.get('limit', '20')), 100)\n    offset = int(request.query_params.get('offset', '0'))\n\n    # Efficient query with LIMIT/OFFSET\n    with database.cursor() as cur:\n        cur.execute(\n            \"\"\"\n            SELECT id, name, email, created_at\n            FROM users\n            ORDER BY created_at DESC\n            LIMIT %s OFFSET %s\n            \"\"\",\n            (limit, offset)\n        )\n\n        users = cur.fetchall()\n\n    return {\n        \"users\": users,\n        \"limit\": limit,\n        \"offset\": offset\n    }\n</code></pre>"},{"location":"advanced/performance/#n1-query-prevention","title":"N+1 Query Prevention","text":"<p>Avoid N+1 queries with eager loading:</p> <pre><code>@app.get('/posts')\ndef list_posts(database):\n    \"\"\"List posts with authors (avoid N+1).\"\"\"\n    with database.cursor() as cur:\n        # Single query with JOIN\n        cur.execute(\n            \"\"\"\n            SELECT\n                p.id, p.title, p.content,\n                u.id as author_id, u.name as author_name\n            FROM posts p\n            JOIN users u ON p.author_id = u.id\n            ORDER BY p.created_at DESC\n            LIMIT 20\n            \"\"\"\n        )\n\n        rows = cur.fetchall()\n\n        posts = [\n            {\n                \"id\": row[0],\n                \"title\": row[1],\n                \"content\": row[2],\n                \"author\": {\n                    \"id\": row[3],\n                    \"name\": row[4]\n                }\n            }\n            for row in rows\n        ]\n\n    return {\"posts\": posts}\n</code></pre>"},{"location":"advanced/performance/#response-optimization","title":"Response Optimization","text":""},{"location":"advanced/performance/#pagination","title":"Pagination","text":"<p>Implement efficient pagination:</p> <pre><code>from typing import Optional\n\nclass PaginationParams:\n    def __init__(self, page: int = 1, per_page: int = 20):\n        self.page = max(1, page)\n        self.per_page = min(per_page, 100)  # Max 100 items\n        self.offset = (self.page - 1) * self.per_page\n\n@app.dependency()\ndef pagination(request) -&gt; PaginationParams:\n    \"\"\"Parse pagination parameters.\"\"\"\n    page = int(request.query_params.get('page', '1'))\n    per_page = int(request.query_params.get('per_page', '20'))\n    return PaginationParams(page, per_page)\n\n@app.get('/users')\ndef list_users(pagination: PaginationParams, database):\n    \"\"\"Paginated user list.\"\"\"\n    with database.cursor() as cur:\n        # Get total count\n        cur.execute(\"SELECT COUNT(*) FROM users\")\n        total = cur.fetchone()[0]\n\n        # Get page of results\n        cur.execute(\n            \"SELECT * FROM users LIMIT %s OFFSET %s\",\n            (pagination.per_page, pagination.offset)\n        )\n        users = cur.fetchall()\n\n    return {\n        \"users\": users,\n        \"pagination\": {\n            \"page\": pagination.page,\n            \"per_page\": pagination.per_page,\n            \"total\": total,\n            \"pages\": (total + pagination.per_page - 1) // pagination.per_page\n        }\n    }\n</code></pre>"},{"location":"advanced/performance/#field-selection","title":"Field Selection","text":"<p>Allow clients to select fields:</p> <pre><code>@app.get('/users/{user_id}')\ndef get_user(request, database):\n    \"\"\"Get user with field selection.\"\"\"\n    user_id = request.path_params['user_id']\n\n    # Parse fields parameter\n    fields_param = request.query_params.get('fields', '')\n    allowed_fields = {'id', 'name', 'email', 'created_at', 'bio'}\n\n    if fields_param:\n        selected_fields = set(fields_param.split(',')) &amp; allowed_fields\n    else:\n        selected_fields = allowed_fields\n\n    # Build query\n    field_list = ', '.join(selected_fields)\n\n    with database.cursor() as cur:\n        cur.execute(\n            f\"SELECT {field_list} FROM users WHERE id = %s\",\n            (user_id,)\n        )\n        row = cur.fetchone()\n\n    if not row:\n        from restmachine import Response\n        return Response(404, '{\"error\": \"Not found\"}')\n\n    # Build response with selected fields\n    user = dict(zip(selected_fields, row))\n\n    return user\n</code></pre>"},{"location":"advanced/performance/#monitoring-and-profiling","title":"Monitoring and Profiling","text":""},{"location":"advanced/performance/#request-timing","title":"Request Timing","text":"<p>Track request performance:</p> <pre><code>import time\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.dependency()\ndef request_timer(request):\n    \"\"\"Track request timing.\"\"\"\n    start_time = time.time()\n\n    yield\n\n    duration = time.time() - start_time\n\n    # Log slow requests\n    if duration &gt; 1.0:\n        logger.warning(\n            f\"Slow request: {request.method} {request.path} took {duration:.2f}s\"\n        )\n\n    # Add timing header\n    return {'X-Response-Time': f\"{duration:.3f}\"}\n\n@app.get('/api/data')\ndef get_data(request_timer):\n    \"\"\"Endpoint with timing.\"\"\"\n    # Simulate work\n    time.sleep(0.1)\n\n    return {\"message\": \"Hello\"}, 200, request_timer\n</code></pre>"},{"location":"advanced/performance/#memory-profiling","title":"Memory Profiling","text":"<p>Monitor memory usage:</p> <pre><code>import tracemalloc\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.on_startup\ndef start_memory_profiling():\n    \"\"\"Start memory profiling.\"\"\"\n    tracemalloc.start()\n\n@app.dependency()\ndef memory_monitor():\n    \"\"\"Monitor memory for request.\"\"\"\n    snapshot1 = tracemalloc.take_snapshot()\n\n    yield\n\n    snapshot2 = tracemalloc.take_snapshot()\n    top_stats = snapshot2.compare_to(snapshot1, 'lineno')\n\n    # Log top memory allocations\n    for stat in top_stats[:3]:\n        logger.debug(f\"Memory: {stat}\")\n\n@app.get('/api/data')\ndef get_data(memory_monitor):\n    \"\"\"Endpoint with memory monitoring.\"\"\"\n    data = fetch_large_dataset()\n    return data\n</code></pre>"},{"location":"advanced/performance/#complete-example","title":"Complete Example","text":"<p>Here's a complete high-performance application:</p> <pre><code>from restmachine import RestApplication, Request\nfrom functools import lru_cache\nimport psycopg2.pool\nimport redis\nimport json\nfrom datetime import datetime\n\napp = RestApplication()\n\n# Connection pools\n@app.on_startup\ndef db_pool():\n    return psycopg2.pool.ThreadedConnectionPool(\n        minconn=5, maxconn=20,\n        host='localhost', database='mydb'\n    )\n\n@app.on_startup\ndef redis_client():\n    return redis.Redis(\n        host='localhost', decode_responses=True,\n        max_connections=20\n    )\n\n# Caching dependency\n@app.dependency()\ndef cache(redis_client):\n    class Cache:\n        def get(self, key):\n            val = redis_client.get(key)\n            return json.loads(val) if val else None\n\n        def set(self, key, value, ttl=300):\n            redis_client.setex(key, ttl, json.dumps(value))\n\n    return Cache()\n\n# Optimized user endpoint\n@app.get('/users/{user_id}')\ndef get_user(request, db_pool, cache):\n    \"\"\"High-performance user endpoint.\"\"\"\n    user_id = request.path_params['user_id']\n    cache_key = f\"user:{user_id}\"\n\n    # Try cache\n    user = cache.get(cache_key)\n    if user:\n        return user, 200, {'X-Cache': 'HIT'}\n\n    # Database query\n    conn = db_pool.getconn()\n    try:\n        with conn.cursor() as cur:\n            cur.execute(\n                \"SELECT id, name, email FROM users WHERE id = %s\",\n                (user_id,)\n            )\n            row = cur.fetchone()\n\n            if not row:\n                from restmachine import Response\n                return Response(404, '{\"error\": \"Not found\"}')\n\n            user = {\"id\": row[0], \"name\": row[1], \"email\": row[2]}\n\n            # Cache result\n            cache.set(cache_key, user, ttl=300)\n\n            return user, 200, {'X-Cache': 'MISS'}\n    finally:\n        db_pool.putconn(conn)\n\n# ASGI with optimizations\nfrom restmachine import ASGIAdapter\nfrom starlette.middleware.gzip import GZipMiddleware\n\nasgi_app = ASGIAdapter(app)\nasgi_app = GZipMiddleware(asgi_app, minimum_size=1000)\n</code></pre>"},{"location":"advanced/performance/#best-practices","title":"Best Practices","text":""},{"location":"advanced/performance/#1-use-connection-pooling","title":"1. Use Connection Pooling","text":"<p>Always pool database and HTTP connections:</p> <pre><code># Good: Connection pool\n@app.on_startup\ndef db_pool():\n    return create_pool(min=5, max=20)\n\n# Bad: New connection per request\n@app.dependency()\ndef database():\n    return create_connection()  # Don't do this!\n</code></pre>"},{"location":"advanced/performance/#2-cache-expensive-operations","title":"2. Cache Expensive Operations","text":"<p>Cache computations and queries:</p> <pre><code># Good: Cached\n@lru_cache(maxsize=1000)\ndef expensive_computation(param):\n    return result\n\n# Bad: Recompute every time\ndef expensive_computation(param):\n    return result  # No caching\n</code></pre>"},{"location":"advanced/performance/#3-use-async-for-io","title":"3. Use Async for I/O","text":"<p>Use async for I/O-bound operations:</p> <pre><code># Good: Async I/O\n@app.get('/data')\nasync def get_data(http_client):\n    return await http_client.get('https://api.example.com')\n\n# Less optimal: Sync I/O (blocks worker)\n@app.get('/data')\ndef get_data():\n    return requests.get('https://api.example.com')\n</code></pre>"},{"location":"advanced/performance/#4-implement-pagination","title":"4. Implement Pagination","text":"<p>Always paginate large result sets:</p> <pre><code># Good: Paginated\n@app.get('/users')\ndef list_users(pagination):\n    return db.query().limit(pagination.per_page).offset(pagination.offset)\n\n# Bad: Return all results\n@app.get('/users')\ndef list_users():\n    return db.query().all()  # Could be millions!\n</code></pre>"},{"location":"advanced/performance/#5-monitor-performance","title":"5. Monitor Performance","text":"<p>Track and log performance metrics:</p> <pre><code>import time\n\n@app.dependency()\ndef perf_monitor(request):\n    start = time.time()\n    yield\n    duration = time.time() - start\n    if duration &gt; 1.0:\n        logger.warning(f\"Slow: {request.path} {duration:.2f}s\")\n</code></pre>"},{"location":"advanced/performance/#next-steps","title":"Next Steps","text":"<ul> <li>Lifecycle \u2192 - Manage application lifecycle</li> <li>State Machine \u2192 - Understand request flow</li> <li>Testing \u2192 - Performance testing</li> <li>Deployment \u2192 - Production deployment</li> </ul>"},{"location":"advanced/state-machine/","title":"State Machine","text":"<p>RestMachine uses a webmachine-inspired state machine to process HTTP requests. This provides robust, standards-compliant HTTP handling with proper status codes and conditional request support.</p>"},{"location":"advanced/state-machine/#overview","title":"Overview","text":"<p>The state machine processes every request through a series of decision points, each checking a specific aspect of the HTTP protocol. Based on the results, it either continues to the next state or returns an appropriate HTTP response.</p>"},{"location":"advanced/state-machine/#key-features","title":"Key Features","text":"<ul> <li>Standards Compliant: Follows HTTP/1.1 specification (RFC 7231-7235)</li> <li>Conditional Requests: Full support for ETags and Last-Modified</li> <li>Content Negotiation: Automatic Accept header processing</li> <li>Customizable: Override any decision point with decorators</li> <li>Efficient: Optimized for minimal overhead</li> </ul>"},{"location":"advanced/state-machine/#state-machine-flow","title":"State Machine Flow","text":"<p>The diagram below shows the complete request processing flow.</p> <p>Viewing the Diagram</p> <ul> <li>Click the Expand Diagram button below for fullscreen view with zoom controls</li> <li>In fullscreen: Use \u00b1 buttons or Ctrl/Cmd + scroll to zoom</li> <li>Horizontal scroll to navigate the full flow</li> <li>Copy the diagram code to Mermaid Live Editor for interactive editing</li> </ul> \u26f6 Expand Diagram %%{init: {'theme':'base', 'themeVariables': {'edgeLabelBackground':'transparent', 'primaryTextColor':'#ccc', 'lineColor':'#ccc'}}}%% flowchart LR     START(( )) --&gt; B13      %% Route and Service Checks     B13{B13: Route&lt;br/&gt;Exists?}     B13 --&gt;|No| PATH_CHECK{Path has&lt;br/&gt;other routes?}     PATH_CHECK --&gt;|Yes| R405[[405 Method&lt;br/&gt;Not Allowed]]     PATH_CHECK --&gt;|No| R404[[404 Not Found]]     B13 --&gt;|Yes| B12      B12{B12: Service&lt;br/&gt;Available?}     B12 --&gt;|No| R503[[503 Service&lt;br/&gt;Unavailable]]     B12 --&gt;|Yes| B11      B11{B11: Known&lt;br/&gt;Method?}     B11 --&gt;|No| R501[[501 Not&lt;br/&gt;Implemented]]     B11 --&gt;|Yes| B10      B10{B10: URI&lt;br/&gt;Too Long?}     B10 --&gt;|Yes| R414[[414 URI&lt;br/&gt;Too Long]]     B10 --&gt;|No| B9      B9{B9: Method&lt;br/&gt;Allowed?}     B9 --&gt;|No| R405_2[[405 Method&lt;br/&gt;Not Allowed]]     B9 --&gt;|Yes| B8      %% Request Validation     B8{B8: Malformed&lt;br/&gt;Request?}     B8 --&gt;|Yes| R400[[400 Bad&lt;br/&gt;Request]]     B8 --&gt;|No| B7      B7{B7: Authorized?}     B7 --&gt;|No| R401[[401&lt;br/&gt;Unauthorized]]     B7 --&gt;|Yes| B6      B6{B6: Forbidden?}     B6 --&gt;|Yes| R403[[403&lt;br/&gt;Forbidden]]     B6 --&gt;|No| B5      B5{B5: Valid Content&lt;br/&gt;Headers?}     B5 --&gt;|No| R400_2[[400 Bad&lt;br/&gt;Request]]     B5 --&gt;|Yes| G7      %% Resource Existence     G7{G7: Resource&lt;br/&gt;Exists?}     G7 --&gt;|No &amp; POST| C3     G7 --&gt;|No &amp; Other| R404_2[[404 Not&lt;br/&gt;Found]]     G7 --&gt;|Yes| COND_CHECK{Conditional&lt;br/&gt;Headers?}      COND_CHECK --&gt;|No| C3     COND_CHECK --&gt;|Yes| G3      %% Conditional Request Processing     G3{G3: If-Match&lt;br/&gt;Header?}     G3 --&gt;|No| G4     G3 --&gt;|* or Match| G4     G3 --&gt;|No Match| R412[[412 Precondition&lt;br/&gt;Failed]]      G4{G4: If-Unmodified-&lt;br/&gt;Since?}     G4 --&gt;|No| G5     G4 --&gt;|Not Modified| G5     G4 --&gt;|Modified| R412_2[[412 Precondition&lt;br/&gt;Failed]]      G5{G5: If-None-Match&lt;br/&gt;Header?}     G5 --&gt;|No| G6     G5 --&gt;|Match &amp; GET| R304[[304 Not&lt;br/&gt;Modified]]     G5 --&gt;|Match &amp; Other| R412_3[[412 Precondition&lt;br/&gt;Failed]]     G5 --&gt;|No Match| G6      G6{G6: If-Modified-&lt;br/&gt;Since?}     G6 --&gt;|No or GET| C3     G6 --&gt;|Not Modified| R304_2[[304 Not&lt;br/&gt;Modified]]     G6 --&gt;|Modified| C3      %% Content Negotiation     C3{C3: Content Types&lt;br/&gt;Available?}     C3 --&gt;|No| R500[[500 Internal&lt;br/&gt;Server Error]]     C3 --&gt;|Yes| C4      C4{C4: Acceptable&lt;br/&gt;Content Type?}     C4 --&gt;|No| R406[[406 Not&lt;br/&gt;Acceptable]]     C4 --&gt;|Yes| EXEC[Execute Handler&lt;br/&gt;&amp; Render]      %% Terminal States     EXEC --&gt; SUCCESS{Response&lt;br/&gt;Type?}     SUCCESS --&gt;|None| R204[[204 No&lt;br/&gt;Content]]     SUCCESS --&gt;|Response Object| RETURN[Return Response]     SUCCESS --&gt;|Data| RENDER[Render with&lt;br/&gt;Content Type]     RENDER --&gt; R200[[200 OK]]      %% Link styles - Green for success/yes paths     linkStyle 0,4,6,8,10,12,14,16,18,20,23,25,26,27,29,30,32,35,36,38,40,42,43,45,46,47 stroke:#2d8659,stroke-width:2px      %% Link styles - Red for error/no paths     linkStyle 1,2,3,5,7,9,11,13,15,17,19,22,28,31,34,39,41 stroke:#d84848,stroke-width:2px      %% Link styles - Special success paths (304, 204)     linkStyle 33,37,44 stroke:#2d8659,stroke-width:2px      %% Class definitions     classDef decisionNode fill:#1a1a1a,stroke:#ccc,stroke-width:2px,color:#eee     classDef errorState fill:#d84848,stroke:#333,stroke-width:2px,color:#fff     classDef successState fill:#2d8659,stroke:#333,stroke-width:2px,color:#fff     classDef executionNode fill:#4a4a8f,stroke:#333,stroke-width:2px,color:#fff      %% Apply classes to decision nodes     class B13,B12,B11,B10,B9,B8,B7,B6,B5 decisionNode     class G7,G6,G5,G4,G3 decisionNode     class C3,C4 decisionNode     class PATH_CHECK,COND_CHECK,SUCCESS decisionNode      %% Apply classes to error states (4xx/5xx)     class R404,R404_2,R405,R405_2,R400,R400_2,R401,R403 errorState     class R412,R412_2,R412_3,R406,R414,R500,R501,R503 errorState      %% Apply classes to success states (2xx/3xx)     class R200,R204,R304,R304_2,RETURN successState      %% Apply classes to execution nodes     class EXEC,RENDER executionNode"},{"location":"advanced/state-machine/#state-descriptions","title":"State Descriptions","text":""},{"location":"advanced/state-machine/#route-and-service-checks-b13-b9","title":"Route and Service Checks (B13-B9)","text":""},{"location":"advanced/state-machine/#b13-route-exists","title":"B13: Route Exists","text":"<p>Decision: Does a route exist for this method and path?</p> <ul> <li>No: Check if path has routes for other methods</li> <li>If yes \u2192 405 Method Not Allowed</li> <li>If no \u2192 404 Not Found</li> <li>Yes: Continue to service availability check</li> </ul>"},{"location":"advanced/state-machine/#b12-service-available","title":"B12: Service Available","text":"<p>Decision: Is the service available to handle requests?</p> <ul> <li>No: 503 Service Unavailable</li> <li>Yes: Continue to known method check</li> </ul> <p>Override with decorator: <pre><code>@app.service_available\ndef check_service(request):\n    # Check if service is in maintenance mode\n    if maintenance_mode:\n        return False\n    return True\n</code></pre></p>"},{"location":"advanced/state-machine/#b11-known-method","title":"B11: Known Method","text":"<p>Decision: Is the HTTP method known/supported?</p> <ul> <li>No: 501 Not Implemented</li> <li>Yes: Continue to URI check</li> </ul> <p>Default known methods: GET, POST, PUT, DELETE, PATCH</p> <p>Override: <pre><code>@app.known_method\ndef check_method(request):\n    allowed = {'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'}\n    return request.method.value in allowed\n</code></pre></p>"},{"location":"advanced/state-machine/#b10-uri-too-long","title":"B10: URI Too Long","text":"<p>Decision: Is the URI too long?</p> <ul> <li>Yes: 414 URI Too Long</li> <li>No: Continue to method allowed check</li> </ul> <p>Override: <pre><code>@app.uri_too_long\ndef check_uri_length(request):\n    return len(request.path) &gt; 2000\n</code></pre></p>"},{"location":"advanced/state-machine/#b9-method-allowed","title":"B9: Method Allowed","text":"<p>Decision: Is the method allowed for this resource?</p> <ul> <li>No: 405 Method Not Allowed</li> <li>Yes: Continue to malformed check</li> </ul>"},{"location":"advanced/state-machine/#request-validation-b8-b5","title":"Request Validation (B8-B5)","text":""},{"location":"advanced/state-machine/#b8-malformed-request","title":"B8: Malformed Request","text":"<p>Decision: Is the request malformed?</p> <ul> <li>Yes: 400 Bad Request</li> <li>No: Continue to authorization</li> </ul> <p>Override: <pre><code>@app.malformed_request\ndef check_request(request):\n    # Custom validation logic\n    if not request.headers.get('content-type'):\n        return True\n    return False\n</code></pre></p>"},{"location":"advanced/state-machine/#b7-authorized","title":"B7: Authorized","text":"<p>Decision: Is the request authorized?</p> <ul> <li>No: 401 Unauthorized</li> <li>Yes: Continue to forbidden check</li> </ul> <p>Override: <pre><code>@app.authorized\ndef check_auth(request):\n    token = request.headers.get('authorization')\n    if not token:\n        return False\n    return validate_token(token)\n</code></pre></p>"},{"location":"advanced/state-machine/#b6-forbidden","title":"B6: Forbidden","text":"<p>Decision: Is access forbidden for this user?</p> <ul> <li>Yes: 403 Forbidden</li> <li>No: Continue to content header validation</li> </ul> <p>Override: <pre><code>@app.forbidden\ndef check_forbidden(request, current_user):\n    # Check if user has permission\n    if current_user.role != 'admin':\n        return True\n    return False\n</code></pre></p>"},{"location":"advanced/state-machine/#b5-valid-content-headers","title":"B5: Valid Content Headers","text":"<p>Decision: Are the content headers valid?</p> <ul> <li>No: 400 Bad Request</li> <li>Yes: Continue to resource existence</li> </ul> <p>Override: <pre><code>@app.valid_content_headers\ndef check_headers(request):\n    content_type = request.headers.get('content-type')\n    if request.method in ['POST', 'PUT']:\n        return content_type is not None\n    return True\n</code></pre></p>"},{"location":"advanced/state-machine/#resource-existence-g7","title":"Resource Existence (G7)","text":""},{"location":"advanced/state-machine/#g7-resource-exists","title":"G7: Resource Exists","text":"<p>Decision: Does the resource exist?</p> <ul> <li>No &amp; POST: Continue to content negotiation (creating resource)</li> <li>No &amp; Other: 404 Not Found</li> <li>Yes: Check for conditional headers</li> </ul> <p>Override with dependency: <pre><code>@app.resource_exists\ndef get_user(request):\n    user_id = request.path_params['user_id']\n    user = database.get(user_id)\n    if not user:\n        return None  # Triggers 404\n    return user  # Cached for use in handler\n</code></pre></p>"},{"location":"advanced/state-machine/#conditional-request-processing-g3-g6","title":"Conditional Request Processing (G3-G6)","text":"<p>These states implement ETags and Last-Modified conditional requests:</p>"},{"location":"advanced/state-machine/#g3-if-match","title":"G3: If-Match","text":"<p>Decision: Does the If-Match header match?</p> <ul> <li>Header not present: Continue to G4</li> <li>Match or *: Continue to G4</li> <li>No match: 412 Precondition Failed</li> </ul> <p>Used for: Preventing mid-air collisions in updates</p> <pre><code>@app.etag\ndef get_etag(resource):\n    import hashlib\n    content = json.dumps(resource, sort_keys=True)\n    return f'\"{hashlib.md5(content.encode()).hexdigest()}\"'\n</code></pre>"},{"location":"advanced/state-machine/#g4-if-unmodified-since","title":"G4: If-Unmodified-Since","text":"<p>Decision: Has resource been modified since specified date?</p> <ul> <li>Header not present: Continue to G5</li> <li>Not modified: Continue to G5</li> <li>Modified: 412 Precondition Failed</li> </ul> <pre><code>@app.last_modified\ndef get_last_modified(resource):\n    from datetime import datetime\n    return datetime.fromisoformat(resource['updated_at'])\n</code></pre>"},{"location":"advanced/state-machine/#g5-if-none-match","title":"G5: If-None-Match","text":"<p>Decision: Does the If-None-Match header match?</p> <ul> <li>Header not present: Continue to G6</li> <li>Match &amp; GET: 304 Not Modified</li> <li>Match &amp; Other: 412 Precondition Failed</li> <li>No match: Continue to G6</li> </ul> <p>Used for: Efficient caching with ETags</p>"},{"location":"advanced/state-machine/#g6-if-modified-since","title":"G6: If-Modified-Since","text":"<p>Decision: Has resource been modified since specified date?</p> <ul> <li>Header not present or not GET: Continue to content negotiation</li> <li>Not modified: 304 Not Modified</li> <li>Modified: Continue to content negotiation</li> </ul> <p>Used for: Efficient caching with timestamps</p>"},{"location":"advanced/state-machine/#content-negotiation-c3-c4","title":"Content Negotiation (C3-C4)","text":""},{"location":"advanced/state-machine/#c3-content-types-provided","title":"C3: Content Types Provided","text":"<p>Decision: Are content types available?</p> <ul> <li>No: 500 Internal Server Error</li> <li>Yes: Continue to acceptance check</li> </ul>"},{"location":"advanced/state-machine/#c4-acceptable-content-type","title":"C4: Acceptable Content Type","text":"<p>Decision: Can we provide an acceptable content type?</p> <ul> <li>No: 406 Not Acceptable</li> <li>Yes: Execute handler and render</li> </ul> <p>Content negotiation: <pre><code>@app.content_renderer(\"application/json\")\ndef json_renderer(data):\n    return json.dumps(data)\n\n@app.content_renderer(\"application/xml\")\ndef xml_renderer(data):\n    return f\"&lt;data&gt;{data}&lt;/data&gt;\"\n</code></pre></p>"},{"location":"advanced/state-machine/#handler-execution-terminal-state","title":"Handler Execution (Terminal State)","text":"<p>Execute Handler &amp; Render: The final state that:</p> <ol> <li>Processes header dependencies</li> <li>Executes the route handler</li> <li>Validates Pydantic return types (if used)</li> <li>Renders response with chosen content type</li> <li>Returns appropriate status code:</li> <li>None \u2192 204 No Content</li> <li>Response object \u2192 Use response as-is</li> <li>Data \u2192 Render with content type \u2192 200 OK</li> </ol>"},{"location":"advanced/state-machine/#decorator-reference","title":"Decorator Reference","text":""},{"location":"advanced/state-machine/#state-override-decorators","title":"State Override Decorators","text":"<p>Override decision points for specific routes:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n# Service availability\n@app.service_available\ndef check_service(request):\n    return not maintenance_mode\n\n# Method checking\n@app.known_method\ndef check_method(request):\n    return request.method.value in ALLOWED_METHODS\n\n# Authorization\n@app.authorized\ndef check_auth(request):\n    return validate_token(request.headers.get('authorization'))\n\n# Access control\n@app.forbidden\ndef check_permission(request, current_user):\n    return current_user.role not in ['admin', 'moderator']\n\n# Resource existence (with caching)\n@app.resource_exists\ndef get_resource(request):\n    resource_id = request.path_params['id']\n    return database.get(resource_id)  # None = 404\n\n# ETag for conditional requests\n@app.etag\ndef calculate_etag(resource):\n    import hashlib\n    return f'\"{hashlib.md5(str(resource).encode()).hexdigest()}\"'\n\n# Last-Modified for conditional requests\n@app.last_modified\ndef get_last_modified(resource):\n    return resource['updated_at']\n</code></pre>"},{"location":"advanced/state-machine/#route-specific-overrides","title":"Route-Specific Overrides","text":"<p>Apply decorators to specific routes:</p> <pre><code>@app.get('/admin/users')\n@app.authorized\ndef check_admin_auth(request):\n    token = request.headers.get('authorization')\n    if not token:\n        return False\n    user = validate_token(token)\n    return user and user.role == 'admin'\n\ndef list_users():\n    return {\"users\": [...]}\n</code></pre>"},{"location":"advanced/state-machine/#http-status-code-reference","title":"HTTP Status Code Reference","text":""},{"location":"advanced/state-machine/#client-errors-4xx","title":"Client Errors (4xx)","text":"Code State Meaning 400 B8, B5 Bad Request - Malformed request or invalid headers 401 B7 Unauthorized - Authentication required 403 B6 Forbidden - Authenticated but not authorized 404 B13, G7 Not Found - Resource doesn't exist 405 B13, B9 Method Not Allowed - Method not allowed for this resource 406 C4 Not Acceptable - Cannot provide acceptable content type 412 G3, G4, G5 Precondition Failed - Conditional request failed 414 B10 URI Too Long - URI exceeds length limit"},{"location":"advanced/state-machine/#server-errors-5xx","title":"Server Errors (5xx)","text":"Code State Meaning 500 C3 Internal Server Error - No content renderers available 501 B11 Not Implemented - HTTP method not supported 503 B12 Service Unavailable - Service temporarily unavailable"},{"location":"advanced/state-machine/#success-codes-2xx3xx","title":"Success Codes (2xx/3xx)","text":"Code State Meaning 200 Exec OK - Successful request with body 204 Exec No Content - Successful request, no body 304 G5, G6 Not Modified - Resource not modified (conditional)"},{"location":"advanced/state-machine/#examples","title":"Examples","text":""},{"location":"advanced/state-machine/#basic-resource-with-conditional-requests","title":"Basic Resource with Conditional Requests","text":"<pre><code>from restmachine import RestApplication\nfrom datetime import datetime\nimport hashlib\nimport json\n\napp = RestApplication()\n\n@app.on_startup\ndef database():\n    return {\n        \"users\": {\n            \"1\": {\n                \"id\": \"1\",\n                \"name\": \"Alice\",\n                \"email\": \"alice@example.com\",\n                \"updated_at\": \"2024-01-15T10:00:00Z\"\n            }\n        }\n    }\n\n# Resource existence check (G7)\n@app.resource_exists\ndef get_user(request, database):\n    user_id = request.path_params.get('user_id')\n    user = database[\"users\"].get(user_id)\n    if not user:\n        return None  # Triggers 404\n    return user  # Cached for use in handler\n\n# ETag calculation (G3, G5)\n@app.etag\ndef user_etag(get_user):\n    if not get_user:\n        return None\n    user_json = json.dumps(get_user, sort_keys=True)\n    return f'\"{hashlib.md5(user_json.encode()).hexdigest()}\"'\n\n# Last-Modified (G4, G6)\n@app.last_modified\ndef user_last_modified(get_user):\n    if not get_user:\n        return None\n    return datetime.fromisoformat(get_user['updated_at'].replace('Z', '+00:00'))\n\n@app.get('/users/{user_id}')\ndef get_user_endpoint(get_user):\n    \"\"\"\n    State flow:\n    1. B13: Route exists \u2713\n    2. B12-B5: Checks pass \u2713\n    3. G7: Resource exists \u2713 (get_user dependency)\n    4. G3: If-Match checked\n    5. G4: If-Unmodified-Since checked\n    6. G5: If-None-Match checked (may return 304)\n    7. G6: If-Modified-Since checked (may return 304)\n    8. C3-C4: Content negotiation\n    9. Execute &amp; render \u2192 200 OK\n    \"\"\"\n    return get_user\n</code></pre>"},{"location":"advanced/state-machine/#protected-resource-with-authorization","title":"Protected Resource with Authorization","text":"<pre><code># Authorization check (B7)\n@app.authorized\ndef check_auth(request):\n    token = request.headers.get('authorization', '')\n    if not token.startswith('Bearer '):\n        return False\n    return validate_token(token[7:])\n\n# Permission check (B6)\n@app.forbidden\ndef check_admin(request):\n    token = request.headers.get('authorization', '')[7:]\n    user = get_user_from_token(token)\n    # Return True if forbidden\n    return user.role != 'admin'\n\n@app.delete('/users/{user_id}')\ndef delete_user(request, database):\n    \"\"\"\n    State flow:\n    1. B13-B11: Route and service checks \u2713\n    2. B10-B9: URI and method checks \u2713\n    3. B8: Not malformed \u2713\n    4. B7: Authorized? (checks token)\n    5. B6: Forbidden? (checks admin role)\n    6. G7-C4: Resource and content checks\n    7. Execute \u2192 204 No Content\n    \"\"\"\n    user_id = request.path_params['user_id']\n    del database[\"users\"][user_id]\n    return None  # 204 No Content\n</code></pre>"},{"location":"advanced/state-machine/#custom-service-availability","title":"Custom Service Availability","text":"<pre><code>import os\n\n# Service availability check (B12)\n@app.service_available\ndef check_maintenance(request):\n    # Allow health checks during maintenance\n    if request.path == '/health':\n        return True\n\n    # Check maintenance mode\n    return not os.environ.get('MAINTENANCE_MODE')\n\n@app.get('/health')\ndef health_check():\n    return {\"status\": \"ok\"}\n\n@app.get('/api/data')\ndef get_data():\n    \"\"\"\n    State flow in maintenance mode:\n    1. B13: Route exists \u2713\n    2. B12: Service available? (returns 503)\n\n    Normal flow:\n    1. B13: Route exists \u2713\n    2. B12: Service available \u2713\n    3. ... continues to execution\n    \"\"\"\n    return {\"data\": [...]}\n</code></pre>"},{"location":"advanced/state-machine/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/state-machine/#state-machine-overhead","title":"State Machine Overhead","text":"<p>The state machine adds minimal overhead:</p> <ul> <li>Without decorators: ~5-10 states per request</li> <li>With decorators: Additional states as needed</li> <li>Conditional requests: +4 states (G3-G6) only when headers present</li> <li>Max states: 50 (safety limit)</li> </ul>"},{"location":"advanced/state-machine/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Skip unnecessary checks: Don't use decorators unless needed</li> <li>Cache dependencies: Resource checks are cached automatically</li> <li>Conditional headers: Only processed when headers present</li> <li>Content negotiation: Cached per request</li> </ol>"},{"location":"advanced/state-machine/#bypass-state-machine","title":"Bypass State Machine","text":"<p>For maximum performance on simple endpoints:</p> <pre><code>@app.get('/ping', bypass_state_machine=True)\ndef ping():\n    \"\"\"Ultra-fast endpoint, skips all state machine processing.\"\"\"\n    return {\"pong\": True}, 200, {'Content-Type': 'application/json'}\n</code></pre>"},{"location":"advanced/state-machine/#comparison-with-other-frameworks","title":"Comparison with Other Frameworks","text":""},{"location":"advanced/state-machine/#vs-flaskfastapi","title":"vs Flask/FastAPI","text":"<p>Traditional frameworks use middleware:</p> <pre><code># Flask/FastAPI style\n@app.middleware\ndef check_auth(request, call_next):\n    if not is_authenticated(request):\n        return Response(401)\n    return call_next(request)\n</code></pre> <p>RestMachine uses decision states:</p> <pre><code># RestMachine style\n@app.authorized\ndef check_auth(request):\n    return is_authenticated(request)\n</code></pre> <p>Advantages: - Clearer HTTP semantics - Proper status codes automatically - Standards-compliant conditional requests - Built-in content negotiation</p>"},{"location":"advanced/state-machine/#next-steps","title":"Next Steps","text":"<ul> <li>Lifecycle \u2192 - Application lifecycle management</li> <li>Performance \u2192 - Optimization techniques</li> <li>Headers \u2192 - Working with HTTP headers</li> <li>Testing \u2192 - Test state machine behavior</li> </ul>"},{"location":"advanced/templates/","title":"Template Rendering","text":"<p>RestMachine supports template rendering for generating HTML, XML, and other text-based formats. This guide covers Jinja2 integration, template-based responses, and custom renderers.</p>"},{"location":"advanced/templates/#jinja2-integration","title":"Jinja2 Integration","text":""},{"location":"advanced/templates/#setup","title":"Setup","text":"<p>Install Jinja2 for template rendering:</p> <pre><code>pip install jinja2\n</code></pre>"},{"location":"advanced/templates/#basic-template-rendering","title":"Basic Template Rendering","text":"<p>Create a simple template rendering system:</p> <pre><code>from restmachine import RestApplication, Request\nfrom jinja2 import Environment, FileSystemLoader, select_autoescape\nimport os\n\napp = RestApplication()\n\n# Configure Jinja2\ntemplate_dir = os.path.join(os.path.dirname(__file__), 'templates')\njinja_env = Environment(\n    loader=FileSystemLoader(template_dir),\n    autoescape=select_autoescape(['html', 'xml'])\n)\n\n@app.dependency()\ndef templates():\n    \"\"\"Provide Jinja2 environment.\"\"\"\n    return jinja_env\n\n@app.get('/hello/{name}')\ndef hello_html(request: Request, templates):\n    \"\"\"Render HTML template.\"\"\"\n    template = templates.get_template('hello.html')\n    name = request.path_params['name']\n\n    html = template.render(name=name)\n\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre> <p>Template file (<code>templates/hello.html</code>):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Hello {{ name }}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;\n    &lt;p&gt;Welcome to RestMachine&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"advanced/templates/#template-helper-dependency","title":"Template Helper Dependency","text":"<p>Create a template helper for cleaner code:</p> <pre><code>@app.dependency()\ndef render_template(templates):\n    \"\"\"Template rendering helper.\"\"\"\n    def render(template_name: str, **context):\n        template = templates.get_template(template_name)\n        return template.render(**context)\n    return render\n\n@app.get('/users')\ndef list_users(database, render_template):\n    \"\"\"Render users list as HTML.\"\"\"\n    users = database[\"users\"]\n\n    html = render_template('users.html', users=users)\n\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre>"},{"location":"advanced/templates/#html-responses","title":"HTML Responses","text":""},{"location":"advanced/templates/#full-html-pages","title":"Full HTML Pages","text":"<p>Render complete HTML pages:</p> <pre><code>@app.get('/dashboard')\ndef dashboard(current_user, database, render_template):\n    \"\"\"User dashboard.\"\"\"\n    stats = {\n        'total_users': len(database['users']),\n        'total_posts': len(database['posts']),\n        'user_name': current_user['name']\n    }\n\n    html = render_template('dashboard.html', **stats)\n\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre> <p>Template (<code>templates/dashboard.html</code>):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Dashboard - {{ user_name }}&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"/static/style.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;nav&gt;\n        &lt;h1&gt;Dashboard&lt;/h1&gt;\n        &lt;p&gt;Welcome, {{ user_name }}&lt;/p&gt;\n    &lt;/nav&gt;\n\n    &lt;main&gt;\n        &lt;div class=\"stats\"&gt;\n            &lt;div class=\"stat\"&gt;\n                &lt;h2&gt;{{ total_users }}&lt;/h2&gt;\n                &lt;p&gt;Total Users&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div class=\"stat\"&gt;\n                &lt;h2&gt;{{ total_posts }}&lt;/h2&gt;\n                &lt;p&gt;Total Posts&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"advanced/templates/#template-inheritance","title":"Template Inheritance","text":"<p>Use base templates for consistent layout:</p> <p>Base template (<code>templates/base.html</code>):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;{% block title %}RestMachine App{% endblock %}&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"/static/style.css\"&gt;\n    {% block head %}{% endblock %}\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;nav&gt;\n            &lt;a href=\"/\"&gt;Home&lt;/a&gt;\n            &lt;a href=\"/users\"&gt;Users&lt;/a&gt;\n            &lt;a href=\"/posts\"&gt;Posts&lt;/a&gt;\n        &lt;/nav&gt;\n    &lt;/header&gt;\n\n    &lt;main&gt;\n        {% block content %}{% endblock %}\n    &lt;/main&gt;\n\n    &lt;footer&gt;\n        &lt;p&gt;&amp;copy; 2024 RestMachine App&lt;/p&gt;\n    &lt;/footer&gt;\n\n    {% block scripts %}{% endblock %}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Child template (<code>templates/users.html</code>):</p> <pre><code>{% extends \"base.html\" %}\n\n{% block title %}Users - RestMachine App{% endblock %}\n\n{% block content %}\n&lt;h1&gt;Users&lt;/h1&gt;\n\n&lt;table&gt;\n    &lt;thead&gt;\n        &lt;tr&gt;\n            &lt;th&gt;Name&lt;/th&gt;\n            &lt;th&gt;Email&lt;/th&gt;\n            &lt;th&gt;Role&lt;/th&gt;\n        &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n        {% for user in users %}\n        &lt;tr&gt;\n            &lt;td&gt;{{ user.name }}&lt;/td&gt;\n            &lt;td&gt;{{ user.email }}&lt;/td&gt;\n            &lt;td&gt;{{ user.role }}&lt;/td&gt;\n        &lt;/tr&gt;\n        {% endfor %}\n    &lt;/tbody&gt;\n&lt;/table&gt;\n{% endblock %}\n</code></pre>"},{"location":"advanced/templates/#partial-templates","title":"Partial Templates","text":"<p>Use includes for reusable components:</p> <pre><code>@app.get('/posts')\ndef list_posts(database, render_template):\n    \"\"\"Render posts with pagination.\"\"\"\n    posts = database[\"posts\"]\n\n    html = render_template(\n        'posts.html',\n        posts=posts,\n        page=1,\n        total_pages=5\n    )\n\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre> <p>Template with includes (<code>templates/posts.html</code>):</p> <pre><code>{% extends \"base.html\" %}\n\n{% block content %}\n&lt;h1&gt;Posts&lt;/h1&gt;\n\n{% for post in posts %}\n    {% include \"partials/post_card.html\" %}\n{% endfor %}\n\n{% include \"partials/pagination.html\" %}\n{% endblock %}\n</code></pre> <p>Partial (<code>templates/partials/post_card.html</code>):</p> <pre><code>&lt;article class=\"post-card\"&gt;\n    &lt;h2&gt;{{ post.title }}&lt;/h2&gt;\n    &lt;p class=\"meta\"&gt;By {{ post.author }} on {{ post.created_at }}&lt;/p&gt;\n    &lt;p&gt;{{ post.excerpt }}&lt;/p&gt;\n    &lt;a href=\"/posts/{{ post.id }}\"&gt;Read more&lt;/a&gt;\n&lt;/article&gt;\n</code></pre>"},{"location":"advanced/templates/#xml-rendering","title":"XML Rendering","text":""},{"location":"advanced/templates/#xml-templates","title":"XML Templates","text":"<p>Render XML responses:</p> <pre><code>@app.get('/api/users.xml')\ndef users_xml(database, render_template):\n    \"\"\"Render users as XML.\"\"\"\n    users = database[\"users\"]\n\n    xml = render_template('users.xml', users=users)\n\n    return xml, 200, {'Content-Type': 'application/xml'}\n</code></pre> <p>XML template (<code>templates/users.xml</code>):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;users&gt;\n    {% for user in users %}\n    &lt;user id=\"{{ user.id }}\"&gt;\n        &lt;name&gt;{{ user.name }}&lt;/name&gt;\n        &lt;email&gt;{{ user.email }}&lt;/email&gt;\n        &lt;role&gt;{{ user.role }}&lt;/role&gt;\n    &lt;/user&gt;\n    {% endfor %}\n&lt;/users&gt;\n</code></pre>"},{"location":"advanced/templates/#rssatom-feeds","title":"RSS/Atom Feeds","text":"<p>Generate RSS feeds:</p> <pre><code>from datetime import datetime\n\n@app.get('/feed.rss')\ndef rss_feed(database, render_template):\n    \"\"\"Generate RSS feed.\"\"\"\n    posts = database[\"posts\"][:10]  # Latest 10 posts\n\n    rss = render_template(\n        'feed.rss',\n        posts=posts,\n        build_date=datetime.now().strftime('%a, %d %b %Y %H:%M:%S GMT')\n    )\n\n    return rss, 200, {'Content-Type': 'application/rss+xml'}\n</code></pre> <p>RSS template (<code>templates/feed.rss</code>):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;rss version=\"2.0\"&gt;\n    &lt;channel&gt;\n        &lt;title&gt;RestMachine Blog&lt;/title&gt;\n        &lt;link&gt;https://example.com&lt;/link&gt;\n        &lt;description&gt;Latest posts from RestMachine Blog&lt;/description&gt;\n        &lt;lastBuildDate&gt;{{ build_date }}&lt;/lastBuildDate&gt;\n\n        {% for post in posts %}\n        &lt;item&gt;\n            &lt;title&gt;{{ post.title }}&lt;/title&gt;\n            &lt;link&gt;https://example.com/posts/{{ post.id }}&lt;/link&gt;\n            &lt;description&gt;{{ post.excerpt }}&lt;/description&gt;\n            &lt;pubDate&gt;{{ post.published_at }}&lt;/pubDate&gt;\n            &lt;guid&gt;https://example.com/posts/{{ post.id }}&lt;/guid&gt;\n        &lt;/item&gt;\n        {% endfor %}\n    &lt;/channel&gt;\n&lt;/rss&gt;\n</code></pre>"},{"location":"advanced/templates/#custom-filters-and-functions","title":"Custom Filters and Functions","text":""},{"location":"advanced/templates/#template-filters","title":"Template Filters","text":"<p>Add custom Jinja2 filters:</p> <pre><code>from datetime import datetime\n\n@app.dependency()\ndef templates():\n    \"\"\"Jinja2 environment with custom filters.\"\"\"\n    env = Environment(\n        loader=FileSystemLoader(template_dir),\n        autoescape=select_autoescape(['html', 'xml'])\n    )\n\n    # Custom filters\n    def format_datetime(value, format='%Y-%m-%d %H:%M:%S'):\n        \"\"\"Format datetime.\"\"\"\n        if isinstance(value, str):\n            value = datetime.fromisoformat(value)\n        return value.strftime(format)\n\n    def truncate_words(value, num_words=10):\n        \"\"\"Truncate to word count.\"\"\"\n        words = value.split()\n        if len(words) &lt;= num_words:\n            return value\n        return ' '.join(words[:num_words]) + '...'\n\n    env.filters['datetime'] = format_datetime\n    env.filters['truncate_words'] = truncate_words\n\n    return env\n\n# Usage in template:\n# {{ post.created_at | datetime('%B %d, %Y') }}\n# {{ post.content | truncate_words(20) }}\n</code></pre>"},{"location":"advanced/templates/#global-functions","title":"Global Functions","text":"<p>Add global template functions:</p> <pre><code>@app.dependency()\ndef templates(request: Request):\n    \"\"\"Jinja2 with global functions.\"\"\"\n    env = Environment(\n        loader=FileSystemLoader(template_dir),\n        autoescape=select_autoescape(['html', 'xml'])\n    )\n\n    # Global functions\n    def url_for(endpoint, **params):\n        \"\"\"Generate URL for endpoint.\"\"\"\n        # Simplified URL generation\n        url = f\"/{endpoint}\"\n        if params:\n            query = '&amp;'.join(f\"{k}={v}\" for k, v in params.items())\n            url += f\"?{query}\"\n        return url\n\n    def static(filename):\n        \"\"\"Generate static file URL.\"\"\"\n        return f\"/static/{filename}\"\n\n    env.globals['url_for'] = url_for\n    env.globals['static'] = static\n    env.globals['request'] = request\n\n    return env\n\n# Usage in template:\n# &lt;link rel=\"stylesheet\" href=\"{{ static('css/style.css') }}\"&gt;\n# &lt;a href=\"{{ url_for('posts', page=2) }}\"&gt;Next&lt;/a&gt;\n</code></pre>"},{"location":"advanced/templates/#content-negotiation-with-templates","title":"Content Negotiation with Templates","text":""},{"location":"advanced/templates/#multiple-format-support","title":"Multiple Format Support","text":"<p>Support different formats based on Accept header:</p> <pre><code>@app.get('/users')\ndef users_multi_format(request: Request, database, render_template):\n    \"\"\"Respond with HTML, JSON, or XML based on Accept header.\"\"\"\n    users = database[\"users\"]\n    accept = request.headers.get('accept', 'text/html')\n\n    if 'application/json' in accept:\n        return users\n\n    elif 'application/xml' in accept:\n        xml = render_template('users.xml', users=users)\n        return xml, 200, {'Content-Type': 'application/xml'}\n\n    else:  # Default to HTML\n        html = render_template('users.html', users=users)\n        return html, 200, {'Content-Type': 'text/html'}\n</code></pre>"},{"location":"advanced/templates/#custom-content-renderers","title":"Custom Content Renderers","text":"<p>Register template renderers for content negotiation:</p> <pre><code>@app.content_renderer(\"text/html\")\ndef html_renderer(data):\n    \"\"\"Render data as HTML.\"\"\"\n    if isinstance(data, dict) and 'template' in data:\n        template_name = data['template']\n        context = data.get('context', {})\n        template = jinja_env.get_template(template_name)\n        return template.render(**context)\n\n    # Fallback to JSON representation\n    return f\"&lt;pre&gt;{json.dumps(data, indent=2)}&lt;/pre&gt;\"\n\n@app.get('/users')\ndef users_with_renderer(database):\n    \"\"\"Use content renderer for templates.\"\"\"\n    users = database[\"users\"]\n\n    return {\n        'template': 'users.html',\n        'context': {'users': users}\n    }\n</code></pre>"},{"location":"advanced/templates/#form-handling","title":"Form Handling","text":""},{"location":"advanced/templates/#html-forms","title":"HTML Forms","text":"<p>Render and process HTML forms:</p> <pre><code>from pydantic import BaseModel, EmailStr\n\nclass UserForm(BaseModel):\n    name: str\n    email: EmailStr\n    bio: str = \"\"\n\n@app.get('/users/new')\ndef new_user_form(render_template):\n    \"\"\"Display user creation form.\"\"\"\n    html = render_template('user_form.html', errors={})\n    return html, 200, {'Content-Type': 'text/html'}\n\n@app.validates\ndef validate_user_form(request: Request) -&gt; UserForm:\n    \"\"\"Validate form data.\"\"\"\n    from urllib.parse import parse_qs\n\n    # Parse form data\n    data = parse_qs(request.body.decode())\n    form_data = {k: v[0] if len(v) == 1 else v for k, v in data.items()}\n\n    return UserForm.model_validate(form_data)\n\n@app.post('/users')\ndef create_user_from_form(validate_user_form: UserForm, database, render_template):\n    \"\"\"Create user from form submission.\"\"\"\n    # Create user\n    user = validate_user_form.model_dump()\n    user['id'] = str(len(database['users']) + 1)\n    database['users'].append(user)\n\n    # Render success page\n    html = render_template('user_created.html', user=user)\n    return html, 201, {'Content-Type': 'text/html'}\n\n@app.error_handler(400)\ndef form_validation_error(request, message, **kwargs):\n    \"\"\"Render form with validation errors.\"\"\"\n    validation_error = kwargs.get('validation_error')\n\n    if validation_error and 'text/html' in request.headers.get('accept', ''):\n        errors = {}\n        for error in validation_error.errors():\n            field = error['loc'][0]\n            errors[field] = error['msg']\n\n        template = jinja_env.get_template('user_form.html')\n        html = template.render(errors=errors)\n\n        return html, 400, {'Content-Type': 'text/html'}\n\n    # JSON error for API requests\n    return {\"error\": \"Validation failed\", \"message\": message}\n</code></pre> <p>Form template (<code>templates/user_form.html</code>):</p> <pre><code>{% extends \"base.html\" %}\n\n{% block content %}\n&lt;h1&gt;Create User&lt;/h1&gt;\n\n&lt;form method=\"POST\" action=\"/users\"&gt;\n    &lt;div class=\"form-group\"&gt;\n        &lt;label for=\"name\"&gt;Name:&lt;/label&gt;\n        &lt;input type=\"text\" id=\"name\" name=\"name\" required&gt;\n        {% if errors.name %}\n        &lt;span class=\"error\"&gt;{{ errors.name }}&lt;/span&gt;\n        {% endif %}\n    &lt;/div&gt;\n\n    &lt;div class=\"form-group\"&gt;\n        &lt;label for=\"email\"&gt;Email:&lt;/label&gt;\n        &lt;input type=\"email\" id=\"email\" name=\"email\" required&gt;\n        {% if errors.email %}\n        &lt;span class=\"error\"&gt;{{ errors.email }}&lt;/span&gt;\n        {% endif %}\n    &lt;/div&gt;\n\n    &lt;div class=\"form-group\"&gt;\n        &lt;label for=\"bio\"&gt;Bio:&lt;/label&gt;\n        &lt;textarea id=\"bio\" name=\"bio\"&gt;&lt;/textarea&gt;\n        {% if errors.bio %}\n        &lt;span class=\"error\"&gt;{{ errors.bio }}&lt;/span&gt;\n        {% endif %}\n    &lt;/div&gt;\n\n    &lt;button type=\"submit\"&gt;Create User&lt;/button&gt;\n&lt;/form&gt;\n{% endblock %}\n</code></pre>"},{"location":"advanced/templates/#email-templates","title":"Email Templates","text":""},{"location":"advanced/templates/#html-emails","title":"HTML Emails","text":"<p>Generate HTML emails:</p> <pre><code>@app.dependency()\ndef send_email():\n    \"\"\"Email sending function.\"\"\"\n    def send(to: str, subject: str, html: str):\n        # Implementation using smtplib, SendGrid, etc.\n        print(f\"Sending email to {to}: {subject}\")\n        print(html)\n\n    return send\n\n@app.post('/users')\ndef create_user_with_email(\n    validate_user: UserCreate,\n    database,\n    render_template,\n    send_email\n):\n    \"\"\"Create user and send welcome email.\"\"\"\n    # Create user\n    user = validate_user.model_dump()\n    user['id'] = str(len(database['users']) + 1)\n    database['users'].append(user)\n\n    # Render email template\n    email_html = render_template(\n        'emails/welcome.html',\n        user_name=user['name']\n    )\n\n    # Send email\n    send_email(\n        to=user['email'],\n        subject='Welcome to RestMachine!',\n        html=email_html\n    )\n\n    return user, 201\n</code></pre> <p>Email template (<code>templates/emails/welcome.html</code>):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;style&gt;\n        body { font-family: Arial, sans-serif; }\n        .container { max-width: 600px; margin: 0 auto; }\n        .header { background: #007bff; color: white; padding: 20px; }\n        .content { padding: 20px; }\n        .button {\n            display: inline-block;\n            padding: 10px 20px;\n            background: #007bff;\n            color: white;\n            text-decoration: none;\n            border-radius: 5px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;div class=\"header\"&gt;\n            &lt;h1&gt;Welcome to RestMachine!&lt;/h1&gt;\n        &lt;/div&gt;\n        &lt;div class=\"content\"&gt;\n            &lt;p&gt;Hi {{ user_name }},&lt;/p&gt;\n            &lt;p&gt;Thank you for joining RestMachine. We're excited to have you!&lt;/p&gt;\n            &lt;p&gt;\n                &lt;a href=\"https://example.com/getting-started\" class=\"button\"&gt;\n                    Get Started\n                &lt;/a&gt;\n            &lt;/p&gt;\n            &lt;p&gt;Best regards,&lt;br&gt;The RestMachine Team&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"advanced/templates/#complete-example","title":"Complete Example","text":"<p>Here's a complete template-based application:</p> <pre><code>from restmachine import RestApplication, Request\nfrom jinja2 import Environment, FileSystemLoader, select_autoescape\nfrom pydantic import BaseModel, EmailStr\nfrom datetime import datetime\nimport os\n\napp = RestApplication()\n\n# Configure templates\ntemplate_dir = os.path.join(os.path.dirname(__file__), 'templates')\njinja_env = Environment(\n    loader=FileSystemLoader(template_dir),\n    autoescape=select_autoescape(['html', 'xml'])\n)\n\n# Custom filters\ndef format_date(value, format='%B %d, %Y'):\n    if isinstance(value, str):\n        value = datetime.fromisoformat(value)\n    return value.strftime(format)\n\njinja_env.filters['date'] = format_date\n\n# Database\n@app.on_startup\ndef database():\n    return {\n        \"users\": [\n            {\"id\": \"1\", \"name\": \"Alice\", \"email\": \"alice@example.com\", \"role\": \"admin\"},\n            {\"id\": \"2\", \"name\": \"Bob\", \"email\": \"bob@example.com\", \"role\": \"user\"}\n        ],\n        \"posts\": [\n            {\n                \"id\": \"1\",\n                \"title\": \"First Post\",\n                \"content\": \"This is my first post!\",\n                \"author_id\": \"1\",\n                \"created_at\": \"2024-01-01T10:00:00\"\n            }\n        ]\n    }\n\n# Dependencies\n@app.dependency()\ndef render_template():\n    \"\"\"Template rendering helper.\"\"\"\n    def render(template_name: str, **context):\n        template = jinja_env.get_template(template_name)\n        return template.render(**context)\n    return render\n\n# Models\nclass PostCreate(BaseModel):\n    title: str\n    content: str\n\n# Routes\n@app.get('/')\ndef index(database, render_template):\n    \"\"\"Home page.\"\"\"\n    html = render_template(\n        'index.html',\n        user_count=len(database['users']),\n        post_count=len(database['posts'])\n    )\n    return html, 200, {'Content-Type': 'text/html'}\n\n@app.get('/users')\ndef list_users(database, render_template):\n    \"\"\"List users.\"\"\"\n    html = render_template('users.html', users=database['users'])\n    return html, 200, {'Content-Type': 'text/html'}\n\n@app.get('/posts')\ndef list_posts(database, render_template):\n    \"\"\"List posts.\"\"\"\n    posts = database['posts']\n\n    # Enhance posts with author info\n    for post in posts:\n        author = next(\n            (u for u in database['users'] if u['id'] == post['author_id']),\n            None\n        )\n        post['author_name'] = author['name'] if author else 'Unknown'\n\n    html = render_template('posts.html', posts=posts)\n    return html, 200, {'Content-Type': 'text/html'}\n\n@app.get('/posts/{post_id}')\ndef view_post(request: Request, database, render_template):\n    \"\"\"View single post.\"\"\"\n    post_id = request.path_params['post_id']\n    post = next((p for p in database['posts'] if p['id'] == post_id), None)\n\n    if not post:\n        html = render_template('404.html')\n        return html, 404, {'Content-Type': 'text/html'}\n\n    # Get author\n    author = next(\n        (u for u in database['users'] if u['id'] == post['author_id']),\n        None\n    )\n    post['author_name'] = author['name'] if author else 'Unknown'\n\n    html = render_template('post.html', post=post)\n    return html, 200, {'Content-Type': 'text/html'}\n\n# ASGI\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n</code></pre>"},{"location":"advanced/templates/#best-practices","title":"Best Practices","text":""},{"location":"advanced/templates/#1-escape-user-input","title":"1. Escape User Input","text":"<p>Always escape user-provided content:</p> <pre><code># Jinja2 auto-escapes in HTML/XML contexts\njinja_env = Environment(\n    loader=FileSystemLoader(template_dir),\n    autoescape=select_autoescape(['html', 'xml'])\n)\n\n# Manual escaping when needed\nfrom markupsafe import escape\n\n@app.get('/search')\ndef search(request: Request, render_template):\n    query = request.query_params.get('q', '')\n    # Auto-escaped in template\n    html = render_template('search.html', query=query)\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre>"},{"location":"advanced/templates/#2-use-template-caching","title":"2. Use Template Caching","text":"<p>Enable template caching for production:</p> <pre><code>jinja_env = Environment(\n    loader=FileSystemLoader(template_dir),\n    autoescape=select_autoescape(['html', 'xml']),\n    cache_size=400,  # Cache up to 400 templates\n    auto_reload=False  # Disable in production\n)\n</code></pre>"},{"location":"advanced/templates/#3-organize-templates","title":"3. Organize Templates","text":"<p>Use a clear directory structure:</p> <pre><code>templates/\n\u251c\u2500\u2500 base.html\n\u251c\u2500\u2500 index.html\n\u251c\u2500\u2500 users/\n\u2502   \u251c\u2500\u2500 list.html\n\u2502   \u251c\u2500\u2500 detail.html\n\u2502   \u2514\u2500\u2500 form.html\n\u251c\u2500\u2500 posts/\n\u2502   \u251c\u2500\u2500 list.html\n\u2502   \u2514\u2500\u2500 detail.html\n\u251c\u2500\u2500 emails/\n\u2502   \u251c\u2500\u2500 welcome.html\n\u2502   \u2514\u2500\u2500 notification.html\n\u2514\u2500\u2500 partials/\n    \u251c\u2500\u2500 header.html\n    \u251c\u2500\u2500 footer.html\n    \u2514\u2500\u2500 pagination.html\n</code></pre>"},{"location":"advanced/templates/#4-provide-context-processors","title":"4. Provide Context Processors","text":"<p>Add common context to all templates:</p> <pre><code>@app.dependency()\ndef render_template(request: Request, current_user=None):\n    \"\"\"Render with common context.\"\"\"\n    def render(template_name: str, **context):\n        # Add common context\n        context.setdefault('request', request)\n        context.setdefault('current_user', current_user)\n        context.setdefault('site_name', 'RestMachine App')\n\n        template = jinja_env.get_template(template_name)\n        return template.render(**context)\n\n    return render\n</code></pre>"},{"location":"advanced/templates/#5-handle-missing-templates","title":"5. Handle Missing Templates","text":"<p>Gracefully handle missing templates:</p> <pre><code>from jinja2.exceptions import TemplateNotFound\n\n@app.dependency()\ndef render_template():\n    def render(template_name: str, **context):\n        try:\n            template = jinja_env.get_template(template_name)\n            return template.render(**context)\n        except TemplateNotFound:\n            # Log error\n            logger.error(f\"Template not found: {template_name}\")\n            # Return 500 error\n            raise ValueError(f\"Template {template_name} not found\")\n\n    return render\n</code></pre>"},{"location":"advanced/templates/#next-steps","title":"Next Steps","text":"<ul> <li>Content Negotiation \u2192 - Multi-format responses</li> <li>Headers \u2192 - Content-Type and caching headers</li> <li>Error Handling \u2192 - Template error pages</li> <li>Testing \u2192 - Test template rendering</li> </ul>"},{"location":"advanced/tls/","title":"TLS and Mutual TLS (mTLS)","text":"<p>RestMachine supports TLS/SSL and mutual TLS authentication for secure communications. This guide covers TLS setup with ASGI servers, AWS integration, and client certificate authentication.</p>"},{"location":"advanced/tls/#tls-with-asgi-servers","title":"TLS with ASGI Servers","text":""},{"location":"advanced/tls/#uvicorn-with-tls","title":"Uvicorn with TLS","text":"<p>Run Uvicorn with TLS certificates:</p> <pre><code># Generate self-signed certificates for development\nopenssl req -x509 -newkey rsa:4096 -nodes \\\n  -keyout key.pem -out cert.pem -days 365 \\\n  -subj \"/CN=localhost\"\n\n# Run with TLS\nuvicorn app:asgi_app \\\n  --host 0.0.0.0 \\\n  --port 8443 \\\n  --ssl-keyfile key.pem \\\n  --ssl-certfile cert.pem\n</code></pre> <p>Production configuration:</p> <pre><code># With Let's Encrypt certificates\nuvicorn app:asgi_app \\\n  --host 0.0.0.0 \\\n  --port 443 \\\n  --ssl-keyfile /etc/letsencrypt/live/example.com/privkey.pem \\\n  --ssl-certfile /etc/letsencrypt/live/example.com/fullchain.pem \\\n  --workers 4\n</code></pre>"},{"location":"advanced/tls/#hypercorn-with-tls","title":"Hypercorn with TLS","text":"<p>Run Hypercorn with TLS support:</p> <pre><code># Basic TLS\nhypercorn app:asgi_app \\\n  --bind 0.0.0.0:8443 \\\n  --certfile cert.pem \\\n  --keyfile key.pem\n\n# Production with HTTP/2\nhypercorn app:asgi_app \\\n  --bind 0.0.0.0:443 \\\n  --certfile /etc/letsencrypt/live/example.com/fullchain.pem \\\n  --keyfile /etc/letsencrypt/live/example.com/privkey.pem \\\n  --workers 4 \\\n  --worker-class uvloop\n</code></pre>"},{"location":"advanced/tls/#hypercorn-configuration-file","title":"Hypercorn Configuration File","text":"<p>Use a configuration file for advanced settings:</p> <pre><code># hypercorn_config.toml\nbind = [\"0.0.0.0:443\"]\ncertfile = \"/etc/letsencrypt/live/example.com/fullchain.pem\"\nkeyfile = \"/etc/letsencrypt/live/example.com/privkey.pem\"\nworkers = 4\nworker_class = \"uvloop\"\naccesslog = \"-\"\nerrorlog = \"-\"\n</code></pre> <p>Run with config:</p> <pre><code>hypercorn app:asgi_app -c hypercorn_config.toml\n</code></pre>"},{"location":"advanced/tls/#mutual-tls-mtls","title":"Mutual TLS (mTLS)","text":""},{"location":"advanced/tls/#client-certificate-authentication","title":"Client Certificate Authentication","text":"<p>Enable client certificate verification:</p>"},{"location":"advanced/tls/#uvicorn-with-mtls","title":"Uvicorn with mTLS","text":"<pre><code># Run with client certificate verification\nuvicorn app:asgi_app \\\n  --host 0.0.0.0 \\\n  --port 8443 \\\n  --ssl-keyfile server-key.pem \\\n  --ssl-certfile server-cert.pem \\\n  --ssl-ca-certs ca-cert.pem \\\n  --ssl-cert-reqs 2  # CERT_REQUIRED\n</code></pre>"},{"location":"advanced/tls/#hypercorn-with-mtls","title":"Hypercorn with mTLS","text":"<pre><code># hypercorn_mtls_config.toml\nbind = [\"0.0.0.0:8443\"]\ncertfile = \"server-cert.pem\"\nkeyfile = \"server-key.pem\"\nca_certs = \"ca-cert.pem\"\nverify_mode = \"CERT_REQUIRED\"\n</code></pre>"},{"location":"advanced/tls/#accessing-client-certificate","title":"Accessing Client Certificate","text":"<p>RestMachine provides client certificate information through the TLS extension:</p> <pre><code>from restmachine import RestApplication, Request\nfrom restmachine.extensions.tls import TLSExtension\n\napp = RestApplication()\n\n# Enable TLS extension\napp.add_extension(TLSExtension())\n\n@app.dependency()\ndef client_cert(request: Request):\n    \"\"\"Extract client certificate from request.\"\"\"\n    tls = request.extensions.get('tls')\n\n    if not tls:\n        raise ValueError(\"TLS information not available\")\n\n    client_cert = tls.get('client_cert')\n\n    if not client_cert:\n        raise ValueError(\"Client certificate required\")\n\n    return client_cert\n\n@app.dependency()\ndef authenticated_user(client_cert):\n    \"\"\"Extract user identity from certificate.\"\"\"\n    subject = client_cert.get('subject', {})\n\n    # Extract Common Name (CN)\n    cn = None\n    for rdn in subject.get('rdnSequence', []):\n        for attr in rdn:\n            if attr.get('type') == 'commonName':\n                cn = attr.get('value')\n                break\n\n    if not cn:\n        raise ValueError(\"Certificate missing Common Name\")\n\n    return {\n        'id': cn,\n        'cert_serial': client_cert.get('serialNumber'),\n        'cert_issuer': client_cert.get('issuer')\n    }\n\n@app.get('/api/secure')\ndef secure_endpoint(authenticated_user):\n    \"\"\"Endpoint requiring client certificate.\"\"\"\n    return {\n        \"message\": f\"Hello, {authenticated_user['id']}\",\n        \"cert_serial\": authenticated_user['cert_serial']\n    }\n</code></pre>"},{"location":"advanced/tls/#certificate-validation","title":"Certificate Validation","text":"<p>Implement custom certificate validation:</p> <pre><code>from datetime import datetime\n\n@app.dependency()\ndef validate_client_cert(client_cert):\n    \"\"\"Validate client certificate.\"\"\"\n    # Check expiration\n    not_after = client_cert.get('notAfter')\n    if not_after:\n        expiry = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')\n        if expiry &lt; datetime.now():\n            raise ValueError(\"Certificate expired\")\n\n    # Check issuer\n    issuer = client_cert.get('issuer', {})\n    org = None\n    for rdn in issuer.get('rdnSequence', []):\n        for attr in rdn:\n            if attr.get('type') == 'organizationName':\n                org = attr.get('value')\n                break\n\n    if org != 'Trusted CA Inc':\n        raise ValueError(\"Certificate from untrusted CA\")\n\n    return client_cert\n\n@app.get('/api/validated')\ndef validated_endpoint(validate_client_cert):\n    \"\"\"Endpoint with certificate validation.\"\"\"\n    subject = validate_client_cert.get('subject', {})\n    return {\"status\": \"authenticated\", \"subject\": subject}\n</code></pre>"},{"location":"advanced/tls/#aws-integration","title":"AWS Integration","text":""},{"location":"advanced/tls/#application-load-balancer-alb-with-tls","title":"Application Load Balancer (ALB) with TLS","text":"<p>ALB terminates TLS and forwards requests to RestMachine:</p> <pre><code>from restmachine import RestApplication, Request\n\napp = RestApplication()\n\n@app.dependency()\ndef client_cert_from_alb(request: Request):\n    \"\"\"Extract client certificate from ALB headers.\"\"\"\n    # ALB adds client cert to X-Amzn-Mtls-Clientcert header\n    cert_header = request.headers.get('x-amzn-mtls-clientcert')\n\n    if not cert_header:\n        raise ValueError(\"Client certificate required\")\n\n    # Decode URL-encoded certificate\n    import urllib.parse\n    cert_pem = urllib.parse.unquote(cert_header)\n\n    # Parse certificate\n    from cryptography import x509\n    from cryptography.hazmat.backends import default_backend\n\n    cert = x509.load_pem_x509_certificate(\n        cert_pem.encode(),\n        default_backend()\n    )\n\n    return {\n        'subject': cert.subject.rfc4514_string(),\n        'issuer': cert.issuer.rfc4514_string(),\n        'serial': str(cert.serial_number),\n        'not_before': cert.not_valid_before.isoformat(),\n        'not_after': cert.not_valid_after.isoformat()\n    }\n\n@app.dependency()\ndef authenticated_user_alb(client_cert_from_alb):\n    \"\"\"Get user from ALB client certificate.\"\"\"\n    # Extract CN from subject\n    subject = client_cert_from_alb['subject']\n    cn = None\n\n    for part in subject.split(','):\n        if part.strip().startswith('CN='):\n            cn = part.strip()[3:]\n            break\n\n    if not cn:\n        raise ValueError(\"Certificate missing CN\")\n\n    return {'id': cn, 'cert': client_cert_from_alb}\n\n@app.get('/api/alb-secure')\ndef alb_secure_endpoint(authenticated_user_alb):\n    \"\"\"Endpoint with ALB mTLS.\"\"\"\n    return {\n        \"message\": f\"Hello from ALB, {authenticated_user_alb['id']}\",\n        \"cert_info\": authenticated_user_alb['cert']\n    }\n</code></pre>"},{"location":"advanced/tls/#alb-configuration","title":"ALB Configuration","text":"<p>Configure ALB for mTLS:</p> <pre><code># CloudFormation/Terraform example\nListener:\n  Port: 443\n  Protocol: HTTPS\n  Certificates:\n    - CertificateArn: arn:aws:acm:region:account:certificate/id\n  MutualAuthentication:\n    Mode: verify  # or 'passthrough'\n    TrustStoreArn: arn:aws:elasticloadbalancing:region:account:truststore/name/id\n  DefaultActions:\n    - Type: forward\n      TargetGroupArn: !Ref TargetGroup\n</code></pre>"},{"location":"advanced/tls/#api-gateway-with-tls","title":"API Gateway with TLS","text":"<p>API Gateway with mutual TLS:</p> <pre><code>from restmachine import RestApplication, Request\n\napp = RestApplication()\n\n@app.dependency()\ndef client_cert_from_apigw(request: Request):\n    \"\"\"Extract client certificate from API Gateway.\"\"\"\n    # API Gateway adds certificate info to request context\n    # Accessed via APIGW-specific event structure\n\n    # For RestMachine with API Gateway, certificate info\n    # is in the request context\n    context = getattr(request, 'request_context', {})\n\n    identity = context.get('identity', {})\n    cert_info = identity.get('clientCert', {})\n\n    if not cert_info:\n        raise ValueError(\"Client certificate required\")\n\n    return {\n        'subject_dn': cert_info.get('subjectDN'),\n        'issuer_dn': cert_info.get('issuerDN'),\n        'serial': cert_info.get('serialNumber'),\n        'validity': {\n            'not_before': cert_info.get('validity', {}).get('notBefore'),\n            'not_after': cert_info.get('validity', {}).get('notAfter')\n        }\n    }\n\n@app.dependency()\ndef authenticated_user_apigw(client_cert_from_apigw):\n    \"\"\"Get user from API Gateway client certificate.\"\"\"\n    subject_dn = client_cert_from_apigw['subject_dn']\n\n    # Parse subject DN (e.g., \"CN=user,OU=dept,O=org\")\n    cn = None\n    for part in subject_dn.split(','):\n        if part.strip().startswith('CN='):\n            cn = part.strip()[3:]\n            break\n\n    if not cn:\n        raise ValueError(\"Certificate missing CN\")\n\n    return {'id': cn, 'cert': client_cert_from_apigw}\n\n@app.get('/api/apigw-secure')\ndef apigw_secure_endpoint(authenticated_user_apigw):\n    \"\"\"Endpoint with API Gateway mTLS.\"\"\"\n    return {\n        \"message\": f\"Hello from API Gateway, {authenticated_user_apigw['id']}\",\n        \"cert_info\": authenticated_user_apigw['cert']\n    }\n\n# For AWS Lambda with API Gateway\nfrom restmachine_aws import AwsApiGatewayAdapter\n\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"advanced/tls/#api-gateway-configuration","title":"API Gateway Configuration","text":"<p>Configure API Gateway for mTLS:</p> <pre><code># API Gateway REST API with mTLS\nDomainName:\n  DomainName: api.example.com\n  MutualTlsAuthentication:\n    TruststoreUri: s3://bucket-name/truststore.pem\n    TruststoreVersion: version-id\n  RegionalCertificateArn: arn:aws:acm:region:account:certificate/id\n\nBasePathMapping:\n  DomainName: !Ref DomainName\n  RestApiId: !Ref RestApi\n  Stage: prod\n</code></pre>"},{"location":"advanced/tls/#certificate-based-authorization","title":"Certificate-Based Authorization","text":""},{"location":"advanced/tls/#role-based-access-from-certificates","title":"Role-Based Access from Certificates","text":"<p>Map certificate attributes to roles:</p> <pre><code>from enum import Enum\n\nclass Role(str, Enum):\n    ADMIN = \"admin\"\n    USER = \"user\"\n    SERVICE = \"service\"\n\n# Certificate OU to Role mapping\nOU_TO_ROLE = {\n    'Administrators': Role.ADMIN,\n    'Users': Role.USER,\n    'Services': Role.SERVICE\n}\n\n@app.dependency()\ndef user_role(client_cert):\n    \"\"\"Extract role from certificate OU.\"\"\"\n    subject = client_cert.get('subject', {})\n\n    # Find OU (Organizational Unit)\n    ou = None\n    for rdn in subject.get('rdnSequence', []):\n        for attr in rdn:\n            if attr.get('type') == 'organizationalUnitName':\n                ou = attr.get('value')\n                break\n\n    if not ou:\n        return Role.USER  # Default role\n\n    return OU_TO_ROLE.get(ou, Role.USER)\n\n@app.dependency()\ndef require_admin_cert(user_role: Role):\n    \"\"\"Require admin certificate.\"\"\"\n    if user_role != Role.ADMIN:\n        raise PermissionError(f\"Admin certificate required, got: {user_role}\")\n    return True\n\n@app.get('/admin/users')\ndef admin_endpoint(require_admin_cert, authenticated_user):\n    \"\"\"Admin-only endpoint requiring admin certificate.\"\"\"\n    return {\n        \"message\": \"Admin access granted\",\n        \"user\": authenticated_user['id']\n    }\n</code></pre>"},{"location":"advanced/tls/#certificate-pinning","title":"Certificate Pinning","text":"<p>Validate specific certificate fingerprints:</p> <pre><code>import hashlib\n\n# Allowed certificate fingerprints (SHA-256)\nALLOWED_CERT_FINGERPRINTS = {\n    'aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99',\n    '11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff'\n}\n\n@app.dependency()\ndef pinned_certificate(client_cert):\n    \"\"\"Validate certificate against pinned fingerprints.\"\"\"\n    # Get DER-encoded certificate\n    der = client_cert.get('der')\n\n    if not der:\n        raise ValueError(\"Certificate DER encoding not available\")\n\n    # Calculate SHA-256 fingerprint\n    fingerprint = hashlib.sha256(der).hexdigest()\n    fingerprint_formatted = ':'.join(\n        fingerprint[i:i+2] for i in range(0, len(fingerprint), 2)\n    )\n\n    if fingerprint_formatted not in ALLOWED_CERT_FINGERPRINTS:\n        raise ValueError(\"Certificate not in allowed list\")\n\n    return client_cert\n\n@app.get('/api/pinned')\ndef pinned_endpoint(pinned_certificate, authenticated_user):\n    \"\"\"Endpoint requiring pinned certificate.\"\"\"\n    return {\n        \"message\": \"Certificate pinning successful\",\n        \"user\": authenticated_user['id']\n    }\n</code></pre>"},{"location":"advanced/tls/#complete-examples","title":"Complete Examples","text":""},{"location":"advanced/tls/#full-mtls-application","title":"Full mTLS Application","text":"<pre><code>from restmachine import RestApplication, Request\nfrom restmachine.extensions.tls import TLSExtension\nfrom datetime import datetime\nfrom typing import Dict, Any\nimport logging\n\napp = RestApplication()\n\n# Enable TLS extension\napp.add_extension(TLSExtension())\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Certificate validation\n@app.dependency()\ndef client_cert(request: Request) -&gt; Dict[str, Any]:\n    \"\"\"Extract and validate client certificate.\"\"\"\n    tls = request.extensions.get('tls')\n\n    if not tls:\n        raise ValueError(\"TLS not enabled\")\n\n    cert = tls.get('client_cert')\n\n    if not cert:\n        raise ValueError(\"Client certificate required\")\n\n    # Validate expiration\n    not_after = cert.get('notAfter')\n    if not_after:\n        try:\n            expiry = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')\n            if expiry &lt; datetime.now():\n                raise ValueError(\"Certificate expired\")\n        except ValueError as e:\n            logger.warning(f\"Could not parse certificate expiry: {e}\")\n\n    return cert\n\n@app.dependency()\ndef authenticated_user(client_cert: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Extract user from certificate.\"\"\"\n    subject = client_cert.get('subject', {})\n\n    # Extract attributes\n    cn = None\n    email = None\n    ou = None\n\n    for rdn in subject.get('rdnSequence', []):\n        for attr in rdn:\n            attr_type = attr.get('type')\n            if attr_type == 'commonName':\n                cn = attr.get('value')\n            elif attr_type == 'emailAddress':\n                email = attr.get('value')\n            elif attr_type == 'organizationalUnitName':\n                ou = attr.get('value')\n\n    if not cn:\n        raise ValueError(\"Certificate missing Common Name\")\n\n    user = {\n        'id': cn,\n        'email': email,\n        'department': ou,\n        'cert_serial': client_cert.get('serialNumber')\n    }\n\n    logger.info(f\"User authenticated via mTLS: {cn}\")\n\n    return user\n\n# Role-based access\n@app.dependency()\ndef user_role(authenticated_user: Dict[str, Any]) -&gt; str:\n    \"\"\"Determine user role from department.\"\"\"\n    dept = authenticated_user.get('department', '')\n\n    if dept == 'Administrators':\n        return 'admin'\n    elif dept == 'Services':\n        return 'service'\n    else:\n        return 'user'\n\n@app.dependency()\ndef require_admin(user_role: str):\n    \"\"\"Require admin role.\"\"\"\n    if user_role != 'admin':\n        raise PermissionError(\"Admin access required\")\n    return True\n\n# Routes\n@app.get('/api/profile')\ndef get_profile(authenticated_user: Dict[str, Any]):\n    \"\"\"Get user profile from certificate.\"\"\"\n    return {\n        \"user\": authenticated_user,\n        \"authenticated_via\": \"mTLS\"\n    }\n\n@app.get('/api/admin/status')\ndef admin_status(require_admin, authenticated_user: Dict[str, Any]):\n    \"\"\"Admin endpoint requiring admin certificate.\"\"\"\n    return {\n        \"status\": \"OK\",\n        \"admin\": authenticated_user['id'],\n        \"timestamp\": datetime.now().isoformat()\n    }\n\n@app.get('/api/cert-info')\ndef cert_info(client_cert: Dict[str, Any]):\n    \"\"\"Get detailed certificate information.\"\"\"\n    return {\n        \"subject\": client_cert.get('subject'),\n        \"issuer\": client_cert.get('issuer'),\n        \"serial\": client_cert.get('serialNumber'),\n        \"validity\": {\n            \"not_before\": client_cert.get('notBefore'),\n            \"not_after\": client_cert.get('notAfter')\n        }\n    }\n\n# Error handlers\n@app.error_handler(401)\ndef unauthorized(request, message, **kwargs):\n    logger.warning(f\"Unauthorized access attempt: {message}\")\n    return {\n        \"error\": \"Unauthorized\",\n        \"message\": message,\n        \"hint\": \"Valid client certificate required\"\n    }\n\n@app.error_handler(403)\ndef forbidden(request, message, **kwargs):\n    logger.warning(f\"Forbidden access attempt: {message}\")\n    return {\n        \"error\": \"Forbidden\",\n        \"message\": message\n    }\n\n# ASGI\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n\nif __name__ == '__main__':\n    # Run with uvicorn\n    # uvicorn app:asgi_app --host 0.0.0.0 --port 8443 \\\n    #   --ssl-keyfile server-key.pem \\\n    #   --ssl-certfile server-cert.pem \\\n    #   --ssl-ca-certs ca-cert.pem \\\n    #   --ssl-cert-reqs 2\n    pass\n</code></pre>"},{"location":"advanced/tls/#aws-alb-mtls-example","title":"AWS ALB mTLS Example","text":"<pre><code>from restmachine import RestApplication, Request\nfrom cryptography import x509\nfrom cryptography.hazmat.backends import default_backend\nimport urllib.parse\nimport logging\n\napp = RestApplication()\nlogger = logging.getLogger(__name__)\n\n@app.dependency()\ndef alb_client_cert(request: Request):\n    \"\"\"Extract client certificate from ALB.\"\"\"\n    cert_header = request.headers.get('x-amzn-mtls-clientcert')\n\n    if not cert_header:\n        raise ValueError(\"Client certificate required\")\n\n    # Decode URL-encoded certificate\n    cert_pem = urllib.parse.unquote(cert_header)\n\n    # Parse certificate\n    cert = x509.load_pem_x509_certificate(\n        cert_pem.encode(),\n        default_backend()\n    )\n\n    return {\n        'subject': cert.subject.rfc4514_string(),\n        'issuer': cert.issuer.rfc4514_string(),\n        'serial': str(cert.serial_number),\n        'not_before': cert.not_valid_before,\n        'not_after': cert.not_valid_after,\n        'raw_cert': cert\n    }\n\n@app.dependency()\ndef validate_alb_cert(alb_client_cert):\n    \"\"\"Validate ALB client certificate.\"\"\"\n    from datetime import datetime, timezone\n\n    # Check expiration\n    now = datetime.now(timezone.utc)\n    if alb_client_cert['not_after'] &lt; now:\n        raise ValueError(\"Certificate expired\")\n\n    if alb_client_cert['not_before'] &gt; now:\n        raise ValueError(\"Certificate not yet valid\")\n\n    # Extract CN\n    subject = alb_client_cert['subject']\n    cn = None\n    for part in subject.split(','):\n        if part.strip().startswith('CN='):\n            cn = part.strip()[3:]\n            break\n\n    if not cn:\n        raise ValueError(\"Certificate missing CN\")\n\n    return {'id': cn, 'cert': alb_client_cert}\n\n@app.get('/api/alb-mtls')\ndef alb_mtls_endpoint(validate_alb_cert):\n    \"\"\"ALB mTLS endpoint.\"\"\"\n    return {\n        \"message\": f\"Authenticated via ALB mTLS\",\n        \"user\": validate_alb_cert['id'],\n        \"cert_serial\": validate_alb_cert['cert']['serial']\n    }\n\n# ASGI for ALB\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n</code></pre>"},{"location":"advanced/tls/#testing-mtls-locally","title":"Testing mTLS Locally","text":""},{"location":"advanced/tls/#generate-test-certificates","title":"Generate Test Certificates","text":"<pre><code>#!/bin/bash\n# generate-mtls-certs.sh\n\n# Create CA\nopenssl req -x509 -newkey rsa:4096 -nodes \\\n  -keyout ca-key.pem -out ca-cert.pem -days 365 \\\n  -subj \"/CN=Test CA\"\n\n# Create server certificate\nopenssl req -newkey rsa:4096 -nodes \\\n  -keyout server-key.pem -out server-req.pem \\\n  -subj \"/CN=localhost\"\n\nopenssl x509 -req -in server-req.pem -days 365 \\\n  -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial \\\n  -out server-cert.pem\n\n# Create client certificate (admin)\nopenssl req -newkey rsa:4096 -nodes \\\n  -keyout client-admin-key.pem -out client-admin-req.pem \\\n  -subj \"/CN=admin/OU=Administrators/emailAddress=admin@example.com\"\n\nopenssl x509 -req -in client-admin-req.pem -days 365 \\\n  -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial \\\n  -out client-admin-cert.pem\n\n# Create client certificate (user)\nopenssl req -newkey rsa:4096 -nodes \\\n  -keyout client-user-key.pem -out client-user-req.pem \\\n  -subj \"/CN=user1/OU=Users/emailAddress=user1@example.com\"\n\nopenssl x509 -req -in client-user-req.pem -days 365 \\\n  -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial \\\n  -out client-user-cert.pem\n\necho \"Certificates generated successfully\"\n</code></pre>"},{"location":"advanced/tls/#test-with-curl","title":"Test with cURL","text":"<pre><code># Test with admin certificate\ncurl https://localhost:8443/api/profile \\\n  --cert client-admin-cert.pem \\\n  --key client-admin-key.pem \\\n  --cacert ca-cert.pem\n\n# Test admin endpoint\ncurl https://localhost:8443/api/admin/status \\\n  --cert client-admin-cert.pem \\\n  --key client-admin-key.pem \\\n  --cacert ca-cert.pem\n\n# Test with user certificate (should fail for admin endpoint)\ncurl https://localhost:8443/api/admin/status \\\n  --cert client-user-cert.pem \\\n  --key client-user-key.pem \\\n  --cacert ca-cert.pem\n\n# Test without certificate (should fail)\ncurl https://localhost:8443/api/profile \\\n  --cacert ca-cert.pem\n</code></pre>"},{"location":"advanced/tls/#best-practices","title":"Best Practices","text":""},{"location":"advanced/tls/#1-always-validate-certificate-expiration","title":"1. Always Validate Certificate Expiration","text":"<pre><code>@app.dependency()\ndef validate_cert_expiry(client_cert):\n    from datetime import datetime\n\n    not_after = client_cert.get('notAfter')\n    if not_after:\n        expiry = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')\n        if expiry &lt; datetime.now():\n            raise ValueError(\"Certificate expired\")\n\n    return client_cert\n</code></pre>"},{"location":"advanced/tls/#2-use-certificate-revocation-lists-crl","title":"2. Use Certificate Revocation Lists (CRL)","text":"<pre><code>@app.dependency()\ndef check_revocation(client_cert):\n    \"\"\"Check if certificate is revoked.\"\"\"\n    serial = client_cert.get('serialNumber')\n\n    # Check against CRL or OCSP\n    if is_revoked(serial):\n        raise ValueError(\"Certificate has been revoked\")\n\n    return client_cert\n</code></pre>"},{"location":"advanced/tls/#3-log-certificate-usage","title":"3. Log Certificate Usage","text":"<pre><code>@app.dependency()\ndef log_cert_usage(authenticated_user, request: Request):\n    \"\"\"Log certificate usage for audit.\"\"\"\n    logger.info(\n        \"Certificate authentication\",\n        extra={\n            'user': authenticated_user['id'],\n            'path': request.path,\n            'cert_serial': authenticated_user.get('cert_serial'),\n            'timestamp': datetime.now().isoformat()\n        }\n    )\n    return authenticated_user\n</code></pre>"},{"location":"advanced/tls/#4-use-strong-cipher-suites","title":"4. Use Strong Cipher Suites","text":"<pre><code># Uvicorn with strong ciphers\nuvicorn app:asgi_app \\\n  --ssl-ciphers \"ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS\"\n</code></pre>"},{"location":"advanced/tls/#5-implement-certificate-rotation","title":"5. Implement Certificate Rotation","text":"<pre><code>@app.dependency()\ndef check_cert_age(client_cert):\n    \"\"\"Warn if certificate is old.\"\"\"\n    from datetime import datetime, timedelta\n\n    not_after = client_cert.get('notAfter')\n    if not_after:\n        expiry = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')\n        days_until_expiry = (expiry - datetime.now()).days\n\n        if days_until_expiry &lt; 30:\n            logger.warning(\n                f\"Certificate expires in {days_until_expiry} days. \"\n                f\"Serial: {client_cert.get('serialNumber')}\"\n            )\n\n    return client_cert\n</code></pre>"},{"location":"advanced/tls/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication \u2192 - Combine with other auth methods</li> <li>Error Handling \u2192 - Handle certificate errors</li> <li>Deployment \u2192 - Deploy with mTLS</li> <li>Testing \u2192 - Test mTLS endpoints</li> </ul>"},{"location":"api/adapters/","title":"ASGI Adapter","text":""},{"location":"api/adapters/#asgiadapter","title":"ASGIAdapter","text":""},{"location":"api/adapters/#restmachine.ASGIAdapter","title":"ASGIAdapter","text":"<pre><code>ASGIAdapter(\n    app: RestApplication,\n    metrics_publisher: Union[\n        MetricsPublisher, None, _DefaultPublisher\n    ] = _DEFAULT_PUBLISHER,\n    enable_metrics: Optional[bool] = None,\n    namespace: Optional[str] = None,\n    service_name: Optional[str] = None,\n    metrics_resolution: int = 60,\n)\n</code></pre> <p>ASGI 3.0 adapter for running RestMachine applications on ASGI servers.</p> <p>This adapter enables RestMachine applications to run on any ASGI-compatible server (Uvicorn, Hypercorn, Daphne, etc.) while maintaining the synchronous programming model internally.</p> <p>The adapter handles: - True streaming of request bodies (application receives data as it arrives) - Converting ASGI scope/receive/send to RestMachine Request - Executing the synchronous RestMachine application in a thread pool - Converting RestMachine Response to ASGI response format (streaming if needed) - Proper header normalization and encoding - Content-Type and Content-Length handling - Automatic AWS detection - Enables CloudWatch EMF metrics when running in AWS</p> <p>Streaming behavior: - Request bodies: The adapter receives the first chunk, passes the stream to the   application immediately, and continues receiving chunks in the background. The   application can start processing before all data has arrived. - Response bodies: File-like objects are streamed in 8KB chunks with proper   ASGI more_body signaling.</p> <p>Metrics behavior: - AWS auto-detection: When AWS environment is detected (via AWS_REGION or   AWS_EXECUTION_ENV), CloudWatch EMF metrics are automatically enabled - Manual configuration: Pass custom metrics_publisher for other platforms - Disable: Set enable_metrics=False to disable metrics</p> Example <pre><code>from restmachine import RestApplication\nfrom restmachine.adapters import ASGIAdapter\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home(metrics):\n    metrics.add_metric(\"requests\", 1)\n    return {\"message\": \"Hello World\"}\n\n# Create ASGI application - metrics auto-enabled if in AWS\nasgi_app = ASGIAdapter(app)\n\n# Use with any ASGI server:\n# uvicorn module:asgi_app\n# hypercorn module:asgi_app\n</code></pre> <p>Initialize the ASGI adapter with optional metrics support.</p> <p>Automatically detects AWS environment and enables CloudWatch EMF metrics when running on AWS (ECS, EC2, App Runner, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>RestApplication</code> <p>The RestMachine application to wrap</p> required <code>metrics_publisher</code> <code>Union[MetricsPublisher, None, _DefaultPublisher]</code> <p>Metrics publisher. Defaults to auto-detection:               - CloudWatch EMF if AWS environment detected               - None if not in AWS               Pass explicit publisher to override, or None to disable.</p> <code>_DEFAULT_PUBLISHER</code> <code>enable_metrics</code> <code>Optional[bool]</code> <p>Explicitly enable/disable metrics (overrides auto-detection)</p> <code>None</code> <code>namespace</code> <code>Optional[str]</code> <p>CloudWatch namespace (used if AWS detected, default: \"RestMachine\")</p> <code>None</code> <code>service_name</code> <code>Optional[str]</code> <p>Service name dimension (default: from env or \"asgi-app\")</p> <code>None</code> <code>metrics_resolution</code> <code>int</code> <p>Metric resolution in seconds, 1 or 60 (default: 60)</p> <code>60</code> <p>Examples:</p>"},{"location":"api/adapters/#restmachine.ASGIAdapter--auto-detect-aws-and-enable-emf","title":"Auto-detect AWS and enable EMF","text":"<p>adapter = ASGIAdapter(app)</p>"},{"location":"api/adapters/#restmachine.ASGIAdapter--custom-namespace-for-aws","title":"Custom namespace for AWS","text":"<p>adapter = ASGIAdapter(app, namespace=\"MyApp/API\")</p>"},{"location":"api/adapters/#restmachine.ASGIAdapter--custom-publisher-prometheus-etc","title":"Custom publisher (Prometheus, etc.)","text":"<p>adapter = ASGIAdapter(app, metrics_publisher=PrometheusPublisher())</p>"},{"location":"api/adapters/#restmachine.ASGIAdapter--disable-metrics","title":"Disable metrics","text":"<p>adapter = ASGIAdapter(app, enable_metrics=False)</p>"},{"location":"api/adapters/#restmachine.ASGIAdapter-functions","title":"Functions","text":""},{"location":"api/adapters/#restmachine.ASGIAdapter.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(\n    scope: Dict[str, Any],\n    receive: Callable[[], Awaitable[Dict[str, Any]]],\n    send: Callable[[Dict[str, Any]], Awaitable[None]],\n)\n</code></pre> <p>ASGI 3.0 application entry point.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>Dict[str, Any]</code> <p>ASGI connection scope dictionary</p> required <code>receive</code> <code>Callable[[], Awaitable[Dict[str, Any]]]</code> <p>Async callable to receive ASGI messages</p> required <code>send</code> <code>Callable[[Dict[str, Any]], Awaitable[None]]</code> <p>Async callable to send ASGI messages</p> required"},{"location":"api/adapters/#adapter-base-class","title":"Adapter (Base Class)","text":""},{"location":"api/adapters/#restmachine.Adapter","title":"Adapter","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for synchronous event adapters.</p> <p>Use this base class for platforms that use synchronous event handling, such as AWS Lambda, Azure Functions, Google Cloud Functions, etc.</p> <p>For ASGI servers, use ASGIAdapter instead.</p>"},{"location":"api/adapters/#restmachine.Adapter-functions","title":"Functions","text":""},{"location":"api/adapters/#restmachine.Adapter.handle_event","title":"handle_event  <code>abstractmethod</code>","text":"<pre><code>handle_event(event: Any, context: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Handle an external event and return the appropriate response format.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Any</code> <p>The external event (e.g., AWS Lambda event)</p> required <code>context</code> <code>Optional[Any]</code> <p>Optional context (e.g., AWS Lambda context)</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Response in the format expected by the external system</p>"},{"location":"api/adapters/#restmachine.Adapter.convert_to_request","title":"convert_to_request  <code>abstractmethod</code>","text":"<pre><code>convert_to_request(event: Any, context: Optional[Any] = None) -&gt; Request\n</code></pre> <p>Convert an external event to a Request object.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Any</code> <p>The external event</p> required <code>context</code> <code>Optional[Any]</code> <p>Optional context</p> <code>None</code> <p>Returns:</p> Type Description <code>Request</code> <p>Request object that can be processed by the app</p>"},{"location":"api/adapters/#restmachine.Adapter.convert_from_response","title":"convert_from_response  <code>abstractmethod</code>","text":"<pre><code>convert_from_response(\n    response: Response, event: Any, context: Optional[Any] = None\n) -&gt; Any\n</code></pre> <p>Convert a Response object to the format expected by the external system.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Response from the app</p> required <code>event</code> <code>Any</code> <p>Original external event</p> required <code>context</code> <code>Optional[Any]</code> <p>Optional context</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Response in the format expected by the external system</p>"},{"location":"api/adapters/#create_asgi_app","title":"create_asgi_app","text":""},{"location":"api/adapters/#restmachine.create_asgi_app","title":"create_asgi_app","text":"<pre><code>create_asgi_app(app: RestApplication, **adapter_kwargs: Any) -&gt; ASGIAdapter\n</code></pre> <p>Create an ASGI application from a RestMachine application.</p> <p>This is a convenience function for creating ASGI adapters with optional metrics configuration.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>RestApplication</code> <p>The RestMachine application to wrap</p> required <code>**adapter_kwargs</code> <code>Any</code> <p>Additional arguments passed to ASGIAdapter: - metrics_publisher: Custom metrics publisher - enable_metrics: Explicitly enable/disable metrics - namespace: CloudWatch namespace (if AWS detected) - service_name: Service name dimension - metrics_resolution: Metric resolution (1 or 60 seconds)</p> <code>{}</code> <p>Returns:</p> Type Description <code>ASGIAdapter</code> <p>An ASGI-compatible application</p> <p>Examples:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine.adapters import create_asgi_app\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home(metrics):\n    metrics.add_metric(\"requests\", 1)\n    return {\"message\": \"Hello World\"}\n\n# Auto-detect AWS and enable EMF (default)\nasgi_app = create_asgi_app(app)\n\n# Custom namespace for AWS\nasgi_app = create_asgi_app(app, namespace=\"MyApp/API\")\n\n# Disable metrics\nasgi_app = create_asgi_app(app, enable_metrics=False)\n\n# Run with uvicorn\n# uvicorn module:asgi_app --reload\n</code></pre>"},{"location":"api/adapters/#overview","title":"Overview","text":"<p>Adapters convert RestMachine applications to run on different platforms. The <code>ASGIAdapter</code> enables deployment on any ASGI-compatible server (Uvicorn, Hypercorn, Daphne, etc.).</p>"},{"location":"api/adapters/#quick-start","title":"Quick Start","text":"<pre><code>from restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n@app.get('/hello')\ndef hello():\n    return {\"message\": \"Hello World\"}\n\n# Create ASGI app\nasgi_app = ASGIAdapter(app)\n\n# Run with uvicorn\n# uvicorn myapp:asgi_app --reload\n</code></pre>"},{"location":"api/adapters/#see-also","title":"See Also","text":"<ul> <li>Application API - Main application class</li> <li>Uvicorn Deployment Guide - Deploy with Uvicorn</li> <li>Hypercorn Deployment Guide - Deploy with Hypercorn</li> <li>AWS Lambda Adapter - Deploy to Lambda</li> </ul>"},{"location":"api/application/","title":"Application","text":""},{"location":"api/application/#restmachine.RestApplication","title":"RestApplication","text":"<pre><code>RestApplication()\n</code></pre> <p>Main application class for the REST framework.</p>"},{"location":"api/application/#restmachine.RestApplication-functions","title":"Functions","text":""},{"location":"api/application/#restmachine.RestApplication.get","title":"get","text":"<pre><code>get(path: str)\n</code></pre> <p>Decorator to register a GET route handler on the root router.</p>"},{"location":"api/application/#restmachine.RestApplication.post","title":"post","text":"<pre><code>post(path: str)\n</code></pre> <p>Decorator to register a POST route handler on the root router.</p>"},{"location":"api/application/#restmachine.RestApplication.put","title":"put","text":"<pre><code>put(path: str)\n</code></pre> <p>Decorator to register a PUT route handler on the root router.</p>"},{"location":"api/application/#restmachine.RestApplication.patch","title":"patch","text":"<pre><code>patch(path: str)\n</code></pre> <p>Decorator to register a PATCH route handler on the root router.</p>"},{"location":"api/application/#restmachine.RestApplication.delete","title":"delete","text":"<pre><code>delete(path: str)\n</code></pre> <p>Decorator to register a DELETE route handler on the root router.</p>"},{"location":"api/application/#restmachine.RestApplication.options","title":"options","text":"<pre><code>options(path: str)\n</code></pre> <p>Decorator to register an OPTIONS route handler on the root router.</p>"},{"location":"api/application/#restmachine.RestApplication.dependency","title":"dependency","text":"<pre><code>dependency(name: Optional[str] = None, scope: DependencyScope = 'request')\n</code></pre> <p>Decorator to register a dependency provider.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Optional name for the dependency. If not provided, uses the function name.</p> <code>None</code> <code>scope</code> <code>DependencyScope</code> <p>Dependency scope - \"request\" (default) or \"session\".    - \"request\": Cached per request, cleared between requests    - \"session\": Cached across all requests, never cleared automatically</p> <code>'request'</code>"},{"location":"api/application/#restmachine.RestApplication.validates","title":"validates","text":"<pre><code>validates(func: Callable, scope: DependencyScope = 'request')\n</code></pre> <p>Decorator to mark a function as returning a validated Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>DependencyScope</code> <p>Dependency scope - \"request\" (default) or \"session\"</p> <code>'request'</code>"},{"location":"api/application/#restmachine.RestApplication.on_startup","title":"on_startup","text":"<pre><code>on_startup(func: Optional[Callable] = None)\n</code></pre> <p>Register a startup handler to run when the application starts.</p> <p>Can be used as a decorator::</p> <pre><code>@app.on_startup\nasync def database():\n    print(\"Opening database connection...\")\n    return create_db_connection()\n\n@app.get(\"/users\")\ndef get_users(database):  # database from startup is injected here\n    return database.query(\"SELECT * FROM users\")\n</code></pre> <p>Or called directly::</p> <pre><code>app.on_startup(my_startup_function)\n</code></pre> <p>Startup handlers are automatically registered as session-scoped dependencies, so their return values can be injected into route handlers and other dependencies. Handlers can be sync or async functions.</p>"},{"location":"api/application/#restmachine.RestApplication.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(func: Optional[Callable] = None)\n</code></pre> <p>Register a shutdown handler to run when the application stops.</p> <p>Can be used as a decorator::</p> <pre><code>@app.on_shutdown\nasync def shutdown():\n    print(\"Application shutting down...\")\n    # Close connections, cleanup resources, etc.\n</code></pre> <p>Or called directly::</p> <pre><code>app.on_shutdown(my_shutdown_function)\n</code></pre> <p>Handlers can be sync or async functions.</p>"},{"location":"api/application/#restmachine.RestApplication.mount","title":"mount","text":"<pre><code>mount(prefix: str, router: Router)\n</code></pre> <p>Mount a router with a given prefix.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The path prefix for all routes in the mounted router</p> required <code>router</code> <code>Router</code> <p>The router to mount</p> required Example <p>app = RestApplication() users_router = Router() users_router.get(\"/\")(lambda: {\"users\": []}) users_router.get(\"/{id}\")(lambda id: {\"user\": id})</p> <p>app.mount(\"/users\", users_router)</p>"},{"location":"api/application/#restmachine.RestApplication.mount--this-creates-routes-get-users-and-get-usersid","title":"This creates routes: GET /users/ and GET /users/{id}","text":""},{"location":"api/application/#restmachine.RestApplication.execute","title":"execute","text":"<pre><code>execute(request: Request) -&gt; Response\n</code></pre> <p>Execute a request through the state machine.</p>"},{"location":"api/application/#restmachine.RestApplication.startup_sync","title":"startup_sync","text":"<pre><code>startup_sync()\n</code></pre> <p>Synchronous wrapper for startup().</p> <p>This is called automatically by the AWS Lambda adapter during cold start to execute startup handlers in a synchronous context (module-level initialization).</p> <p>Uses anyio.run() to execute the async startup() method synchronously.</p>"},{"location":"api/application/#restmachine.RestApplication.shutdown_sync","title":"shutdown_sync","text":"<pre><code>shutdown_sync()\n</code></pre> <p>Synchronous wrapper for shutdown().</p> <p>This can be called by AWS Lambda Extensions or other synchronous shutdown hooks to execute shutdown handlers in a synchronous context.</p> <p>Uses anyio.run() to execute the async shutdown() method synchronously.</p>"},{"location":"api/application/#overview","title":"Overview","text":"<p><code>RestApplication</code> is the main entry point for building REST APIs with RestMachine. It provides:</p> <ul> <li>Route registration - Flask-style decorators for HTTP methods</li> <li>Dependency injection - pytest-style parameter injection</li> <li>Content negotiation - Automatic format selection based on Accept headers</li> <li>Validation - Optional Pydantic integration for request/response validation</li> <li>Lifecycle hooks - Startup and shutdown handlers</li> <li>Router mounting - Compose applications from multiple routers</li> </ul>"},{"location":"api/application/#quick-start","title":"Quick Start","text":"<pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.get('/hello/{name}')\ndef hello(path_params):\n    name = path_params['name']\n    return {\"message\": f\"Hello, {name}!\"}\n</code></pre>"},{"location":"api/application/#route-registration","title":"Route Registration","text":""},{"location":"api/application/#http-method-decorators","title":"HTTP Method Decorators","text":"<p>Register routes using HTTP method decorators:</p> <pre><code>@app.get('/users')\ndef list_users():\n    return {\"users\": [...]}\n\n@app.post('/users')\ndef create_user(json_body):\n    # json_body automatically injected for JSON requests\n    return {\"created\": True}, 201\n\n@app.put('/users/{user_id}')\ndef update_user(path_params, json_body):\n    user_id = path_params['user_id']\n    return {\"updated\": user_id}\n\n@app.delete('/users/{user_id}')\ndef delete_user(path_params):\n    user_id = path_params['user_id']\n    return {\"deleted\": user_id}, 204\n</code></pre>"},{"location":"api/application/#path-parameters","title":"Path Parameters","text":"<p>Use <code>{param}</code> syntax for path parameters, accessed via the <code>path_params</code> dependency:</p> <pre><code>@app.get('/users/{user_id}/posts/{post_id}')\ndef get_post(path_params):\n    user_id = path_params['user_id']\n    post_id = path_params['post_id']\n    return {\"user_id\": user_id, \"post_id\": post_id}\n</code></pre>"},{"location":"api/application/#generic-route-registration","title":"Generic Route Registration","text":"<p>Use <code>@app.route()</code> for custom methods or multiple methods:</p> <pre><code>@app.route('PATCH', '/users/{user_id}')\ndef patch_user(request):\n    return {\"patched\": True}\n</code></pre>"},{"location":"api/application/#dependency-injection","title":"Dependency Injection","text":"<p>Share resources across handlers using pytest-style dependency injection:</p> <pre><code>@app.on_startup\ndef database():\n    \"\"\"Create database connection at startup.\"\"\"\n    return create_db_connection()\n\n@app.resource_exists\ndef user(database, path_params):\n    \"\"\"Check if user exists and return it.\"\"\"\n    user_id = path_params.get('user_id')\n    return database.get_user(user_id)  # Returns None if not found\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    \"\"\"User is injected, 404 handled automatically if None.\"\"\"\n    return user\n\n@app.get('/posts')\ndef list_posts(database):\n    \"\"\"Database instance is reused across all requests.\"\"\"\n    return {\"posts\": database.query(\"SELECT * FROM posts\")}\n</code></pre> <p>Startup dependencies persist across all requests. See Dependency Injection Guide for details.</p>"},{"location":"api/application/#request-validation","title":"Request Validation","text":"<p>Validate request bodies using Pydantic with the <code>@app.validates</code> decorator:</p> <pre><code>from pydantic import BaseModel\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\n@app.validates\ndef validate_user(json_body) -&gt; UserCreate:\n    \"\"\"Validates JSON body, returns 422 on validation error.\"\"\"\n    return UserCreate.model_validate(json_body)\n\n@app.post('/users')\ndef create_user(validate_user: UserCreate):\n    \"\"\"Validated model is injected, errors handled automatically.\"\"\"\n    return {\"created\": validate_user.model_dump()}, 201\n</code></pre>"},{"location":"api/application/#content-negotiation","title":"Content Negotiation","text":"<p>Serve multiple formats using the <code>@app.provides</code> decorator:</p> <pre><code>@app.get('/data')\ndef get_data():\n    return {\"key\": \"value\"}\n\n@app.provides(\"text/html\")\ndef render_html(get_data):\n    data = get_data\n    return f\"&lt;div&gt;{data}&lt;/div&gt;\"\n\n@app.provides(\"application/xml\")\ndef render_xml(get_data):\n    data = get_data\n    return f\"&lt;result&gt;{data}&lt;/result&gt;\"\n# Returns JSON, HTML, or XML based on Accept header\n</code></pre> <p>Built-in renderers: JSON (default), HTML, Plain Text. See Content Negotiation Guide for details.</p>"},{"location":"api/application/#error-handling","title":"Error Handling","text":"<p>Register custom error handlers:</p> <pre><code>@app.error_handler(404)\ndef not_found_handler(error):\n    \"\"\"Handle 404 errors.\"\"\"\n    return {\"error\": \"Not Found\", \"path\": error.get(\"path\")}, 404\n\n@app.error_handler(500)\ndef server_error_handler(error):\n    \"\"\"Handle 500 errors.\"\"\"\n    return {\"error\": \"Internal Server Error\"}, 500\n\n@app.error_handler()  # Default handler for all errors\ndef default_error_handler(error):\n    \"\"\"Fallback for unhandled errors.\"\"\"\n    return {\"error\": \"Something went wrong\"}, 500\n</code></pre>"},{"location":"api/application/#lifecycle-handlers","title":"Lifecycle Handlers","text":"<p>Manage application startup and shutdown:</p> <pre><code>@app.on_startup\ndef init_database():\n    \"\"\"Runs once at startup.\"\"\"\n    print(\"Initializing database...\")\n    return create_db_connection()\n\n@app.on_shutdown\ndef close_database(init_database):\n    \"\"\"Runs at shutdown, can inject startup dependencies.\"\"\"\n    print(\"Closing database...\")\n    init_database.close()\n\n@app.on_startup(scope=DependencyScope.SESSION)\ndef load_config():\n    \"\"\"SESSION scope - persists across requests.\"\"\"\n    return load_app_config()\n</code></pre> <p>See Lifecycle Handlers Guide for details.</p>"},{"location":"api/application/#mounting-routers","title":"Mounting Routers","text":"<p>Compose applications from multiple routers:</p> <pre><code>from restmachine import Router\n\napi_v1 = Router()\n\n@api_v1.get('/users')\ndef list_users():\n    return {\"users\": [...]}\n\n# Mount at /api/v1\napp.mount('/api/v1', api_v1)\n\n# Access: GET /api/v1/users\n</code></pre> <p>See Router API for details.</p>"},{"location":"api/application/#executing-requests","title":"Executing Requests","text":"<p>Execute requests directly (useful for testing):</p> <pre><code>from restmachine import Request, HTTPMethod\n\nrequest = Request(\n    method=HTTPMethod.GET,\n    path=\"/users/123\",\n    headers={},\n    query_params={},\n    body=\"\"\n)\n\nresponse = app.execute(request)\nprint(response.status_code, response.body)\n</code></pre>"},{"location":"api/application/#deployment","title":"Deployment","text":""},{"location":"api/application/#asgi-servers","title":"ASGI Servers","text":"<pre><code>from restmachine import ASGIAdapter\n\nasgi_app = ASGIAdapter(app)\n\n# Run with uvicorn\n# uvicorn app:asgi_app --reload\n</code></pre>"},{"location":"api/application/#aws-lambda","title":"AWS Lambda","text":"<pre><code>from restmachine_aws import AwsApiGatewayAdapter\n\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"api/application/#configuration","title":"Configuration","text":""},{"location":"api/application/#constructor-options","title":"Constructor Options","text":"<pre><code>app = RestApplication(\n    # Add custom configuration here if needed\n)\n</code></pre>"},{"location":"api/application/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide - Build your first API</li> <li>Basic Application Guide - Core concepts</li> <li>Dependency Injection - Share resources</li> <li>Content Negotiation - Multiple formats</li> <li>Validation - Request/response validation</li> <li>Router API - Composable routers</li> <li>Request &amp; Response - Request/response models</li> </ul>"},{"location":"api/content-renderers/","title":"Content Renderers","text":""},{"location":"api/content-renderers/#built-in-renderers","title":"Built-in Renderers","text":""},{"location":"api/content-renderers/#restmachine.JSONRenderer","title":"JSONRenderer","text":"<pre><code>JSONRenderer()\n</code></pre> <p>               Bases: <code>ContentRenderer</code></p> <p>JSON content renderer.</p>"},{"location":"api/content-renderers/#restmachine.JSONRenderer-functions","title":"Functions","text":""},{"location":"api/content-renderers/#restmachine.JSONRenderer.render","title":"render","text":"<pre><code>render(data: Any, request: Request) -&gt; str\n</code></pre> <p>Render data as JSON.</p>"},{"location":"api/content-renderers/#restmachine.HTMLRenderer","title":"HTMLRenderer","text":"<pre><code>HTMLRenderer()\n</code></pre> <p>               Bases: <code>ContentRenderer</code></p> <p>HTML content renderer with Jinja2 template support.</p>"},{"location":"api/content-renderers/#restmachine.HTMLRenderer-functions","title":"Functions","text":""},{"location":"api/content-renderers/#restmachine.HTMLRenderer.render","title":"render","text":"<pre><code>render(data: Any, request: Request) -&gt; str\n</code></pre> <p>Render data as HTML.</p> <p>This renderer now supports Jinja2 templates via the render() helper. For backward compatibility, it still accepts pre-rendered HTML strings.</p>"},{"location":"api/content-renderers/#restmachine.PlainTextRenderer","title":"PlainTextRenderer","text":"<pre><code>PlainTextRenderer()\n</code></pre> <p>               Bases: <code>ContentRenderer</code></p> <p>Plain text content renderer.</p>"},{"location":"api/content-renderers/#restmachine.PlainTextRenderer-functions","title":"Functions","text":""},{"location":"api/content-renderers/#restmachine.PlainTextRenderer.render","title":"render","text":"<pre><code>render(data: Any, request: Request) -&gt; str\n</code></pre> <p>Render data as plain text.</p>"},{"location":"api/content-renderers/#contentrenderer-base-class","title":"ContentRenderer Base Class","text":""},{"location":"api/content-renderers/#restmachine.ContentRenderer","title":"ContentRenderer","text":"<pre><code>ContentRenderer(media_type: str)\n</code></pre> <p>Base class for content renderers.</p>"},{"location":"api/content-renderers/#restmachine.ContentRenderer-functions","title":"Functions","text":""},{"location":"api/content-renderers/#restmachine.ContentRenderer.can_render","title":"can_render","text":"<pre><code>can_render(accept_header: str) -&gt; bool\n</code></pre> <p>Check if this renderer can handle the given Accept header.</p>"},{"location":"api/content-renderers/#restmachine.ContentRenderer.render","title":"render","text":"<pre><code>render(data: Any, request: Request) -&gt; str\n</code></pre> <p>Render the data as this content type.</p>"},{"location":"api/content-renderers/#overview","title":"Overview","text":"<p>Content renderers convert response data into different formats based on the client's <code>Accept</code> header. RestMachine includes built-in renderers for JSON, HTML, and plain text.</p>"},{"location":"api/content-renderers/#custom-renderers","title":"Custom Renderers","text":"<p>Register custom renderers for specific content types:</p> <pre><code>@app.content_renderer(\"application/xml\")\ndef render_xml(data):\n    \"\"\"Render data as XML.\"\"\"\n    return f\"&lt;result&gt;{data}&lt;/result&gt;\"\n\n@app.get('/data')\ndef get_data():\n    return {\"key\": \"value\"}\n    # Returns JSON or XML based on Accept header\n</code></pre>"},{"location":"api/content-renderers/#see-also","title":"See Also","text":"<ul> <li>Content Negotiation Guide - Complete guide</li> <li>Application API - Register renderers</li> </ul>"},{"location":"api/dependencies/","title":"Dependencies","text":""},{"location":"api/dependencies/#restmachine.DependencyScope","title":"DependencyScope  <code>module-attribute</code>","text":"<pre><code>DependencyScope = Literal['request', 'session']\n</code></pre>"},{"location":"api/dependencies/#overview","title":"Overview","text":"<p>The dependency injection system in RestMachine allows you to share resources across handlers automatically. Dependencies are defined using the <code>@app.dependency()</code> decorator and resolved based on parameter names.</p>"},{"location":"api/dependencies/#quick-start","title":"Quick Start","text":"<pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.dependency()\ndef database():\n    \"\"\"Create database connection.\"\"\"\n    return create_db_connection()\n\n@app.get('/users')\ndef list_users(database):\n    \"\"\"database is automatically injected.\"\"\"\n    return {\"users\": database.query(\"SELECT * FROM users\")}\n</code></pre>"},{"location":"api/dependencies/#dependency-scopes","title":"Dependency Scopes","text":""},{"location":"api/dependencies/#request-scope-default","title":"REQUEST Scope (Default)","text":"<p>Dependencies are created once per request and cached:</p> <pre><code>@app.dependency()  # Default scope is REQUEST\ndef database():\n    print(\"Creating database connection\")\n    return create_db_connection()\n\n@app.get('/users')\ndef list_users(database):\n    return {\"users\": database.query(\"SELECT * FROM users\")}\n\n@app.get('/posts')\ndef list_posts(database):\n    # Same database instance as list_users (within same request)\n    return {\"posts\": database.query(\"SELECT * FROM posts\")}\n</code></pre>"},{"location":"api/dependencies/#session-scope","title":"SESSION Scope","text":"<p>Dependencies are created once per application lifetime:</p> <pre><code>from restmachine import DependencyScope\n\n@app.dependency(scope=DependencyScope.SESSION)\ndef config():\n    \"\"\"Load config once at startup.\"\"\"\n    print(\"Loading configuration...\")\n    return load_app_config()\n\n@app.get('/info')\ndef get_info(config):\n    # Config is loaded once and reused across all requests\n    return {\"version\": config['version']}\n</code></pre>"},{"location":"api/dependencies/#dependency-chain","title":"Dependency Chain","text":"<p>Dependencies can depend on other dependencies:</p> <pre><code>@app.dependency()\ndef database():\n    return create_db_connection()\n\n@app.dependency()\ndef user_repository(database):\n    \"\"\"Depends on database.\"\"\"\n    return UserRepository(database)\n\n@app.get('/users/{user_id}')\ndef get_user(user_id: str, user_repository):\n    \"\"\"user_repository (and database) are automatically injected.\"\"\"\n    user = user_repository.get(user_id)\n    return user or ({\"error\": \"Not found\"}, 404)\n</code></pre>"},{"location":"api/dependencies/#see-also","title":"See Also","text":"<ul> <li>Dependency Injection Guide - Complete guide</li> <li>Application API - Main application class</li> <li>Lifecycle Handlers - Startup dependencies</li> </ul>"},{"location":"api/error-models/","title":"Error Models","text":""},{"location":"api/error-models/#restmachine.ErrorResponse","title":"ErrorResponse","text":"<pre><code>ErrorResponse(\n    error: str,\n    details: Optional[List[Dict[str, Any]]] = None,\n    request_id: Optional[str] = None,\n    trace_id: Optional[str] = None,\n)\n</code></pre> <p>Fallback ErrorResponse when Pydantic is not available.</p>"},{"location":"api/error-models/#restmachine.ErrorResponse-functions","title":"Functions","text":""},{"location":"api/error-models/#restmachine.ErrorResponse.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(**kwargs)\n</code></pre> <p>Serialize to JSON string.</p>"},{"location":"api/error-models/#restmachine.ErrorResponse.model_dump","title":"model_dump","text":"<pre><code>model_dump(**kwargs)\n</code></pre> <p>Serialize to dict.</p>"},{"location":"api/error-models/#restmachine.ErrorResponse.from_validation_error","title":"from_validation_error  <code>classmethod</code>","text":"<pre><code>from_validation_error(\n    error: Any,\n    message: str = \"Validation failed\",\n    request_id: Optional[str] = None,\n    trace_id: Optional[str] = None,\n)\n</code></pre> <p>Create an ErrorResponse from a validation error.</p>"},{"location":"api/error-models/#restmachine.ValidationError","title":"ValidationError  <code>module-attribute</code>","text":"<pre><code>ValidationError = ValidationError\n</code></pre>"},{"location":"api/error-models/#overview","title":"Overview","text":"<p>Error models provide structured error responses for REST APIs.</p>"},{"location":"api/error-models/#errorresponse","title":"ErrorResponse","text":"<p>Standard error response format:</p> <pre><code>from restmachine import ErrorResponse\n\n@app.get('/users/{user_id}')\ndef get_user(user_id: str):\n    user = db.get(user_id)\n\n    if not user:\n        return ErrorResponse(\n            error=\"Not Found\",\n            message=f\"User {user_id} not found\",\n            status_code=404\n        )\n\n    return user\n</code></pre>"},{"location":"api/error-models/#validationerror","title":"ValidationError","text":"<p>Raised when request validation fails:</p> <pre><code>from pydantic import BaseModel\nfrom restmachine import ValidationError\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\n@app.post('/users')\ndef create_user(request):\n    try:\n        data = UserCreate.model_validate_json(request.body)\n    except Exception as e:\n        raise ValidationError(str(e))\n\n    return {\"created\": data.model_dump()}, 201\n</code></pre>"},{"location":"api/error-models/#see-also","title":"See Also","text":"<ul> <li>Error Handling Guide - Complete guide</li> <li>Application API - Error handlers</li> </ul>"},{"location":"api/models/","title":"Request &amp; Response Models","text":""},{"location":"api/models/#request","title":"Request","text":""},{"location":"api/models/#restmachine.Request","title":"Request  <code>dataclass</code>","text":"<pre><code>Request(\n    method: HTTPMethod,\n    path: str,\n    headers: Union[Dict[str, str], MultiValueHeaders],\n    body: Optional[BinaryIO] = None,\n    query_params: Optional[Dict[str, str]] = None,\n    path_params: Optional[Dict[str, str]] = None,\n    tls: bool = False,\n    client_cert: Optional[Dict[str, Any]] = None,\n)\n</code></pre> <p>Represents an HTTP request.</p> <p>Supports the ASGI TLS extension for TLS/SSL connection information.</p> <p>The body is a file-like stream of bytes that can be read by content parsers. This allows efficient handling of large request bodies without loading everything into memory.</p>"},{"location":"api/models/#restmachine.Request-functions","title":"Functions","text":""},{"location":"api/models/#restmachine.Request.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Ensure headers is a MultiValueHeaders for case-insensitive header lookups.</p>"},{"location":"api/models/#restmachine.Request.get_accept_header","title":"get_accept_header","text":"<pre><code>get_accept_header() -&gt; str\n</code></pre> <p>Get the Accept header, defaulting to / if not present.</p>"},{"location":"api/models/#restmachine.Request.get_content_type","title":"get_content_type","text":"<pre><code>get_content_type() -&gt; Optional[str]\n</code></pre> <p>Get the Content-Type header.</p>"},{"location":"api/models/#restmachine.Request.get_authorization_header","title":"get_authorization_header","text":"<pre><code>get_authorization_header() -&gt; Optional[str]\n</code></pre> <p>Get the Authorization header.</p>"},{"location":"api/models/#restmachine.Request.get_if_match","title":"get_if_match","text":"<pre><code>get_if_match() -&gt; Optional[List[str]]\n</code></pre> <p>Get the If-Match header values as a list of ETags.</p>"},{"location":"api/models/#restmachine.Request.get_if_none_match","title":"get_if_none_match","text":"<pre><code>get_if_none_match() -&gt; Optional[List[str]]\n</code></pre> <p>Get the If-None-Match header values as a list of ETags.</p>"},{"location":"api/models/#restmachine.Request.get_if_modified_since","title":"get_if_modified_since","text":"<pre><code>get_if_modified_since() -&gt; Optional[datetime]\n</code></pre> <p>Get the If-Modified-Since header as a datetime object.</p>"},{"location":"api/models/#restmachine.Request.get_if_unmodified_since","title":"get_if_unmodified_since","text":"<pre><code>get_if_unmodified_since() -&gt; Optional[datetime]\n</code></pre> <p>Get the If-Unmodified-Since header as a datetime object.</p>"},{"location":"api/models/#response","title":"Response","text":""},{"location":"api/models/#restmachine.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response(\n    status_code: int,\n    body: Optional[Union[str, bytes, BinaryIO, Path, dict, list]] = None,\n    headers: Optional[Union[Dict[str, str], MultiValueHeaders]] = None,\n    content_type: Optional[str] = None,\n    request: Optional[Request] = None,\n    available_content_types: Optional[list] = None,\n    pre_calculated_headers: Optional[\n        Union[Dict[str, str], MultiValueHeaders]\n    ] = None,\n    etag: Optional[str] = None,\n    last_modified: Optional[datetime] = None,\n    range_start: Optional[int] = None,\n    range_end: Optional[int] = None,\n)\n</code></pre> <p>Represents an HTTP response.</p> <p>The body can be: - str: Will be encoded to UTF-8 bytes - bytes: Used directly - BinaryIO: File-like object that will be streamed (useful for large files, S3 objects, etc.) - Path: Local filesystem path to a file (will be served efficiently) - dict/list: Will be JSON-encoded - None: Empty response body</p> <p>For Path objects: - ASGI servers will use the path send extension for efficient file serving - Lambda will read the file and send as body - Content-Type is automatically detected from file extension - Content-Length is automatically set from file size</p> <p>Range Request Support: - range_start/range_end: Set by framework when processing Range header - Adapters use these fields to send only requested byte range - ASGI adapter uses zero-copy extension when possible</p>"},{"location":"api/models/#restmachine.Response-functions","title":"Functions","text":""},{"location":"api/models/#restmachine.Response.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Initialize Response object after dataclass creation.</p>"},{"location":"api/models/#restmachine.Response.set_etag","title":"set_etag","text":"<pre><code>set_etag(etag: str, weak: bool = False)\n</code></pre> <p>Set the ETag header.</p> <p>Parameters:</p> Name Type Description Default <code>etag</code> <code>str</code> <p>The ETag value (without quotes)</p> required <code>weak</code> <code>bool</code> <p>Whether this is a weak ETag (prefixed with W/)</p> <code>False</code>"},{"location":"api/models/#restmachine.Response.set_last_modified","title":"set_last_modified","text":"<pre><code>set_last_modified(last_modified: datetime)\n</code></pre> <p>Set the Last-Modified header.</p> <p>Parameters:</p> Name Type Description Default <code>last_modified</code> <code>datetime</code> <p>The last modified datetime</p> required"},{"location":"api/models/#restmachine.Response.is_range_response","title":"is_range_response","text":"<pre><code>is_range_response() -&gt; bool\n</code></pre> <p>Check if this is a partial content (range) response.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if range_start and range_end are set, indicating this is a 206 Partial Content response</p>"},{"location":"api/models/#restmachine.Response.generate_etag_from_content","title":"generate_etag_from_content","text":"<pre><code>generate_etag_from_content(weak: bool = False)\n</code></pre> <p>Generate and set ETag based on response body content.</p> <p>Parameters:</p> Name Type Description Default <code>weak</code> <code>bool</code> <p>Whether to generate a weak ETag</p> <code>False</code> Note <p>For streaming bodies (BinaryIO), this will read the entire stream to calculate the hash. The stream will be reset to the beginning after hashing.</p>"},{"location":"api/models/#httpmethod","title":"HTTPMethod","text":""},{"location":"api/models/#restmachine.HTTPMethod","title":"HTTPMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported HTTP methods.</p>"},{"location":"api/models/#overview","title":"Overview","text":"<p>These are the core models for handling HTTP requests and responses in RestMachine.</p>"},{"location":"api/models/#request-model","title":"Request Model","text":"<p>The <code>Request</code> object encapsulates an incoming HTTP request with:</p> <ul> <li>method - HTTP method (GET, POST, PUT, DELETE, etc.)</li> <li>path - Request path</li> <li>headers - HTTP headers (case-insensitive)</li> <li>query_params - Query string parameters</li> <li>path_params - Path parameters from route matching</li> <li>body - Request body (string or bytes)</li> </ul>"},{"location":"api/models/#response-model","title":"Response Model","text":"<p>The <code>Response</code> object represents an HTTP response with:</p> <ul> <li>status_code - HTTP status code (200, 404, 500, etc.)</li> <li>body - Response body (string)</li> <li>headers - HTTP response headers</li> </ul>"},{"location":"api/models/#httpmethod-enum","title":"HTTPMethod Enum","text":"<p>Enum of supported HTTP methods: - GET - POST - PUT - DELETE - PATCH - HEAD - OPTIONS</p>"},{"location":"api/models/#request-usage","title":"Request Usage","text":""},{"location":"api/models/#accessing-request-data","title":"Accessing Request Data","text":"<pre><code>@app.get('/users/{user_id}')\ndef get_user(request: Request):\n    # Path parameters\n    user_id = request.path_params['user_id']\n\n    # Query parameters\n    page = request.query_params.get('page', '1')\n\n    # Headers\n    auth = request.headers.get('authorization')\n\n    # Body (for POST/PUT)\n    # body = request.body\n\n    return {\"user_id\": user_id, \"page\": page}\n</code></pre>"},{"location":"api/models/#creating-requests-manually","title":"Creating Requests Manually","text":"<p>Useful for testing:</p> <pre><code>from restmachine import Request, HTTPMethod\n\nrequest = Request(\n    method=HTTPMethod.GET,\n    path=\"/users/123\",\n    headers={\"authorization\": \"Bearer token\"},\n    query_params={\"page\": \"1\"},\n    path_params={\"user_id\": \"123\"},\n    body=\"\"\n)\n\nresponse = app.execute(request)\n</code></pre>"},{"location":"api/models/#response-usage","title":"Response Usage","text":""},{"location":"api/models/#returning-responses","title":"Returning Responses","text":"<p>Handlers can return responses in multiple ways:</p> <p>1. Dictionary (auto-converted to JSON):</p> <pre><code>@app.get('/users')\ndef list_users():\n    return {\"users\": [...]}  # 200 OK with JSON\n</code></pre> <p>2. Tuple (body, status_code):</p> <pre><code>@app.post('/users')\ndef create_user(request):\n    return {\"created\": True}, 201  # 201 Created\n</code></pre> <p>3. Tuple (body, status_code, headers):</p> <pre><code>@app.get('/file')\ndef download_file():\n    return \"file contents\", 200, {\n        \"Content-Type\": \"text/plain\",\n        \"Content-Disposition\": \"attachment; filename=file.txt\"\n    }\n</code></pre> <p>4. Explicit Response object:</p> <pre><code>from restmachine import Response\n\n@app.get('/custom')\ndef custom_response():\n    return Response(\n        status_code=200,\n        body='{\"custom\": true}',\n        headers={\"X-Custom-Header\": \"value\"}\n    )\n</code></pre>"},{"location":"api/models/#response-status-codes","title":"Response Status Codes","text":"<p>Use <code>http.HTTPStatus</code> for readable status codes:</p> <pre><code>from http import HTTPStatus\n\n@app.post('/users')\ndef create_user(request):\n    return {\"created\": True}, HTTPStatus.CREATED\n\n@app.get('/users/{user_id}')\ndef get_user(request):\n    user_id = request.path_params['user_id']\n    user = db.get(user_id)\n\n    if not user:\n        return {\"error\": \"Not found\"}, HTTPStatus.NOT_FOUND\n\n    return user, HTTPStatus.OK\n</code></pre> <p>Common status codes: - <code>200 OK</code> - Successful GET/PUT/PATCH - <code>201 Created</code> - Successful POST - <code>204 No Content</code> - Successful DELETE - <code>400 Bad Request</code> - Invalid request - <code>401 Unauthorized</code> - Authentication required - <code>403 Forbidden</code> - Insufficient permissions - <code>404 Not Found</code> - Resource not found - <code>500 Internal Server Error</code> - Server error</p>"},{"location":"api/models/#httpmethod-usage","title":"HTTPMethod Usage","text":"<p>The <code>HTTPMethod</code> enum provides type-safe HTTP method constants:</p> <pre><code>from restmachine import HTTPMethod\n\n# Used internally for route matching\n@app.route(HTTPMethod.POST, '/users')\ndef create_user(request):\n    return {\"created\": True}\n\n# Or use string (converted automatically)\n@app.route('PATCH', '/users/{user_id}')\ndef patch_user(request):\n    return {\"patched\": True}\n</code></pre>"},{"location":"api/models/#headers","title":"Headers","text":""},{"location":"api/models/#request-headers","title":"Request Headers","text":"<p>Headers are case-insensitive:</p> <pre><code>@app.get('/data')\ndef get_data(request: Request):\n    # All of these work:\n    auth = request.headers.get('Authorization')\n    auth = request.headers.get('authorization')\n    auth = request.headers.get('AUTHORIZATION')\n\n    content_type = request.headers.get('content-type')\n\n    return {\"auth\": auth, \"type\": content_type}\n</code></pre>"},{"location":"api/models/#response-headers","title":"Response Headers","text":"<p>Set response headers in tuple return or Response object:</p> <pre><code># Via tuple\n@app.get('/data')\ndef get_data():\n    return {\"data\": ...}, 200, {\n        \"Cache-Control\": \"max-age=3600\",\n        \"X-API-Version\": \"1.0\"\n    }\n\n# Via Response\nfrom restmachine import Response\n\n@app.get('/data')\ndef get_data():\n    return Response(\n        status_code=200,\n        body='{\"data\": \"value\"}',\n        headers={\n            \"Cache-Control\": \"max-age=3600\",\n            \"X-API-Version\": \"1.0\"\n        }\n    )\n</code></pre>"},{"location":"api/models/#query-parameters","title":"Query Parameters","text":"<p>Access query parameters from the request:</p> <pre><code>@app.get('/search')\ndef search(request: Request):\n    # GET /search?q=python&amp;page=2\n    query = request.query_params.get('q')\n    page = int(request.query_params.get('page', '1'))\n\n    results = search_db(query, page=page)\n    return {\"results\": results, \"page\": page}\n</code></pre>"},{"location":"api/models/#request-body","title":"Request Body","text":"<p>Access and parse request bodies:</p> <pre><code>@app.post('/users')\ndef create_user(request: Request):\n    import json\n\n    # Parse JSON body\n    data = json.loads(request.body)\n    name = data['name']\n    email = data['email']\n\n    user = db.create_user(name=name, email=email)\n    return {\"created\": user}, 201\n</code></pre> <p>For automatic validation, use <code>@app.validates</code>:</p> <pre><code>from pydantic import BaseModel\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\n@app.validates\ndef validate_user(request: Request) -&gt; UserCreate:\n    import json\n    return UserCreate.model_validate(json.loads(request.body))\n\n@app.post('/users')\ndef create_user(validate_user: UserCreate):\n    # validate_user is already parsed and validated\n    return {\"created\": validate_user.model_dump()}, 201\n</code></pre>"},{"location":"api/models/#see-also","title":"See Also","text":"<ul> <li>Application API - Main application class</li> <li>Basic Application Guide - Core concepts</li> <li>Validation Guide - Request validation</li> <li>Testing Guide - Testing with Request/Response</li> </ul>"},{"location":"api/router/","title":"Router","text":""},{"location":"api/router/#restmachine.Router","title":"Router","text":"<pre><code>Router(app: Optional[Any] = None)\n</code></pre> <p>Router class for organizing routes with mounting support.</p> <p>Routers allow you to organize routes by functionality and mount them with different prefixes. Routers can also be nested (mounted into other routers).</p> <p>Initialize a router.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Optional[Any]</code> <p>Optional RestApplication instance for dependency/callback registration</p> <code>None</code>"},{"location":"api/router/#restmachine.Router-functions","title":"Functions","text":""},{"location":"api/router/#restmachine.Router.get","title":"get","text":"<pre><code>get(path: str)\n</code></pre> <p>Decorator to register a GET route handler.</p>"},{"location":"api/router/#restmachine.Router.post","title":"post","text":"<pre><code>post(path: str)\n</code></pre> <p>Decorator to register a POST route handler.</p>"},{"location":"api/router/#restmachine.Router.put","title":"put","text":"<pre><code>put(path: str)\n</code></pre> <p>Decorator to register a PUT route handler.</p>"},{"location":"api/router/#restmachine.Router.patch","title":"patch","text":"<pre><code>patch(path: str)\n</code></pre> <p>Decorator to register a PATCH route handler.</p>"},{"location":"api/router/#restmachine.Router.delete","title":"delete","text":"<pre><code>delete(path: str)\n</code></pre> <p>Decorator to register a DELETE route handler.</p>"},{"location":"api/router/#restmachine.Router.options","title":"options","text":"<pre><code>options(path: str)\n</code></pre> <p>Decorator to register an OPTIONS route handler.</p>"},{"location":"api/router/#overview","title":"Overview","text":"<p><code>Router</code> allows you to organize routes into reusable, composable units. Routers can be mounted onto applications or other routers, enabling modular API design.</p>"},{"location":"api/router/#why-use-routers","title":"Why Use Routers?","text":"<ul> <li>Modularity - Organize routes by feature or domain</li> <li>Reusability - Share routers across applications</li> <li>Composition - Build complex APIs from simple components</li> <li>Separation of Concerns - Keep related routes together</li> </ul>"},{"location":"api/router/#basic-usage","title":"Basic Usage","text":"<pre><code>from restmachine import RestApplication, Router\n\napp = RestApplication()\nusers_router = Router()\n\n@users_router.get('/users')\ndef list_users():\n    return {\"users\": [...]}\n\n@users_router.get('/users/{user_id}')\ndef get_user(request):\n    user_id = request.path_params['user_id']\n    return {\"id\": user_id}\n\n@users_router.post('/users')\ndef create_user(request):\n    return {\"created\": True}, 201\n\n# Mount router at /api/v1\napp.mount('/api/v1', users_router)\n\n# Routes become:\n# GET  /api/v1/users\n# GET  /api/v1/users/{user_id}\n# POST /api/v1/users\n</code></pre>"},{"location":"api/router/#route-registration","title":"Route Registration","text":"<p>Routers support the same HTTP method decorators as <code>RestApplication</code>:</p> <pre><code>router = Router()\n\n@router.get('/items')\ndef list_items():\n    return {\"items\": []}\n\n@router.post('/items')\ndef create_item(request):\n    return {\"created\": True}\n\n@router.put('/items/{item_id}')\ndef update_item(request):\n    return {\"updated\": True}\n\n@router.delete('/items/{item_id}')\ndef delete_item(request):\n    return {\"deleted\": True}\n\n@router.patch('/items/{item_id}')\ndef patch_item(request):\n    return {\"patched\": True}\n\n@router.head('/items')\ndef head_items():\n    return None  # HEAD returns only headers\n\n@router.options('/items')\ndef options_items():\n    return {\"methods\": [\"GET\", \"POST\"]}\n</code></pre>"},{"location":"api/router/#nested-routers","title":"Nested Routers","text":"<p>Mount routers onto other routers:</p> <pre><code>from restmachine import Router\n\n# API v1 router\napi_v1 = Router()\n\n# Users sub-router\nusers = Router()\n@users.get('/users')\ndef list_users():\n    return {\"users\": []}\n\n# Posts sub-router\nposts = Router()\n@posts.get('/posts')\ndef list_posts():\n    return {\"posts\": []}\n\n# Mount sub-routers\napi_v1.mount('/api/v1', users)\napi_v1.mount('/api/v1', posts)\n\n# Mount to application\napp.mount('/', api_v1)\n\n# Routes become:\n# GET /api/v1/users\n# GET /api/v1/posts\n</code></pre>"},{"location":"api/router/#modular-api-design","title":"Modular API Design","text":"<p>Organize by feature:</p> <pre><code># users.py\nfrom restmachine import Router\n\nusers_router = Router()\n\n@users_router.get('/users')\ndef list_users():\n    return {\"users\": []}\n\n@users_router.post('/users')\ndef create_user(request):\n    return {\"created\": True}\n</code></pre> <pre><code># posts.py\nfrom restmachine import Router\n\nposts_router = Router()\n\n@posts_router.get('/posts')\ndef list_posts():\n    return {\"posts\": []}\n\n@posts_router.post('/posts')\ndef create_post(request):\n    return {\"created\": True}\n</code></pre> <pre><code># app.py\nfrom restmachine import RestApplication\nfrom users import users_router\nfrom posts import posts_router\n\napp = RestApplication()\n\napp.mount('/api', users_router)\napp.mount('/api', posts_router)\n\n# Routes:\n# GET  /api/users\n# POST /api/users\n# GET  /api/posts\n# POST /api/posts\n</code></pre>"},{"location":"api/router/#versioned-apis","title":"Versioned APIs","text":"<p>Create multiple API versions:</p> <pre><code>from restmachine import Router\n\n# API v1\napi_v1 = Router()\n\n@api_v1.get('/users')\ndef list_users_v1():\n    return {\"users\": [], \"version\": \"1.0\"}\n\n# API v2\napi_v2 = Router()\n\n@api_v2.get('/users')\ndef list_users_v2():\n    return {\"users\": [], \"version\": \"2.0\", \"new_field\": \"value\"}\n\n# Mount both versions\napp.mount('/api/v1', api_v1)\napp.mount('/api/v2', api_v2)\n\n# Routes:\n# GET /api/v1/users -&gt; v1 response\n# GET /api/v2/users -&gt; v2 response\n</code></pre>"},{"location":"api/router/#path-parameters","title":"Path Parameters","text":"<p>Path parameters work the same as in applications:</p> <pre><code>router = Router()\n\n@router.get('/users/{user_id}')\ndef get_user(request):\n    user_id = request.path_params['user_id']\n    return {\"id\": user_id}\n\n@router.get('/users/{user_id}/posts/{post_id}')\ndef get_post(request):\n    user_id = request.path_params['user_id']\n    post_id = request.path_params['post_id']\n    return {\"user_id\": user_id, \"post_id\": post_id}\n</code></pre>"},{"location":"api/router/#dependency-injection","title":"Dependency Injection","text":"<p>Routers don't have their own dependency registry - dependencies are resolved from the parent application:</p> <pre><code>from restmachine import RestApplication, Router\n\napp = RestApplication()\n\n@app.dependency()\ndef database():\n    return create_db_connection()\n\nrouter = Router()\n\n@router.get('/users')\ndef list_users(database):\n    # database is injected from app\n    return {\"users\": database.query(\"SELECT * FROM users\")}\n\napp.mount('/api', router)\n</code></pre>"},{"location":"api/router/#static-file-routers","title":"Static File Routers","text":"<p>Use specialized routers for static files:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine_web import StaticRouter\n\napp = RestApplication()\n\n# Static files router\nstatic = StaticRouter(serve=\"./public\")\napp.mount('/static', static)\n\n# GET /static/css/style.css -&gt; serves ./public/css/style.css\n</code></pre> <p>See StaticRouter API for details.</p>"},{"location":"api/router/#comparison-router-vs-application","title":"Comparison: Router vs Application","text":"Feature Router RestApplication Route registration \u2705 Yes \u2705 Yes Dependency injection \u274c No (uses parent) \u2705 Yes Content negotiation \u274c No (uses parent) \u2705 Yes Lifecycle handlers \u274c No \u2705 Yes Error handlers \u274c No \u2705 Yes Mounting \u2705 Yes \u2705 Yes Execution \u274c No \u2705 Yes <p>Use Router when: - Organizing routes by feature - Building reusable route collections - Creating modular APIs</p> <p>Use RestApplication when: - Creating the main application - Need dependency injection - Need lifecycle handlers - Need custom error handling</p>"},{"location":"api/router/#see-also","title":"See Also","text":"<ul> <li>Application API - Main application class</li> <li>Basic Application Guide - Core concepts</li> <li>StaticRouter - Serve static files</li> </ul>"},{"location":"api/state-machine/","title":"State Machine","text":""},{"location":"api/state-machine/#overview","title":"Overview","text":"<p>RestMachine uses a webmachine-inspired state machine to process HTTP requests. The state machine handles content negotiation, authentication, authorization, and conditional requests automatically.</p>"},{"location":"api/state-machine/#state-machine-callbacks","title":"State Machine Callbacks","text":"<p>Customize request processing by providing state machine callbacks:</p> <pre><code>@app.get('/protected')\ndef protected_resource(request):\n    return {\"data\": \"secret\"}\n\n# Add authentication callback\n@app.state_machine_callback('is_authorized')\ndef check_auth(request):\n    \"\"\"Check if request is authorized.\"\"\"\n    auth_header = request.headers.get('authorization')\n    if not auth_header or not auth_header.startswith('Bearer '):\n        return False\n    # Validate token...\n    return True\n</code></pre>"},{"location":"api/state-machine/#available-callbacks","title":"Available Callbacks","text":"<p>The state machine supports various callback points:</p> <ul> <li><code>is_authorized</code> - Check authorization</li> <li><code>forbidden</code> - Handle forbidden requests</li> <li><code>malformed_request</code> - Validate request format</li> <li><code>allowed_methods</code> - Specify allowed HTTP methods</li> <li><code>content_types_provided</code> - Available response formats</li> <li><code>content_types_accepted</code> - Accepted request formats</li> </ul>"},{"location":"api/state-machine/#see-also","title":"See Also","text":"<ul> <li>State Machine Guide - Complete guide with diagrams</li> <li>Application API - Register callbacks</li> <li>Authentication Guide - Auth patterns</li> </ul>"},{"location":"api/testing/","title":"Testing","text":""},{"location":"api/testing/#overview","title":"Overview","text":"<p>RestMachine provides testing utilities for writing tests against your REST APIs.</p>"},{"location":"api/testing/#testing-drivers","title":"Testing Drivers","text":"<p>Test your application with different drivers:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine.testing import DirectDriver\n\napp = RestApplication()\n\n@app.get('/hello')\ndef hello():\n    return {\"message\": \"Hello\"}\n\n# Test with DirectDriver\ndriver = DirectDriver(app)\nresponse = driver.get('/hello')\n\nassert response.status_code == 200\nassert response.json() == {\"message\": \"Hello\"}\n</code></pre>"},{"location":"api/testing/#http-testing-dsl","title":"HTTP Testing DSL","text":"<p>Use the testing DSL for more readable tests:</p> <pre><code>from restmachine.testing import test_http\n\ndef test_my_api():\n    with test_http(app) as client:\n        response = client.get('/users')\n        assert response.status_code == 200\n        assert 'users' in response.json()\n</code></pre>"},{"location":"api/testing/#testing-with-dependencies","title":"Testing with Dependencies","text":"<p>Mock dependencies in tests:</p> <pre><code>@app.dependency()\ndef database():\n    return create_db_connection()\n\n# In tests\ndef test_with_mock_db():\n    mock_db = MockDatabase()\n\n    # Override dependency\n    app.dependency_cache['database'] = mock_db\n\n    response = DirectDriver(app).get('/users')\n    assert response.status_code == 200\n</code></pre>"},{"location":"api/testing/#see-also","title":"See Also","text":"<ul> <li>Testing Guide - Complete testing guide</li> <li>Application API - Application class</li> <li>Request &amp; Response - Request/response models</li> </ul>"},{"location":"development/code-quality/","title":"Code Quality","text":"<p>This page is under construction.</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>This page is under construction.</p>"},{"location":"development/releases/","title":"Releases","text":"<p>This page is under construction.</p>"},{"location":"development/security/","title":"Security Guidelines","text":"<p>This project includes comprehensive security scanning tools to help identify vulnerabilities and follow security best practices.</p>"},{"location":"development/security/#security-scanning-tools","title":"Security Scanning Tools","text":""},{"location":"development/security/#1-static-application-security-testing-sast","title":"1. Static Application Security Testing (SAST)","text":""},{"location":"development/security/#bandit-python-security-linter","title":"Bandit - Python Security Linter","text":"<ul> <li>Purpose: Finds common security issues in Python code</li> <li>Run: <code>tox -e bandit</code></li> <li>Config: <code>pyproject.toml</code> under <code>[tool.bandit]</code></li> <li>Reports: Console output + <code>bandit-report.sarif</code> (SARIF format for GitHub Security tab)</li> </ul>"},{"location":"development/security/#codeql-advanced-security-analysis","title":"CodeQL - Advanced Security Analysis","text":"<ul> <li>Purpose: Deep semantic code analysis for security vulnerabilities and code quality</li> <li>Run: Automatic via GitHub Actions (<code>.github/workflows/codeql.yml</code>)</li> <li>Query Suite: <code>security-and-quality</code> (comprehensive analysis)</li> <li>Reports: GitHub Security tab (SARIF format)</li> <li>Triggers: Push to main/develop, PRs, weekly schedule (Monday 10am UTC)</li> </ul>"},{"location":"development/security/#semgrep-advanced-sast-optional","title":"Semgrep - Advanced SAST (Optional)","text":"<ul> <li>Purpose: Advanced pattern-based security scanning</li> <li>Run: <code>tox -e semgrep</code></li> <li>Reports: Console output + <code>semgrep-report.json</code></li> </ul>"},{"location":"development/security/#2-dependency-vulnerability-scanning","title":"2. Dependency Vulnerability Scanning","text":""},{"location":"development/security/#pip-audit-dependency-security-scanner","title":"pip-audit - Dependency Security Scanner","text":"<ul> <li>Purpose: Checks dependencies for known vulnerabilities</li> <li>Run: <code>tox -e pip-audit</code></li> <li>Reports: Console output + <code>pip-audit-report.md</code> (Markdown format)</li> <li>Database: Uses PyPI vulnerability database</li> </ul>"},{"location":"development/security/#dependabot-automated-dependency-updates","title":"Dependabot - Automated Dependency Updates","text":"<ul> <li>Purpose: Automatically detects and creates PRs for dependency updates</li> <li>Config: <code>.github/dependabot.yml</code></li> <li>Schedule: Weekly (Monday 9am UTC)</li> <li>Coverage: Python dependencies and GitHub Actions</li> <li>Features: Groups minor/patch updates, auto-labels PRs</li> </ul>"},{"location":"development/security/#3-secret-detection","title":"3. Secret Detection","text":""},{"location":"development/security/#detect-secrets-secret-scanner","title":"Detect-Secrets - Secret Scanner","text":"<ul> <li>Purpose: Scans for hardcoded secrets, API keys, tokens</li> <li>Run: <code>tox -e secrets</code></li> <li>Config: <code>pyproject.toml</code> under <code>[tool.detect-secrets]</code></li> <li>Baseline: <code>.secrets.baseline</code> (tracks known false positives)</li> </ul>"},{"location":"development/security/#running-security-scans","title":"Running Security Scans","text":""},{"location":"development/security/#run-all-security-scans","title":"Run All Security Scans","text":"<pre><code>tox -e security\n</code></pre>"},{"location":"development/security/#run-individual-scans","title":"Run Individual Scans","text":"<pre><code># SAST scanning\ntox -e bandit           # Local static analysis\n# CodeQL runs via GitHub Actions automatically\n\n# Dependency vulnerabilities\ntox -e pip-audit        # Manual dependency scan\n# Dependabot runs automatically weekly\n\n# Secret detection\ntox -e secrets\n\n# Advanced SAST (optional)\ntox -e semgrep\n</code></pre>"},{"location":"development/security/#current-security-issues","title":"Current Security Issues","text":""},{"location":"development/security/#high-severity","title":"High Severity","text":"<p>\u2705 Resolved: All high-severity issues have been fixed.</p>"},{"location":"development/security/#low-severity","title":"Low Severity","text":"<p>6 instances of Try/Except/Pass patterns in <code>restmachine/state_machine.py</code>    - Issue: Silent exception handling can mask errors    - Recommendation: Add logging or more specific exception handling</p>"},{"location":"development/security/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Regular Scanning: Run security scans before each release</li> <li>Dependency Updates: Keep dependencies updated to latest secure versions</li> <li>Code Review: Review security scan results during code review process</li> <li>CI Integration: Add security scans to your CI/CD pipeline</li> </ol>"},{"location":"development/security/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"development/security/#github-actions","title":"GitHub Actions","text":"<p>This project includes automated security scanning as part of the CI workflow. The security job: - Runs on every push to <code>main</code> and <code>develop</code> branches - Runs on all pull requests to <code>main</code> - Runs weekly on Monday at 9am UTC (scheduled scan) - Uploads Bandit results to GitHub Security tab (SARIF format) - Uploads pip-audit markdown reports as artifacts</p> <p>View security findings: Navigate to the Security tab in GitHub: - Code scanning \u2192 View Bandit and CodeQL findings - Dependabot alerts \u2192 View dependency vulnerabilities - Code scanning alerts \u2192 Filtered views by severity/tool</p> <p>The security scans run in parallel with unit tests, linting, and type checking as part of the CI pipeline.</p> <p>Manual workflow example:</p> <pre><code>security:\n  runs-on: ubuntu-latest\n  permissions:\n    security-events: write\n    contents: read\n\n  steps:\n  - uses: actions/checkout@v4\n\n  - name: Set up Python\n    uses: actions/setup-python@v4\n    with:\n      python-version: \"3.11\"\n\n  - name: Run security scans\n    run: |\n      pip install tox\n      tox -e security\n\n  - name: Upload Bandit SARIF to Security tab\n    uses: github/codeql-action/upload-sarif@v3\n    if: always()\n    with:\n      sarif_file: bandit-report.sarif\n      category: bandit\n\n  - name: Upload pip-audit report\n    uses: actions/upload-artifact@v4\n    if: always()\n    with:\n      name: pip-audit-report\n      path: pip-audit-report.md\n</code></pre>"},{"location":"development/security/#suppressing-false-positives","title":"Suppressing False Positives","text":""},{"location":"development/security/#bandit","title":"Bandit","text":"<p>Add <code># nosec</code> comment to suppress specific warnings: <pre><code>import hashlib\npassword_hash = hashlib.md5(password.encode()).hexdigest()  # nosec B324\n</code></pre></p>"},{"location":"development/security/#detect-secrets","title":"Detect-Secrets","text":"<p>Add false positives to <code>.secrets.baseline</code>: <pre><code>detect-secrets scan --baseline .secrets.baseline --update\n</code></pre></p>"},{"location":"development/security/#security-contact","title":"Security Contact","text":"<p>For security vulnerabilities, please follow responsible disclosure: 1. Do not open public issues for security vulnerabilities 2. Email security concerns to: [your-security-email] 3. Include detailed reproduction steps and impact assessment</p>"},{"location":"development/security/#compliance","title":"Compliance","text":"<p>This security setup helps maintain compliance with: - OWASP Top 10 security risks - Common security vulnerabilities (CWE) - Python security best practices - Open source security standards</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"getting-started/installation/#basic-installation","title":"Basic Installation","text":"<p>Install RestMachine using pip:</p> <pre><code>pip install restmachine\n</code></pre> <p>This installs the core framework with zero required dependencies.</p>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#validation-support","title":"Validation Support","text":"<p>For Pydantic-based request/response validation:</p> <pre><code>pip install restmachine[validation]\n</code></pre> <p>This adds: - <code>pydantic&gt;=2.0.0</code> - For data validation and serialization</p>"},{"location":"getting-started/installation/#aws-lambda-support","title":"AWS Lambda Support","text":"<p>For deploying to AWS Lambda:</p> <pre><code>pip install restmachine-aws\n</code></pre> <p>This includes the AWS Lambda adapter with support for: - API Gateway REST API (v1) - API Gateway HTTP API (v2) - Application Load Balancer (ALB) - Lambda Function URLs</p>"},{"location":"getting-started/installation/#asgi-server-development","title":"ASGI Server (Development)","text":"<p>For running locally with an ASGI server:</p> UvicornHypercornDaphne <pre><code>pip install uvicorn[standard]\n</code></pre> <pre><code>pip install hypercorn\n</code></pre> <pre><code>pip install daphne\n</code></pre>"},{"location":"getting-started/installation/#complete-installation","title":"Complete Installation","text":"<p>For all features:</p> <pre><code>pip install restmachine[validation] restmachine-aws uvicorn[standard]\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>To contribute to RestMachine:</p> <ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/rfestag/restmachine-python.git\ncd restmachine-python\n</code></pre></p> </li> <li> <p>Install in editable mode with dev dependencies: <pre><code>pip install -e packages/restmachine[dev]\npip install -e packages/restmachine-aws[dev]\n</code></pre></p> </li> <li> <p>Run tests: <pre><code>tox\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Verify your installation:</p> <pre><code>import restmachine\nprint(restmachine.__version__)\n</code></pre> <p>Or create a simple application:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.get('/health')\ndef health_check():\n    return {\"status\": \"healthy\"}\n\n# Test it\nfrom restmachine import Request, HTTPMethod\n\nrequest = Request(method=HTTPMethod.GET, path='/health')\nresponse = app.execute(request)\nprint(response.body)  # {\"status\": \"healthy\"}\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start \u2192 - Build your first API</li> <li>Basic Application \u2192 - Learn the fundamentals</li> </ul>"},{"location":"getting-started/overview/","title":"Overview","text":"<p>RestMachine is a Python REST framework designed to make building APIs simple while providing powerful features when you need them.</p>"},{"location":"getting-started/overview/#philosophy","title":"Philosophy","text":"<p>RestMachine is designed to get out of your way:</p> <ol> <li>Simple by default - Start with minimal code, add features as needed</li> <li>Explicit over implicit - Clear, readable code over hidden behavior</li> <li>Easy testing - Share resources cleanly without global state</li> <li>HTTP done right - Automatic content negotiation, proper status codes, standards-compliant behavior</li> <li>Deploy anywhere - Same code runs locally or in AWS Lambda</li> </ol>"},{"location":"getting-started/overview/#architecture","title":"Architecture","text":""},{"location":"getting-started/overview/#smart-request-processing","title":"Smart Request Processing","text":"<p>RestMachine handles HTTP requests intelligently, exposing useful information about what's happening:</p> <ul> <li>Automatic content negotiation - Serves JSON, XML, or custom formats based on client preferences</li> <li>Conditional requests - Built-in support for ETags, If-Modified-Since, and other cache headers</li> <li>Correct status codes - Returns 404, 405, 406, etc. automatically based on request context</li> <li>Inspectable facts - Access details like accepted content types, authentication status, and request validity at any point in your handler</li> </ul> graph TD     A[Incoming Request] --&gt; B{Route Matched?}     B --&gt;|No| C[404 Not Found]     B --&gt;|Yes| D{Method Allowed?}     D --&gt;|No| E[405 Method Not Allowed]     D --&gt;|Yes| F{Content Negotiation}     F --&gt;|Success| G[Execute Handler]     F --&gt;|Fail| H[406 Not Acceptable]     G --&gt; I{Validation}     I --&gt;|Success| J[Render Response]     I --&gt;|Fail| K[400 Bad Request]     J --&gt; L[Send Response]"},{"location":"getting-started/overview/#sharing-resources","title":"Sharing Resources","text":"<p>Share resources like database connections across handlers without global variables:</p> <pre><code>@app.dependency()\ndef database():\n    return create_db_connection()\n\n@app.get('/users')\ndef list_users(database):  # 'database' automatically provided\n    return database.query(\"SELECT * FROM users\")\n</code></pre> <p>Resources are created once per request and cached automatically, so expensive operations (like opening database connections) only happen when needed.</p>"},{"location":"getting-started/overview/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/overview/#application","title":"Application","text":"<p>The <code>RestApplication</code> is the main entry point:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n</code></pre>"},{"location":"getting-started/overview/#routes","title":"Routes","text":"<p>Routes are defined using decorators:</p> <pre><code>@app.get('/users/{user_id}')\ndef get_user(path_params):\n    user_id = path_params['user_id']\n    return {\"id\": user_id}\n</code></pre> <p>Supported HTTP methods: - <code>@app.get(path)</code> - <code>@app.post(path)</code> - <code>@app.put(path)</code> - <code>@app.patch(path)</code> - <code>@app.delete(path)</code> - <code>@app.head(path)</code> - <code>@app.options(path)</code></p>"},{"location":"getting-started/overview/#request-response","title":"Request &amp; Response","text":"<ul> <li>Request - Contains method, path, headers, body, query params, path params</li> <li>Response - Can be dict (auto-serialized), string, or explicit Response object</li> </ul> <pre><code>from restmachine import Response\n\n@app.get('/custom')\ndef custom_response():\n    return Response(\n        status_code=201,\n        body=\"Created\",\n        headers={\"X-Custom\": \"Header\"}\n    )\n</code></pre>"},{"location":"getting-started/overview/#content-negotiation","title":"Content Negotiation","text":"<p>RestMachine automatically negotiates content types based on the <code>Accept</code> header:</p> <pre><code>@app.content_renderer(\"application/json\")\ndef render_json(data):\n    import json\n    return json.dumps(data)\n\n@app.content_renderer(\"application/xml\")\ndef render_xml(data):\n    return f\"&lt;data&gt;{data}&lt;/data&gt;\"\n</code></pre> <p>Requests with <code>Accept: application/json</code> will use the JSON renderer, while <code>Accept: application/xml</code> will use the XML renderer.</p>"},{"location":"getting-started/overview/#deployment-options","title":"Deployment Options","text":"<p>RestMachine supports multiple deployment targets:</p> Deployment Use Case Adapter ASGI Servers Production web servers <code>ASGIAdapter</code> AWS Lambda Serverless, auto-scaling <code>AwsApiGatewayAdapter</code> Direct Testing, development <code>app.execute(request)</code>"},{"location":"getting-started/overview/#asgi-deployment","title":"ASGI Deployment","text":"<pre><code>from restmachine import ASGIAdapter\n\nasgi_app = ASGIAdapter(app)\n</code></pre> <p>Run with any ASGI server:</p> <pre><code>uvicorn app:asgi_app --reload           # Uvicorn\nhypercorn app:asgi_app --reload         # Hypercorn\ndaphne app:asgi_app                     # Daphne\n</code></pre>"},{"location":"getting-started/overview/#aws-lambda-deployment","title":"AWS Lambda Deployment","text":"<pre><code>from restmachine_aws import AwsApiGatewayAdapter\n\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre> <p>Supports: - API Gateway REST API (v1) - API Gateway HTTP API (v2) - Application Load Balancer (ALB) - Lambda Function URLs</p>"},{"location":"getting-started/overview/#whats-next","title":"What's Next?","text":"<ul> <li>Installation \u2192 - Install RestMachine</li> <li>Quick Start \u2192 - Build your first API</li> <li>Basic Application \u2192 - Learn the fundamentals</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will walk you through creating your first RestMachine application and deploying it with various servers.</p>"},{"location":"getting-started/quickstart/#create-your-first-api","title":"Create Your First API","text":""},{"location":"getting-started/quickstart/#1-install-restmachine","title":"1. Install RestMachine","text":"<pre><code>pip install restmachine uvicorn[standard]\n</code></pre>"},{"location":"getting-started/quickstart/#2-create-apppy","title":"2. Create <code>app.py</code>","text":"<pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.get('/')\ndef home():\n    return {\"message\": \"Welcome to RestMachine!\"}\n\n@app.get('/hello/{name}')\ndef hello(path_params):\n    name = path_params['name']\n    return {\"message\": f\"Hello, {name}!\"}\n\n@app.post('/echo')\ndef echo(json_body):\n    return {\"you_sent\": json_body}\n</code></pre>"},{"location":"getting-started/quickstart/#3-test-locally","title":"3. Test Locally","text":"<p>You can test your application directly without a server:</p> <pre><code>from restmachine import Request, HTTPMethod\n\n# Test GET\nrequest = Request(method=HTTPMethod.GET, path='/')\nresponse = app.execute(request)\nprint(response.body)  # {\"message\": \"Welcome to RestMachine!\"}\n\n# Test with path params\nrequest = Request(method=HTTPMethod.GET, path='/hello/World')\nresponse = app.execute(request)\nprint(response.body)  # {\"message\": \"Hello, World!\"}\n</code></pre>"},{"location":"getting-started/quickstart/#deploy-with-asgi-servers","title":"Deploy with ASGI Servers","text":"<p>RestMachine includes built-in ASGI support for production deployment.</p>"},{"location":"getting-started/quickstart/#option-1-uvicorn-recommended","title":"Option 1: Uvicorn (Recommended)","text":"<p>Add ASGI adapter to <code>app.py</code>:</p> <pre><code>from restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n@app.get('/')\ndef home():\n    return {\"message\": \"Welcome to RestMachine!\"}\n\n# Create ASGI application\nasgi_app = ASGIAdapter(app)\n</code></pre> <p>Run with Uvicorn:</p> <pre><code># Development (with auto-reload)\nuvicorn app:asgi_app --reload --host 0.0.0.0 --port 8000\n\n# Production\nuvicorn app:asgi_app --host 0.0.0.0 --port 8000 --workers 4\n</code></pre> <p>Test it:</p> <pre><code>curl http://localhost:8000/\n# {\"message\": \"Welcome to RestMachine!\"}\n\ncurl http://localhost:8000/hello/RestMachine\n# {\"message\": \"Hello, RestMachine!\"}\n</code></pre>"},{"location":"getting-started/quickstart/#option-2-hypercorn-http2-support","title":"Option 2: Hypercorn (HTTP/2 Support)","text":"<p>Install:</p> <pre><code>pip install hypercorn\n</code></pre> <p>Run with Hypercorn:</p> <pre><code># Development\nhypercorn app:asgi_app --reload --bind 0.0.0.0:8000\n\n# Production with HTTP/2\nhypercorn app:asgi_app --bind 0.0.0.0:8000 --workers 4\n</code></pre>"},{"location":"getting-started/quickstart/#option-3-gunicorn-uvicorn-workers","title":"Option 3: Gunicorn + Uvicorn Workers","text":"<p>For production deployments with process management:</p> <pre><code>pip install gunicorn uvicorn[standard]\n</code></pre> <pre><code>gunicorn app:asgi_app \\\n  -w 4 \\\n  -k uvicorn.workers.UvicornWorker \\\n  --bind 0.0.0.0:8000 \\\n  --access-logfile - \\\n  --error-logfile -\n</code></pre>"},{"location":"getting-started/quickstart/#deploy-to-aws-lambda","title":"Deploy to AWS Lambda","text":"<p>RestMachine provides first-class support for AWS Lambda deployment.</p>"},{"location":"getting-started/quickstart/#1-install-aws-package","title":"1. Install AWS Package","text":"<pre><code>pip install restmachine-aws\n</code></pre>"},{"location":"getting-started/quickstart/#2-create-lambda_handlerpy","title":"2. Create <code>lambda_handler.py</code>","text":"<pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\n\napp = RestApplication()\n\n@app.get('/')\ndef home():\n    return {\"message\": \"Welcome to RestMachine on Lambda!\"}\n\n@app.get('/hello/{name}')\ndef hello(path_params):\n    name = path_params['name']\n    return {\"message\": f\"Hello, {name}!\"}\n\n# Create AWS Lambda adapter\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"getting-started/quickstart/#3-package-for-deployment","title":"3. Package for Deployment","text":"<p>Create a deployment package:</p> <pre><code># Create a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install restmachine restmachine-aws\n\n# Package the code\nmkdir package\npip install --target ./package restmachine restmachine-aws\ncd package\nzip -r ../lambda_function.zip .\ncd ..\nzip lambda_function.zip lambda_handler.py\n</code></pre>"},{"location":"getting-started/quickstart/#4-deploy-to-aws-lambda","title":"4. Deploy to AWS Lambda","text":"<p>Using AWS CLI:</p> <pre><code># Create Lambda function\naws lambda create-function \\\n  --function-name restmachine-api \\\n  --runtime python3.11 \\\n  --role arn:aws:iam::YOUR_ACCOUNT:role/lambda-execution-role \\\n  --handler lambda_handler.lambda_handler \\\n  --zip-file fileb://lambda_function.zip \\\n  --timeout 30 \\\n  --memory-size 512\n</code></pre>"},{"location":"getting-started/quickstart/#5-connect-to-api-gateway","title":"5. Connect to API Gateway","text":"<p>Create API Gateway REST API:</p> <pre><code>aws apigatewayv2 create-api \\\n  --name restmachine-api \\\n  --protocol-type HTTP \\\n  --target arn:aws:lambda:REGION:ACCOUNT:function:restmachine-api\n</code></pre> <p>Or create Function URL (simpler):</p> <pre><code>aws lambda create-function-url-config \\\n  --function-name restmachine-api \\\n  --auth-type NONE\n</code></pre>"},{"location":"getting-started/quickstart/#supported-event-sources","title":"Supported Event Sources","text":"<p>The AWS adapter automatically detects and handles:</p> Event Source Format Notes API Gateway REST API v1 (1.0) Traditional REST APIs API Gateway HTTP API v2 (2.0) Lower latency, cheaper Application Load Balancer ALB Multi-value headers, mTLS Lambda Function URLs v2 Simplest setup"},{"location":"getting-started/quickstart/#add-startup-shutdown-handlers","title":"Add Startup &amp; Shutdown Handlers","text":"<p>RestMachine supports lifecycle hooks for resource management:</p> <pre><code>from restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n# Startup handler (runs once when app starts)\n@app.on_startup\ndef database():\n    print(\"Opening database connection...\")\n    return create_db_connection()\n\n# Use dependency injection\n@app.get('/users')\ndef list_users(database):  # 'database' injected from startup\n    return database.query(\"SELECT * FROM users\")\n\n# Shutdown handler (runs when app stops)\n@app.on_shutdown\ndef close_database(database):  # Can also inject dependencies\n    print(\"Closing database connection...\")\n    database.close()\n\nasgi_app = ASGIAdapter(app)\n</code></pre> <p>ASGI Deployment: Startup/shutdown handlers work automatically.</p> <p>AWS Lambda: Startup handlers run during cold start. For shutdown handlers, see Lambda Extensions.</p>"},{"location":"getting-started/quickstart/#generate-openapi-documentation","title":"Generate OpenAPI Documentation","text":"<p>RestMachine automatically generates OpenAPI 3.0 specifications from your code:</p> <pre><code>from restmachine import RestApplication\nfrom pydantic import BaseModel, EmailStr\n\napp = RestApplication()\n\nclass UserCreate(BaseModel):\n    name: str\n    email: EmailStr\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n@app.post('/users')\ndef create_user(user_create: UserCreate):\n    \"\"\"Create a new user account.\"\"\"\n    return {\"created\": user_create.model_dump()}, 201\n\n# Generate OpenAPI spec\nopenapi_json = app.generate_openapi_json(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"My awesome API\"\n)\n\n# Or save to file\napp.save_openapi_json(\n    filename=\"openapi.json\",\n    docs_dir=\"docs\"\n)\n</code></pre>"},{"location":"getting-started/quickstart/#add-interactive-documentation","title":"Add Interactive Documentation","text":"<p>Serve Swagger UI for interactive API documentation:</p> <pre><code>@app.get('/openapi.json')\ndef openapi_spec():\n    \"\"\"OpenAPI specification endpoint.\"\"\"\n    import json\n    return json.loads(app.generate_openapi_json(\n        title=\"My API\",\n        version=\"1.0.0\"\n    ))\n\n@app.get('/docs')\ndef swagger_ui():\n    \"\"\"Interactive API documentation.\"\"\"\n    return \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;API Documentation&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"swagger-ui\"&gt;&lt;/div&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n            SwaggerUIBundle({\n                url: '/openapi.json',\n                dom_id: '#swagger-ui',\n            });\n        &lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre> <p>Visit <code>http://localhost:8000/docs</code> to see your interactive API documentation.</p> <p>See the OpenAPI Guide for advanced features including client SDK generation.</p>"},{"location":"getting-started/quickstart/#observability-metrics","title":"Observability &amp; Metrics","text":"<p>RestMachine includes built-in metrics collection to help you monitor your application's performance.</p>"},{"location":"getting-started/quickstart/#default-behavior","title":"Default Behavior","text":"<p>AWS Lambda: Metrics are automatically enabled and published to CloudWatch Logs in EMF (Embedded Metric Format). No configuration required!</p> <pre><code>from restmachine_aws import AwsApiGatewayAdapter\n\n# Metrics automatically enabled for CloudWatch\nadapter = AwsApiGatewayAdapter(app)\n</code></pre> <p>ASGI/Other Platforms: Metrics collection is available but requires a custom publisher. See the Metrics documentation for details.</p>"},{"location":"getting-started/quickstart/#adding-custom-metrics","title":"Adding Custom Metrics","text":"<p>Inject the <code>metrics</code> dependency to track business metrics:</p> <pre><code>@app.get('/orders')\ndef list_orders(metrics):\n    # Track request count\n    metrics.add_metric(\"orders.listed\", 1, unit=\"Count\")\n\n    # Track timing\n    metrics.start_timer(\"db.query\")\n    orders = db.query(\"SELECT * FROM orders\")\n    metrics.stop_timer(\"db.query\")\n\n    return {\"orders\": orders}\n</code></pre>"},{"location":"getting-started/quickstart/#what-gets-logged","title":"What Gets Logged","text":"<p>All requests automatically include: - Total request time - Application execution time - Response conversion time - HTTP method and path - Status code</p> <p>For more details: - Core Metrics Guide - Platform-agnostic metrics features - AWS CloudWatch Metrics - CloudWatch EMF configuration</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you have a running application:</p> <ul> <li>Basic Application \u2192 - Learn fundamental concepts</li> <li>Dependency Injection \u2192 - Master DI patterns</li> <li>Request Validation \u2192 - Add Pydantic validation</li> <li>Deployment Guide \u2192 - Production deployment strategies</li> </ul>"},{"location":"getting-started/quickstart/#common-issues","title":"Common Issues","text":"Import Error: No module named 'restmachine' <p>Make sure you've installed RestMachine: <pre><code>pip install restmachine\n</code></pre></p> ASGI server not working <p>Ensure you've created the ASGI adapter: <pre><code>asgi_app = ASGIAdapter(app)\n</code></pre> And you're running the correct module: <code>uvicorn app:asgi_app</code></p> Lambda function timing out <p>Increase the timeout in your Lambda configuration: <pre><code>aws lambda update-function-configuration \\\n  --function-name restmachine-api \\\n  --timeout 30\n</code></pre></p> 404 Not Found for all routes <p>Check that your API Gateway integration is configured correctly to proxy all requests to Lambda: - Use <code>{proxy+}</code> as the resource path - Enable \"Lambda Proxy Integration\"</p>"},{"location":"guide/authentication/","title":"Authentication","text":"<p>Implement authentication and authorization in RestMachine using dependency injection. This guide covers API keys, JWT tokens, OAuth, and role-based access control.</p>"},{"location":"guide/authentication/#basic-authentication","title":"Basic Authentication","text":""},{"location":"guide/authentication/#api-key-authentication","title":"API Key Authentication","text":"<p>Simple API key authentication using headers:</p> <pre><code>from restmachine import RestApplication, Request, Response\nimport json\n\napp = RestApplication()\n\n# Database initialized at startup\n@app.on_startup\ndef database():\n    \"\"\"Initialize API keys and user data at startup.\"\"\"\n    return {\n        \"api_keys\": {\n            \"key_12345\": {\"user_id\": \"1\", \"name\": \"Alice\"},\n            \"key_67890\": {\"user_id\": \"2\", \"name\": \"Bob\"}\n        }\n    }\n\n@app.dependency()\ndef api_key(request: Request) -&gt; str:\n    \"\"\"Extract API key from header.\"\"\"\n    key = request.headers.get('x-api-key')\n    if not key:\n        raise ValueError(\"API key required\")\n    return key\n\n@app.dependency()\ndef current_user(api_key: str, database):\n    \"\"\"Validate API key and get user.\"\"\"\n    user = database[\"api_keys\"].get(api_key)\n    if not user:\n        raise ValueError(\"Invalid API key\")\n    return user\n\n@app.get('/protected')\ndef protected_resource(current_user):\n    return {\n        \"message\": f\"Hello, {current_user['name']}!\",\n        \"user_id\": current_user['user_id']\n    }\n\n@app.error_handler(401)\ndef unauthorized(request, message, **kwargs):\n    return {\n        \"error\": \"Unauthorized\",\n        \"message\": message\n    }\n</code></pre>"},{"location":"guide/authentication/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>Implement Bearer token authentication:</p> <pre><code>@app.dependency()\ndef bearer_token(request: Request) -&gt; str:\n    \"\"\"Extract bearer token from Authorization header.\"\"\"\n    auth_header = request.headers.get('authorization', '')\n\n    if not auth_header.startswith('Bearer '):\n        raise ValueError(\"Bearer token required\")\n\n    return auth_header[7:]  # Remove 'Bearer ' prefix\n\n@app.dependency()\ndef current_user(bearer_token: str):\n    \"\"\"Validate token and get user.\"\"\"\n    # In production, validate against database or cache\n    user = validate_token(bearer_token)\n    if not user:\n        raise ValueError(\"Invalid or expired token\")\n    return user\n\ndef validate_token(token: str):\n    \"\"\"Validate token (implement your logic).\"\"\"\n    # Simplified example\n    if token == \"valid_token_123\":\n        return {\"id\": \"1\", \"name\": \"Alice\", \"role\": \"admin\"}\n    return None\n</code></pre>"},{"location":"guide/authentication/#jwt-authentication","title":"JWT Authentication","text":""},{"location":"guide/authentication/#jwt-token-validation","title":"JWT Token Validation","text":"<p>Use PyJWT for token-based authentication:</p> <pre><code>import jwt\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any\n\n# Configuration\nSECRET_KEY = \"your-secret-key\"  # Use environment variable in production\nALGORITHM = \"HS256\"\nTOKEN_EXPIRY_HOURS = 24\n\n@app.dependency()\ndef jwt_token(request: Request) -&gt; str:\n    \"\"\"Extract JWT from Authorization header.\"\"\"\n    auth_header = request.headers.get('authorization', '')\n\n    if not auth_header.startswith('Bearer '):\n        raise ValueError(\"JWT token required\")\n\n    return auth_header[7:]\n\n@app.dependency()\ndef current_user(jwt_token: str) -&gt; Dict[str, Any]:\n    \"\"\"Decode and validate JWT token.\"\"\"\n    try:\n        payload = jwt.decode(\n            jwt_token,\n            SECRET_KEY,\n            algorithms=[ALGORITHM]\n        )\n\n        # Check expiration\n        exp = payload.get('exp')\n        if exp and datetime.fromtimestamp(exp) &lt; datetime.now():\n            raise ValueError(\"Token expired\")\n\n        return {\n            \"id\": payload.get('user_id'),\n            \"email\": payload.get('email'),\n            \"role\": payload.get('role', 'user')\n        }\n\n    except jwt.InvalidTokenError as e:\n        raise ValueError(f\"Invalid token: {str(e)}\")\n\n@app.post('/login')\ndef login(request: Request):\n    \"\"\"Generate JWT token for user.\"\"\"\n    import json\n    data = json.loads(request.body)\n\n    # Validate credentials (simplified)\n    if data.get('email') == 'alice@example.com' and data.get('password') == 'secret':\n        # Create token\n        payload = {\n            'user_id': '1',\n            'email': 'alice@example.com',\n            'role': 'admin',\n            'exp': datetime.now() + timedelta(hours=TOKEN_EXPIRY_HOURS),\n            'iat': datetime.now()\n        }\n\n        token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)\n\n        return {\n            \"access_token\": token,\n            \"token_type\": \"bearer\",\n            \"expires_in\": TOKEN_EXPIRY_HOURS * 3600\n        }\n\n    return Response(401, json.dumps({\"error\": \"Invalid credentials\"}))\n\n@app.get('/profile')\ndef get_profile(current_user):\n    return {\n        \"user\": current_user\n    }\n</code></pre>"},{"location":"guide/authentication/#refresh-tokens","title":"Refresh Tokens","text":"<p>Implement refresh token pattern:</p> <pre><code>from uuid import uuid4\n\n# Store refresh tokens (use Redis in production)\nREFRESH_TOKENS = {}\n\ndef create_tokens(user_id: str, email: str, role: str):\n    \"\"\"Create access and refresh tokens.\"\"\"\n    # Access token (short-lived)\n    access_payload = {\n        'user_id': user_id,\n        'email': email,\n        'role': role,\n        'exp': datetime.now() + timedelta(hours=1),\n        'iat': datetime.now(),\n        'type': 'access'\n    }\n    access_token = jwt.encode(access_payload, SECRET_KEY, algorithm=ALGORITHM)\n\n    # Refresh token (long-lived)\n    refresh_token_id = str(uuid4())\n    refresh_payload = {\n        'token_id': refresh_token_id,\n        'user_id': user_id,\n        'exp': datetime.now() + timedelta(days=30),\n        'iat': datetime.now(),\n        'type': 'refresh'\n    }\n    refresh_token = jwt.encode(refresh_payload, SECRET_KEY, algorithm=ALGORITHM)\n\n    # Store refresh token\n    REFRESH_TOKENS[refresh_token_id] = {\n        'user_id': user_id,\n        'created_at': datetime.now(),\n        'active': True\n    }\n\n    return access_token, refresh_token\n\n@app.post('/login')\ndef login(request: Request):\n    import json\n    data = json.loads(request.body)\n\n    # Validate credentials\n    if data.get('email') == 'alice@example.com' and data.get('password') == 'secret':\n        access_token, refresh_token = create_tokens('1', 'alice@example.com', 'admin')\n\n        return {\n            \"access_token\": access_token,\n            \"refresh_token\": refresh_token,\n            \"token_type\": \"bearer\",\n            \"expires_in\": 3600\n        }\n\n    return Response(401, json.dumps({\"error\": \"Invalid credentials\"}))\n\n@app.post('/refresh')\ndef refresh_access_token(request: Request):\n    import json\n    data = json.loads(request.body)\n    refresh_token = data.get('refresh_token')\n\n    try:\n        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])\n\n        # Validate refresh token\n        token_id = payload.get('token_id')\n        if token_id not in REFRESH_TOKENS or not REFRESH_TOKENS[token_id]['active']:\n            return Response(401, json.dumps({\"error\": \"Invalid refresh token\"}))\n\n        # Create new access token\n        user_id = payload.get('user_id')\n        # In production, fetch user details from database\n        new_access_token = jwt.encode({\n            'user_id': user_id,\n            'exp': datetime.now() + timedelta(hours=1),\n            'type': 'access'\n        }, SECRET_KEY, algorithm=ALGORITHM)\n\n        return {\n            \"access_token\": new_access_token,\n            \"token_type\": \"bearer\",\n            \"expires_in\": 3600\n        }\n\n    except jwt.InvalidTokenError:\n        return Response(401, json.dumps({\"error\": \"Invalid refresh token\"}))\n\n@app.post('/logout')\ndef logout(request: Request, current_user):\n    \"\"\"Revoke refresh tokens for user.\"\"\"\n    import json\n    data = json.loads(request.body)\n    refresh_token = data.get('refresh_token')\n\n    try:\n        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])\n        token_id = payload.get('token_id')\n\n        if token_id in REFRESH_TOKENS:\n            REFRESH_TOKENS[token_id]['active'] = False\n\n        return {\"message\": \"Logged out successfully\"}\n\n    except jwt.InvalidTokenError:\n        return Response(400, json.dumps({\"error\": \"Invalid token\"}))\n</code></pre>"},{"location":"guide/authentication/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":""},{"location":"guide/authentication/#basic-rbac","title":"Basic RBAC","text":"<p>Implement role-based authorization:</p> <pre><code>from typing import List\n\n# Simple role-based dependencies\n@app.dependency()\ndef require_admin(current_user):\n    \"\"\"Require admin role.\"\"\"\n    if current_user.get('role') != 'admin':\n        raise PermissionError(\"Admin access required\")\n    return current_user\n\n@app.get('/admin/users')\ndef list_all_users(require_admin, database):\n    \"\"\"Admin-only endpoint.\"\"\"\n    return {\"users\": database[\"users\"]}\n\n@app.dependency()\ndef require_moderator(current_user):\n    \"\"\"Require moderator or admin role.\"\"\"\n    role = current_user.get('role')\n    if role not in ['admin', 'moderator']:\n        raise PermissionError(\"Moderator or admin access required\")\n    return current_user\n\n@app.delete('/posts/{post_id}')\ndef delete_post(path_params, require_moderator, database):\n    \"\"\"Moderators and admins can delete posts.\"\"\"\n    post_id = path_params['post_id']\n    # Delete logic\n    return {\"message\": \"Post deleted\"}, 204\n\n@app.error_handler(403)\ndef forbidden(request, message, **kwargs):\n    return {\n        \"error\": \"Forbidden\",\n        \"message\": message\n    }\n</code></pre>"},{"location":"guide/authentication/#permission-based-access","title":"Permission-Based Access","text":"<p>Implement fine-grained permissions:</p> <pre><code>from enum import Enum\n\nclass Permission(str, Enum):\n    READ_USERS = \"users:read\"\n    WRITE_USERS = \"users:write\"\n    DELETE_USERS = \"users:delete\"\n    READ_POSTS = \"posts:read\"\n    WRITE_POSTS = \"posts:write\"\n    DELETE_POSTS = \"posts:delete\"\n\nROLE_PERMISSIONS = {\n    \"admin\": [\n        Permission.READ_USERS, Permission.WRITE_USERS, Permission.DELETE_USERS,\n        Permission.READ_POSTS, Permission.WRITE_POSTS, Permission.DELETE_POSTS\n    ],\n    \"moderator\": [\n        Permission.READ_USERS, Permission.READ_POSTS,\n        Permission.WRITE_POSTS, Permission.DELETE_POSTS\n    ],\n    \"user\": [\n        Permission.READ_POSTS, Permission.WRITE_POSTS\n    ]\n}\n\n@app.dependency()\ndef current_user_permissions(current_user) -&gt; List[Permission]:\n    \"\"\"Get permissions for current user.\"\"\"\n    role = current_user.get('role', 'user')\n    return ROLE_PERMISSIONS.get(role, [])\n\n# Permission-checking dependencies (one per permission needed)\n@app.dependency()\ndef require_read_users(current_user_permissions: List[Permission]):\n    \"\"\"Require READ_USERS permission.\"\"\"\n    if Permission.READ_USERS not in current_user_permissions:\n        raise PermissionError(f\"Permission '{Permission.READ_USERS}' required\")\n    return True\n\n@app.dependency()\ndef require_delete_users(current_user_permissions: List[Permission]):\n    \"\"\"Require DELETE_USERS permission.\"\"\"\n    if Permission.DELETE_USERS not in current_user_permissions:\n        raise PermissionError(f\"Permission '{Permission.DELETE_USERS}' required\")\n    return True\n\n@app.get('/users')\ndef list_users(require_read_users, database):\n    return {\"users\": database[\"users\"]}\n\n@app.delete('/users/{user_id}')\ndef delete_user(require_delete_users, path_params, database):\n    user_id = path_params['user_id']\n    # Delete logic\n    return {\"message\": \"User deleted\"}, 204\n</code></pre>"},{"location":"guide/authentication/#resource-based-authorization","title":"Resource-Based Authorization","text":""},{"location":"guide/authentication/#owner-based-access","title":"Owner-Based Access","text":"<p>Check if user owns the resource using <code>@app.resource_exists</code> and authorization dependencies:</p> <pre><code>@app.resource_exists\ndef post(path_params, database):\n    \"\"\"Get post by ID, returns None if not found (triggers 404).\"\"\"\n    post_id = path_params.get('post_id')\n    return next((p for p in database[\"posts\"] if p[\"id\"] == post_id), None)\n\n@app.dependency()\ndef authorized_post(post, current_user):\n    \"\"\"Require user to be post owner or admin.\"\"\"\n    user_role = current_user.get('role')\n    user_id = current_user.get('id')\n\n    if user_role == 'admin':\n        return post  # Admins can access any post\n\n    if post['author_id'] != user_id:\n        raise PermissionError(\"You can only edit your own posts\")\n\n    return post\n\n@app.put('/posts/{post_id}')\ndef update_post(authorized_post, json_body):\n    \"\"\"Update post (owner or admin only). 404 and 403 handled automatically.\"\"\"\n    authorized_post.update(json_body)\n    return authorized_post\n</code></pre>"},{"location":"guide/authentication/#optional-authentication","title":"Optional Authentication","text":""},{"location":"guide/authentication/#public-and-protected-routes","title":"Public and Protected Routes","text":"<p>Make authentication optional for some routes:</p> <pre><code>@app.dependency()\ndef optional_user(request: Request):\n    \"\"\"Get current user if authenticated, None otherwise.\"\"\"\n    auth_header = request.headers.get('authorization', '')\n\n    if not auth_header.startswith('Bearer '):\n        return None\n\n    token = auth_header[7:]\n\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return {\n            \"id\": payload.get('user_id'),\n            \"role\": payload.get('role', 'user')\n        }\n    except jwt.InvalidTokenError:\n        return None\n\n@app.get('/posts')\ndef list_posts(optional_user, database):\n    \"\"\"List posts. Authenticated users see more details.\"\"\"\n    posts = database[\"posts\"]\n\n    if optional_user:\n        # Authenticated: show all fields\n        return {\"posts\": posts}\n    else:\n        # Anonymous: show limited fields\n        return {\n            \"posts\": [\n                {\n                    \"id\": p[\"id\"],\n                    \"title\": p[\"title\"],\n                    \"published\": p.get(\"published\", False)\n                }\n                for p in posts\n                if p.get(\"published\", False)\n            ]\n        }\n</code></pre>"},{"location":"guide/authentication/#session-based-authentication","title":"Session-Based Authentication","text":""},{"location":"guide/authentication/#cookie-based-sessions","title":"Cookie-Based Sessions","text":"<p>Implement session-based auth with cookies:</p> <pre><code>from uuid import uuid4\nfrom datetime import datetime, timedelta\n\n# Store sessions (use Redis in production)\nSESSIONS = {}\n\n@app.post('/login')\ndef login(request: Request):\n    import json\n    data = json.loads(request.body)\n\n    # Validate credentials\n    if data.get('email') == 'alice@example.com' and data.get('password') == 'secret':\n        # Create session\n        session_id = str(uuid4())\n        SESSIONS[session_id] = {\n            'user_id': '1',\n            'email': 'alice@example.com',\n            'role': 'admin',\n            'created_at': datetime.now(),\n            'expires_at': datetime.now() + timedelta(days=7)\n        }\n\n        # Return session cookie\n        return (\n            {\"message\": \"Logged in successfully\"},\n            200,\n            {\n                'Set-Cookie': f'session_id={session_id}; HttpOnly; SameSite=Lax; Max-Age=604800'\n            }\n        )\n\n    return Response(401, json.dumps({\"error\": \"Invalid credentials\"}))\n\n@app.dependency()\ndef session_id(request: Request) -&gt; str:\n    \"\"\"Extract session ID from cookie.\"\"\"\n    cookies = request.headers.get('cookie', '')\n\n    # Parse cookies (simplified)\n    for cookie in cookies.split(';'):\n        cookie = cookie.strip()\n        if cookie.startswith('session_id='):\n            return cookie[11:]  # Remove 'session_id=' prefix\n\n    raise ValueError(\"Not authenticated\")\n\n@app.dependency()\ndef current_user(session_id: str):\n    \"\"\"Get user from session.\"\"\"\n    session = SESSIONS.get(session_id)\n\n    if not session:\n        raise ValueError(\"Invalid session\")\n\n    # Check expiration\n    if session['expires_at'] &lt; datetime.now():\n        del SESSIONS[session_id]\n        raise ValueError(\"Session expired\")\n\n    return {\n        'id': session['user_id'],\n        'email': session['email'],\n        'role': session['role']\n    }\n\n@app.post('/logout')\ndef logout(session_id: str):\n    \"\"\"Destroy session.\"\"\"\n    if session_id in SESSIONS:\n        del SESSIONS[session_id]\n\n    return (\n        {\"message\": \"Logged out successfully\"},\n        200,\n        {\n            'Set-Cookie': 'session_id=; HttpOnly; SameSite=Lax; Max-Age=0'\n        }\n    )\n</code></pre>"},{"location":"guide/authentication/#complete-example","title":"Complete Example","text":"<p>Here's a complete authentication system:</p> <pre><code>from restmachine import RestApplication, Request, Response\nfrom pydantic import BaseModel, EmailStr\nimport jwt\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any\nimport json\n\napp = RestApplication()\n\n# Configuration\nSECRET_KEY = \"your-secret-key-change-in-production\"\nALGORITHM = \"HS256\"\n\n# Models\nclass LoginRequest(BaseModel):\n    email: EmailStr\n    password: str\n\nclass User(BaseModel):\n    id: str\n    email: EmailStr\n    role: str\n\n# Database\n@app.on_startup\ndef database():\n    return {\n        \"users\": [\n            {\n                \"id\": \"1\",\n                \"email\": \"alice@example.com\",\n                \"password_hash\": \"hashed_password\",  # Use bcrypt in production\n                \"role\": \"admin\"\n            },\n            {\n                \"id\": \"2\",\n                \"email\": \"bob@example.com\",\n                \"password_hash\": \"hashed_password\",\n                \"role\": \"user\"\n            }\n        ],\n        \"posts\": [\n            {\"id\": \"1\", \"title\": \"Post 1\", \"author_id\": \"1\"},\n            {\"id\": \"2\", \"title\": \"Post 2\", \"author_id\": \"2\"}\n        ]\n    }\n\n# Authentication\n@app.validates\ndef login_request(json_body) -&gt; LoginRequest:\n    return LoginRequest.model_validate(json_body)\n\n@app.dependency()\ndef jwt_token(request: Request) -&gt; str:\n    auth_header = request.headers.get('authorization', '')\n    if not auth_header.startswith('Bearer '):\n        raise ValueError(\"Authentication required\")\n    return auth_header[7:]\n\n@app.dependency()\ndef current_user(jwt_token: str, database) -&gt; Dict[str, Any]:\n    try:\n        payload = jwt.decode(jwt_token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id = payload.get('user_id')\n\n        user = next((u for u in database[\"users\"] if u[\"id\"] == user_id), None)\n        if not user:\n            raise ValueError(\"User not found\")\n\n        return {\n            \"id\": user[\"id\"],\n            \"email\": user[\"email\"],\n            \"role\": user[\"role\"]\n        }\n    except jwt.InvalidTokenError as e:\n        raise ValueError(f\"Invalid token: {str(e)}\")\n\n@app.dependency()\ndef require_admin(current_user):\n    if current_user.get('role') != 'admin':\n        raise PermissionError(\"Admin access required\")\n    return current_user\n\n# Routes\n@app.post('/login')\ndef login(login_request: LoginRequest, database):\n    # Find user\n    user = next(\n        (u for u in database[\"users\"] if u[\"email\"] == login_request.email),\n        None\n    )\n\n    # Verify password (use bcrypt.checkpw in production)\n    if not user or user[\"password_hash\"] != \"hashed_password\":\n        return Response(401, json.dumps({\"error\": \"Invalid credentials\"}))\n\n    # Create token\n    payload = {\n        'user_id': user['id'],\n        'email': user['email'],\n        'role': user['role'],\n        'exp': datetime.now() + timedelta(hours=24),\n        'iat': datetime.now()\n    }\n\n    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)\n\n    return {\n        \"access_token\": token,\n        \"token_type\": \"bearer\",\n        \"expires_in\": 86400\n    }\n\n@app.get('/profile')\ndef get_profile(current_user):\n    return {\"user\": current_user}\n\n@app.get('/admin/users')\ndef list_users(require_admin, database):\n    return {\n        \"users\": [\n            {\"id\": u[\"id\"], \"email\": u[\"email\"], \"role\": u[\"role\"]}\n            for u in database[\"users\"]\n        ]\n    }\n\n@app.resource_exists\ndef post(path_params, database):\n    \"\"\"Get post by ID, returns None if not found (triggers 404).\"\"\"\n    post_id = path_params['post_id']\n    return next((p for p in database[\"posts\"] if p[\"id\"] == post_id), None)\n\n@app.get('/posts/{post_id}')\ndef get_post(post, current_user):\n    \"\"\"Get post. 404 handled automatically.\"\"\"\n    return post\n\n@app.dependency()\ndef authorized_post(post, current_user):\n    \"\"\"Check if user can modify post (owner or admin).\"\"\"\n    if post['author_id'] != current_user['id'] and current_user['role'] != 'admin':\n        raise PermissionError(\"Not authorized to modify this post\")\n    return post\n\n@app.delete('/posts/{post_id}')\ndef delete_post(authorized_post, path_params, database):\n    \"\"\"Delete post. 404 and 403 handled automatically.\"\"\"\n    post_id = path_params['post_id']\n    database[\"posts\"] = [p for p in database[\"posts\"] if p[\"id\"] != post_id]\n    return {\"message\": \"Post deleted\"}, 204\n\n# Error handlers\n@app.error_handler(401)\ndef unauthorized(request, message, **kwargs):\n    return {\"error\": \"Unauthorized\", \"message\": message}\n\n@app.error_handler(403)\ndef forbidden(request, message, **kwargs):\n    return {\"error\": \"Forbidden\", \"message\": message}\n\n# ASGI\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n</code></pre>"},{"location":"guide/authentication/#best-practices","title":"Best Practices","text":""},{"location":"guide/authentication/#1-never-store-plain-text-passwords","title":"1. Never Store Plain Text Passwords","text":"<p>Always hash passwords:</p> <pre><code>import bcrypt\n\ndef hash_password(password: str) -&gt; str:\n    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()\n\ndef verify_password(password: str, password_hash: str) -&gt; bool:\n    return bcrypt.checkpw(password.encode(), password_hash.encode())\n</code></pre>"},{"location":"guide/authentication/#2-use-environment-variables","title":"2. Use Environment Variables","text":"<p>Store secrets securely:</p> <pre><code>import os\n\nSECRET_KEY = os.environ.get('JWT_SECRET_KEY')\nif not SECRET_KEY:\n    raise ValueError(\"JWT_SECRET_KEY environment variable not set\")\n</code></pre>"},{"location":"guide/authentication/#3-implement-rate-limiting","title":"3. Implement Rate Limiting","text":"<p>Prevent brute force attacks:</p> <pre><code>from collections import defaultdict\nfrom datetime import datetime, timedelta\n\n# Simple rate limiter (use Redis in production)\nlogin_attempts = defaultdict(list)\n\n@app.dependency()\ndef rate_limit_login(request: Request):\n    ip = request.headers.get('x-forwarded-for', 'unknown')\n\n    # Clean old attempts\n    cutoff = datetime.now() - timedelta(minutes=15)\n    login_attempts[ip] = [t for t in login_attempts[ip] if t &gt; cutoff]\n\n    # Check rate limit\n    if len(login_attempts[ip]) &gt;= 5:\n        raise ValueError(\"Too many login attempts. Try again later.\")\n\n    login_attempts[ip].append(datetime.now())\n    return True\n\n@app.post('/login')\ndef login(rate_limit_login, validate_login: LoginRequest, database):\n    # Login logic\n    ...\n</code></pre>"},{"location":"guide/authentication/#4-set-token-expiration","title":"4. Set Token Expiration","text":"<p>Use short-lived access tokens:</p> <pre><code># Short access token\naccess_exp = datetime.now() + timedelta(hours=1)\n\n# Long refresh token\nrefresh_exp = datetime.now() + timedelta(days=30)\n</code></pre>"},{"location":"guide/authentication/#5-validate-token-claims","title":"5. Validate Token Claims","text":"<p>Always validate all token claims:</p> <pre><code>@app.dependency()\ndef current_user(jwt_token: str):\n    try:\n        payload = jwt.decode(jwt_token, SECRET_KEY, algorithms=[ALGORITHM])\n\n        # Validate token type\n        if payload.get('type') != 'access':\n            raise ValueError(\"Invalid token type\")\n\n        # Validate expiration\n        exp = payload.get('exp')\n        if not exp or datetime.fromtimestamp(exp) &lt; datetime.now():\n            raise ValueError(\"Token expired\")\n\n        # Validate issuer (if using)\n        if payload.get('iss') != 'your-app':\n            raise ValueError(\"Invalid issuer\")\n\n        return payload\n\n    except jwt.InvalidTokenError as e:\n        raise ValueError(f\"Invalid token: {str(e)}\")\n</code></pre>"},{"location":"guide/authentication/#next-steps","title":"Next Steps","text":"<ul> <li>Error Handling \u2192 - Handle authentication errors</li> <li>Testing \u2192 - Test authentication flows</li> <li>Deployment \u2192 - Deploy with HTTPS</li> <li>Advanced Features \u2192 - TLS client certificate authentication</li> </ul>"},{"location":"guide/basic-application/","title":"Basic Application","text":"<p>This guide covers the fundamentals of building a RestMachine application.</p>"},{"location":"guide/basic-application/#creating-your-first-application","title":"Creating Your First Application","text":""},{"location":"guide/basic-application/#minimal-application","title":"Minimal Application","text":"<p>The simplest RestMachine application requires just a few lines:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.get('/')\ndef home():\n    return {\"message\": \"Hello, World!\"}\n</code></pre>"},{"location":"guide/basic-application/#running-the-application","title":"Running the Application","text":"<p>You can test your application in several ways:</p> Direct ExecutionWith ASGI Server <pre><code>from restmachine import Request, HTTPMethod\n\nrequest = Request(method=HTTPMethod.GET, path='/')\nresponse = app.execute(request)\nprint(response.body)  # {\"message\": \"Hello, World!\"}\n</code></pre> <pre><code>from restmachine import ASGIAdapter\n\nasgi_app = ASGIAdapter(app)\n\n# Run with: uvicorn app:asgi_app --reload\n</code></pre>"},{"location":"guide/basic-application/#defining-routes","title":"Defining Routes","text":""},{"location":"guide/basic-application/#http-methods","title":"HTTP Methods","text":"<p>RestMachine supports all standard HTTP methods:</p> <pre><code>@app.get('/users')\ndef list_users():\n    return {\"users\": [\"Alice\", \"Bob\"]}\n\n@app.post('/users')\ndef create_user(json_body):\n    # Access parsed JSON body via dependency injection\n    return {\"created\": json_body}, 201\n\n@app.put('/users/{user_id}')\ndef update_user(path_params, json_body):\n    user_id = path_params['user_id']\n    return {\"updated\": user_id, \"data\": json_body}\n\n@app.patch('/users/{user_id}')\ndef partial_update(path_params, json_body):\n    return {\"patched\": path_params['user_id']}\n\n@app.delete('/users/{user_id}')\ndef delete_user(path_params):\n    # Returning None gives 204 No Content\n    return None\n\n@app.head('/users/{user_id}')\ndef user_head(path_params):\n    # HEAD requests don't return a body\n    return None\n\n@app.options('/users')\ndef user_options():\n    return None, 200, {\"Allow\": \"GET, POST, OPTIONS\"}\n</code></pre>"},{"location":"guide/basic-application/#path-parameters","title":"Path Parameters","text":"<p>Capture dynamic path segments using the <code>path_params</code> dependency:</p> <pre><code>@app.get('/users/{user_id}')\ndef get_user(path_params):\n    user_id = path_params['user_id']\n    return {\"user_id\": user_id}\n\n@app.get('/posts/{post_id}/comments/{comment_id}')\ndef get_comment(path_params):\n    post_id = path_params['post_id']\n    comment_id = path_params['comment_id']\n    return {\n        \"post_id\": post_id,\n        \"comment_id\": comment_id\n    }\n</code></pre>"},{"location":"guide/basic-application/#query-parameters","title":"Query Parameters","text":"<p>Access query string parameters using the <code>query_params</code> dependency:</p> <pre><code>@app.get('/search')\ndef search(query_params):\n    # URL: /search?q=python&amp;limit=10\n    query = query_params.get('q', '')\n    limit = int(query_params.get('limit', '20'))\n\n    return {\n        \"query\": query,\n        \"limit\": limit,\n        \"results\": []\n    }\n</code></pre>"},{"location":"guide/basic-application/#working-with-requests","title":"Working with Requests","text":""},{"location":"guide/basic-application/#request-object","title":"Request Object","text":"<p>The <code>Request</code> object contains all information about the incoming request:</p> <pre><code>@app.post('/example')\ndef example_handler(request):\n    # HTTP method\n    method = request.method  # HTTPMethod.POST\n\n    # Path\n    path = request.path  # \"/example\"\n\n    # Headers (case-insensitive)\n    content_type = request.headers.get('content-type')\n    auth = request.headers.get('authorization')\n\n    # Body (raw bytes or string)\n    body = request.body\n\n    # Query parameters\n    params = request.query_params  # dict\n\n    # Path parameters\n    path_params = request.path_params  # dict\n\n    # Parsed JSON (if content-type is application/json)\n    import json\n    if content_type == 'application/json':\n        data = json.loads(body)\n\n    return {\"received\": True}\n</code></pre>"},{"location":"guide/basic-application/#request-headers","title":"Request Headers","text":"<p>Headers are case-insensitive and support multiple values. Use the <code>request_headers</code> dependency:</p> <pre><code>@app.get('/headers')\ndef show_headers(request_headers):\n    # Get single header\n    user_agent = request_headers.get('user-agent')\n\n    # Get all headers\n    all_headers = dict(request_headers)\n\n    # Check if header exists\n    has_auth = 'authorization' in request_headers\n\n    return {\n        \"user_agent\": user_agent,\n        \"headers\": all_headers,\n        \"authenticated\": has_auth\n    }\n</code></pre>"},{"location":"guide/basic-application/#request-body","title":"Request Body","text":"<p>For JSON requests, use the <code>json_body</code> dependency for automatic parsing:</p> <pre><code>@app.post('/data')\ndef handle_json(json_body):\n    # json_body is automatically parsed from application/json requests\n    return {\"received\": json_body}\n</code></pre> <p>For other content types, use the <code>request</code> dependency:</p> <pre><code>@app.post('/form')\ndef handle_form(request):\n    content_type = request.headers.get('content-type', '')\n\n    if 'application/x-www-form-urlencoded' in content_type:\n        from urllib.parse import parse_qs\n        data = parse_qs(request.body.decode())\n        return {\"form\": data}\n\n    elif 'text/plain' in content_type:\n        text = request.body.decode()\n        return {\"text\": text}\n\n    else:\n        return {\"error\": \"Unsupported content type\"}, 415\n</code></pre>"},{"location":"guide/basic-application/#working-with-responses","title":"Working with Responses","text":""},{"location":"guide/basic-application/#returning-data","title":"Returning Data","text":"<p>RestMachine automatically serializes return values:</p> <pre><code># Return dict (automatically JSON-encoded)\n@app.get('/json')\ndef return_json():\n    return {\"key\": \"value\"}\n\n# Return string\n@app.get('/text')\ndef return_text():\n    return \"Plain text response\"\n\n# Return list\n@app.get('/list')\ndef return_list():\n    return [1, 2, 3, 4, 5]\n\n# Return None (204 No Content)\n@app.delete('/resource')\ndef delete_resource():\n    return None\n</code></pre>"},{"location":"guide/basic-application/#response-object","title":"Response Object","text":"<p>For more control, return a <code>Response</code> object:</p> <pre><code>from restmachine import Response\n\n@app.get('/custom')\ndef custom_response():\n    return Response(\n        status_code=201,\n        body='{\"created\": true}',\n        headers={\n            'Content-Type': 'application/json',\n            'X-Custom-Header': 'value'\n        }\n    )\n</code></pre>"},{"location":"guide/basic-application/#status-codes","title":"Status Codes","text":"<p>Specify status codes in several ways:</p> <pre><code># Tuple: (body, status_code)\n@app.post('/users')\ndef create_user(json_body):\n    return {\"user\": \"created\"}, 201\n\n# Tuple: (body, status_code, headers)\n@app.get('/redirect')\ndef redirect():\n    return None, 302, {\"Location\": \"/new-location\"}\n\n# Response object\n@app.get('/error')\ndef error():\n    from restmachine import Response\n    return Response(404, \"Not Found\")\n</code></pre>"},{"location":"guide/basic-application/#response-headers","title":"Response Headers","text":"<p>Add custom headers:</p> <pre><code>@app.get('/cached')\ndef cached_resource():\n    return (\n        {\"data\": \"value\"},\n        200,\n        {\n            'Cache-Control': 'max-age=3600',\n            'ETag': '\"abc123\"',\n            'Last-Modified': 'Wed, 21 Oct 2015 07:28:00 GMT'\n        }\n    )\n</code></pre>"},{"location":"guide/basic-application/#content-negotiation","title":"Content Negotiation","text":"<p>RestMachine automatically handles content negotiation based on the <code>Accept</code> header:</p> <pre><code>import json\n\n# Register JSON renderer (built-in)\n@app.content_renderer(\"application/json\")\ndef render_json(data):\n    return json.dumps(data)\n\n# Register XML renderer\n@app.content_renderer(\"application/xml\")\ndef render_xml(data):\n    return f\"&lt;data&gt;{data}&lt;/data&gt;\"\n\n# Register CSV renderer\n@app.content_renderer(\"text/csv\")\ndef render_csv(data):\n    if isinstance(data, list):\n        return \"\\n\".join(str(item) for item in data)\n    return str(data)\n\n@app.get('/data')\ndef get_data():\n    return {\"message\": \"Hello\"}\n\n# Client requests:\n# Accept: application/json \u2192 {\"message\": \"Hello\"}\n# Accept: application/xml  \u2192 &lt;data&gt;{'message': 'Hello'}&lt;/data&gt;\n# Accept: text/csv         \u2192 message\n</code></pre>"},{"location":"guide/basic-application/#error-handling","title":"Error Handling","text":""},{"location":"guide/basic-application/#built-in-error-responses","title":"Built-in Error Responses","text":"<p>Use decorators to automatically generate appropriate error responses:</p> <pre><code>@app.on_startup\ndef database():\n    return {\"users\": {\"1\": {\"id\": \"1\", \"name\": \"Alice\"}}}\n\n# Use @app.resource_exists to return 404 when resource not found\n@app.resource_exists\ndef user(path_params, database):\n    user_id = path_params['user_id']\n    # Return None to trigger 404, or return the resource\n    return database[\"users\"].get(user_id)\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    # user is injected - if it was None, 404 already returned\n    return user\n</code></pre>"},{"location":"guide/basic-application/#custom-error-handlers","title":"Custom Error Handlers","text":"<p>Define custom handlers for specific status codes:</p> <pre><code>@app.error_handler(404)\ndef not_found_handler(request, message, **kwargs):\n    return {\n        \"error\": \"Not Found\",\n        \"message\": message,\n        \"path\": request.path\n    }\n\n@app.error_handler(500)\ndef server_error_handler(request, message, **kwargs):\n    # Log the error\n    print(f\"Server error: {message}\")\n\n    return {\n        \"error\": \"Internal Server Error\",\n        \"message\": \"Something went wrong\"\n    }\n</code></pre>"},{"location":"guide/basic-application/#application-configuration","title":"Application Configuration","text":""},{"location":"guide/basic-application/#debug-mode","title":"Debug Mode","text":"<p>Enable debug mode for development:</p> <pre><code>app = RestApplication()\n\n# Development\nif __name__ == '__main__':\n    # Enable detailed error messages\n    import traceback\n    app.debug = True\n</code></pre>"},{"location":"guide/basic-application/#custom-configuration","title":"Custom Configuration","text":"<p>Store configuration in your application:</p> <pre><code>class Config:\n    DEBUG = True\n    DATABASE_URL = \"postgresql://localhost/mydb\"\n    API_KEY = \"secret\"\n\napp = RestApplication()\napp.config = Config()\n\n@app.get('/config')\ndef show_config():\n    return {\n        \"debug\": app.config.DEBUG,\n        \"database\": app.config.DATABASE_URL\n    }\n</code></pre>"},{"location":"guide/basic-application/#complete-example","title":"Complete Example","text":"<p>Here's a complete example using dependency injection and decorators:</p> <pre><code>from restmachine import RestApplication, Request, HTTPMethod\nfrom pydantic import BaseModel, Field\n\napp = RestApplication()\n\n# Database (initialized at startup)\n@app.on_startup\ndef database():\n    \"\"\"Initialize database connection at startup.\"\"\"\n    return {\n        \"users\": {\n            \"1\": {\"id\": \"1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            \"2\": {\"id\": \"2\", \"name\": \"Bob\", \"email\": \"bob@example.com\"}\n        }\n    }\n\n# Validation models\nclass CreateUserRequest(BaseModel):\n    name: str = Field(min_length=1)\n    email: str = Field(pattern=r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$')\n\nclass UpdateUserRequest(BaseModel):\n    name: str | None = None\n    email: str | None = None\n\n# Decorators for proper status codes\n@app.resource_exists\ndef user(path_params, database):\n    \"\"\"Returns user or None (which triggers 404).\"\"\"\n    user_id = path_params.get('user_id')\n    return database[\"users\"].get(user_id)\n\n@app.validates\ndef user_create(json_body) -&gt; CreateUserRequest:\n    \"\"\"Validates create request, returns 422 on error.\"\"\"\n    return CreateUserRequest.model_validate(json_body)\n\n@app.validates\ndef user_update(json_body) -&gt; UpdateUserRequest:\n    \"\"\"Validates update request, returns 422 on error.\"\"\"\n    return UpdateUserRequest.model_validate(json_body)\n\n# Helper function (placeholder - use bcrypt in production)\ndef hash_password(password: str) -&gt; str:\n    \"\"\"Hash password securely (use bcrypt.hashpw in production).\"\"\"\n    return f\"hashed_{password}\"  # Placeholder only!\n\n# List all users\n@app.get('/users')\ndef list_users(query_params, database):\n    # Support filtering by name\n    name_filter = query_params.get('name')\n    users = database[\"users\"]\n\n    if name_filter:\n        filtered = [u for u in users.values()\n                   if name_filter.lower() in u['name'].lower()]\n        return {\"users\": filtered}\n\n    return {\"users\": list(users.values())}\n\n# Get single user\n@app.get('/users/{user_id}')\ndef get_user(user):\n    # resource_exists decorator handles 404 automatically\n    return user\n\n# Create user\n@app.post('/users')\ndef create_user(user_create: CreateUserRequest, database):\n    # Validation decorator handles 422 automatically\n    users = database[\"users\"]\n    user_id = str(len(users) + 1)\n    user = {\n        \"id\": user_id,\n        **user_create.model_dump()\n    }\n    users[user_id] = user\n    return user, 201\n\n# Update user\n@app.put('/users/{user_id}')\ndef update_user(user, user_update: UpdateUserRequest):\n    # Both decorators handle 404 and 422 automatically\n    if user_update.name:\n        user['name'] = user_update.name\n    if user_update.email:\n        user['email'] = user_update.email\n\n    return user\n\n# Delete user\n@app.delete('/users/{user_id}')\ndef delete_user(user, path_params, database):\n    # resource_exists decorator handles 404 automatically\n    user_id = path_params['user_id']\n    del database[\"users\"][user_id]\n    return None  # Returns 204 No Content\n\n# Custom error handler\n@app.error_handler(404)\ndef not_found(request, message, **kwargs):\n    return {\n        \"error\": \"Not Found\",\n        \"message\": message,\n        \"path\": request.path\n    }\n\n# Run with ASGI\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n\nif __name__ == '__main__':\n    # Test locally\n    req = Request(method=HTTPMethod.GET, path='/users')\n    resp = app.execute(req)\n    print(resp.body)\n</code></pre>"},{"location":"guide/basic-application/#next-steps","title":"Next Steps","text":"<ul> <li>Dependency Injection \u2192 - Learn advanced DI patterns</li> <li>Request Validation \u2192 - Add Pydantic validation</li> <li>Authentication \u2192 - Secure your API</li> <li>Testing \u2192 - Test your application</li> </ul>"},{"location":"guide/concepts/","title":"Core Concepts","text":"<p>RestMachine combines dependency injection with a webmachine-inspired state machine to create a powerful, declarative framework for building REST APIs. This guide explains these core concepts and how they work together.</p>"},{"location":"guide/concepts/#dependency-injection","title":"Dependency Injection","text":"<p>RestMachine features pytest-style dependency injection that makes your code clean, testable, and maintainable. Dependencies are automatically resolved and cached during request processing.</p>"},{"location":"guide/concepts/#how-it-works","title":"How It Works","text":"<p>Dependencies are functions that provide values to your route handlers. RestMachine automatically matches parameter names in your handlers with dependency function names:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.dependency()\ndef database():\n    return {\"users\": [], \"posts\": []}\n\n@app.get('/users')\ndef list_users(database):\n    # database is injected automatically\n    return {\"users\": database[\"users\"]}\n</code></pre>"},{"location":"guide/concepts/#dependency-scopes","title":"Dependency Scopes","text":"<p>RestMachine supports two scopes:</p> <p>Request-scoped (default): Created once per request and cached for that request:</p> <pre><code>@app.dependency()\ndef get_timestamp():\n    from datetime import datetime\n    print(\"Creating timestamp...\")\n    return datetime.now()\n\n@app.get('/example')\ndef example_handler(get_timestamp):\n    # get_timestamp is only created once per request\n    return {\"timestamp\": str(get_timestamp)}\n</code></pre> <p>Session-scoped: Created once when the application starts and shared across all requests:</p> <pre><code>@app.on_startup\ndef database():\n    print(\"Opening database connection...\")\n    # In real app, create connection pool\n    return create_db_pool()\n\n@app.on_shutdown\ndef close_database(database):\n    print(\"Closing database connection...\")\n    database.close()\n\n@app.get('/users')\ndef list_users(database):\n    # Same database instance used across all requests\n    return {\"users\": database.query_all()}\n</code></pre>"},{"location":"guide/concepts/#nested-dependencies","title":"Nested Dependencies","text":"<p>Dependencies can depend on other dependencies, creating a dependency graph:</p> <pre><code>@app.dependency()\ndef config():\n    return {\"db_host\": \"localhost\", \"db_port\": 5432}\n\n@app.dependency()\ndef database_url(config):\n    return f\"postgresql://{config['db_host']}:{config['db_port']}/mydb\"\n\n@app.dependency()\ndef database(database_url):\n    print(f\"Connecting to {database_url}\")\n    return create_connection(database_url)\n\n@app.get('/status')\ndef status(database):\n    # config \u2192 database_url \u2192 database are all resolved automatically\n    return {\"connected\": database.is_connected()}\n</code></pre>"},{"location":"guide/concepts/#the-state-machine","title":"The State Machine","text":"<p>RestMachine uses a webmachine-inspired state machine to process HTTP requests. Instead of running middleware in sequence, the state machine makes decisions at specific points to determine the appropriate HTTP response.</p>"},{"location":"guide/concepts/#why-a-state-machine","title":"Why a State Machine?","text":"<p>The state machine approach provides several benefits:</p> <ul> <li>Standards-compliant: Automatically follows HTTP/1.1 specifications</li> <li>Correct status codes: Returns appropriate status codes based on request conditions</li> <li>Declarative: Use decorators to define API behavior</li> <li>Built-in features: Conditional requests, content negotiation, and more</li> </ul>"},{"location":"guide/concepts/#how-dependencies-define-api-facts","title":"How Dependencies Define API Facts","text":"<p>The key insight of RestMachine is that dependencies define facts about your API, and the state machine uses these facts to automatically generate correct HTTP responses.</p> <p>For example:</p> <pre><code>@app.resource_exists\ndef user(path_params, database):\n    \"\"\"Define the fact: does this user exist?\"\"\"\n    user_id = path_params['user_id']\n    return database.get_user(user_id)  # None = doesn't exist\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    # If user is None, the state machine already returned 404\n    # If we reach here, user definitely exists\n    return user\n</code></pre> <p>In this example: - The <code>@app.resource_exists</code> decorator defines a dependency that answers: \"Does the resource exist?\" - If it returns <code>None</code>, the state machine automatically returns <code>404 Not Found</code> - If it returns a value, that value is cached and available to your handler - Your handler only runs when the resource exists</p>"},{"location":"guide/concepts/#state-machine-flow","title":"State Machine Flow","text":"<p>The state machine processes requests through decision points:</p> <pre><code>Request \u2192 B13: Route exists? \u2192 B12: Service available? \u2192 ...\n  \u2192 G7: Resource exists? \u2192 G3-G6: Conditional requests\n  \u2192 C3-C4: Content negotiation \u2192 Execute handler \u2192 Response\n</code></pre> <p>Each decision point can be customized with decorators:</p> Decorator Decision Effect <code>@app.resource_exists</code> Does the resource exist? Return 404 if None <code>@app.authorized</code> Is request authorized? Return 401 if False <code>@app.forbidden</code> Is access forbidden? Return 403 if True <code>@app.validates</code> Is request valid? Return 400/422 on validation error <code>@app.etag</code> What's the ETag? Enable conditional requests <code>@app.last_modified</code> When was it modified? Enable conditional requests"},{"location":"guide/concepts/#dependencies-as-facts","title":"Dependencies as Facts","text":"<p>Each decorator defines a \"fact\" that the state machine uses:</p> <pre><code># Fact: User must be authenticated\n@app.authorized\ndef check_auth(request_headers):\n    token = request_headers.get('authorization')\n    return validate_token(token)  # False = not authorized\n\n# Fact: User must have admin role\n@app.forbidden\ndef check_admin(request_headers):\n    user = get_user_from_token(request_headers.get('authorization'))\n    return user.role != 'admin'  # True = forbidden\n\n# Fact: Resource has an ETag\n@app.etag\ndef user_etag(user):\n    import hashlib\n    return f'\"{hashlib.md5(str(user).encode()).hexdigest()}\"'\n\n@app.delete('/users/{user_id}')\ndef delete_user(user, database):\n    # State machine ensures:\n    # 1. User is authenticated (401 if not)\n    # 2. User is admin (403 if not)\n    # 3. Resource exists (404 if not)\n    # 4. ETag matches (412 if not, for If-Match header)\n    # Only then does this handler run\n    database.delete(user['id'])\n    return None  # 204 No Content\n</code></pre>"},{"location":"guide/concepts/#automatic-http-responses","title":"Automatic HTTP Responses","text":"<p>The state machine automatically handles:</p> <p>Conditional Requests: <pre><code>@app.etag\ndef user_etag(user):\n    return calculate_etag(user)\n\n@app.last_modified\ndef user_last_modified(user):\n    return user['updated_at']\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    # If client sends If-None-Match with matching ETag \u2192 304 Not Modified\n    # If client sends If-Modified-Since and not modified \u2192 304 Not Modified\n    # Otherwise \u2192 200 OK with user data\n    return user\n</code></pre></p> <p>Content Negotiation: <pre><code>@app.content_renderer(\"application/json\")\ndef render_json(data):\n    import json\n    return json.dumps(data)\n\n@app.content_renderer(\"application/xml\")\ndef render_xml(data):\n    return f\"&lt;data&gt;{data}&lt;/data&gt;\"\n\n@app.get('/data')\ndef get_data():\n    return {\"message\": \"Hello\"}\n    # Client sends Accept: application/json \u2192 JSON response\n    # Client sends Accept: application/xml \u2192 XML response\n    # Client sends Accept: text/html \u2192 406 Not Acceptable\n</code></pre></p> <p>Resource Existence: <pre><code>@app.resource_exists\ndef article(path_params, database):\n    return database.get_article(path_params['article_id'])\n\n@app.get('/articles/{article_id}')\ndef get_article(article):\n    # article is None \u2192 404 already returned\n    # article exists \u2192 200 with data\n    return article\n\n@app.delete('/articles/{article_id}')\ndef delete_article(article, database):\n    # Same resource_exists dependency\n    # Automatic 404 if article doesn't exist\n    database.delete(article['id'])\n    return None\n</code></pre></p>"},{"location":"guide/concepts/#combining-concepts","title":"Combining Concepts","text":"<p>The power of RestMachine comes from combining dependency injection with the state machine:</p> <pre><code>from restmachine import RestApplication\nfrom pydantic import BaseModel\nfrom datetime import datetime\nimport hashlib\n\napp = RestApplication()\n\n# Session-scoped dependency\n@app.on_startup\ndef database():\n    return create_db_connection()\n\n# Request-scoped dependencies\n@app.dependency()\ndef current_user(request_headers, database):\n    token = request_headers.get('authorization', '').replace('Bearer ', '')\n    return database.get_user_by_token(token)\n\n# State machine facts\n@app.resource_exists\ndef article(path_params, database):\n    \"\"\"Fact: Does the article exist?\"\"\"\n    return database.get_article(path_params['article_id'])\n\n@app.authorized\ndef is_authenticated(current_user):\n    \"\"\"Fact: Is user authenticated?\"\"\"\n    return current_user is not None\n\n@app.forbidden\ndef can_edit_article(current_user, article):\n    \"\"\"Fact: Can user edit this article?\"\"\"\n    # Forbidden if user is not the author\n    return current_user['id'] != article['author_id']\n\n@app.etag\ndef article_etag(article):\n    \"\"\"Fact: What's the article's ETag?\"\"\"\n    content = f\"{article['id']}{article['updated_at']}\"\n    return f'\"{hashlib.md5(content.encode()).hexdigest()}\"'\n\n@app.last_modified\ndef article_last_modified(article):\n    \"\"\"Fact: When was article last modified?\"\"\"\n    return datetime.fromisoformat(article['updated_at'])\n\n# Validation\nclass ArticleUpdate(BaseModel):\n    title: str\n    content: str\n\n@app.validates\ndef article_update(json_body) -&gt; ArticleUpdate:\n    \"\"\"Fact: Is the request valid?\"\"\"\n    return ArticleUpdate.model_validate(json_body)\n\n# Route handler\n@app.put('/articles/{article_id}')\ndef update_article(article, article_update: ArticleUpdate, database):\n    \"\"\"\n    The state machine ensures:\n    1. Article exists (404 if not)\n    2. User is authenticated (401 if not)\n    3. User can edit article (403 if not)\n    4. Request is valid (400/422 if not)\n    5. ETag matches (412 if client sent If-Match and it doesn't match)\n    6. Article was modified (304 if client sent If-None-Match and it matches)\n\n    If all checks pass, this handler runs:\n    \"\"\"\n    article['title'] = article_update.title\n    article['content'] = article_update.content\n    article['updated_at'] = datetime.now().isoformat()\n    database.update_article(article)\n    return article\n</code></pre> <p>In this example: - Dependencies define facts about the API (auth, permissions, validation) - The state machine uses these facts to make decisions - HTTP responses are automatically generated based on these decisions - Your handler only runs when all conditions are met</p>"},{"location":"guide/concepts/#key-principles","title":"Key Principles","text":"<ol> <li>Dependencies define facts about your API (existence, authorization, validation)</li> <li>The state machine makes decisions based on these facts</li> <li>HTTP responses are automatic - you focus on business logic</li> <li>Decorators are declarative - state what your API needs, not how to check</li> <li>Everything is cacheable - dependencies run once per request</li> </ol>"},{"location":"guide/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Usage \u2192 - Learn how to use decorators in practice</li> <li>Advanced State Machine \u2192 - Deep dive into the state machine</li> <li>Lifecycle Management \u2192 - Startup and shutdown handlers</li> </ul>"},{"location":"guide/content-negotiation/","title":"Content Negotiation","text":"<p>Content negotiation allows clients to request resources in different formats (JSON, HTML, XML, etc.) using the HTTP <code>Accept</code> header. RestMachine provides built-in support for content negotiation with automatic format selection and rendering.</p>"},{"location":"guide/content-negotiation/#overview","title":"Overview","text":"<p>Content negotiation enables a single endpoint to serve multiple representations of the same resource:</p> <ul> <li>JSON for API clients</li> <li>HTML for web browsers</li> <li>XML for legacy systems</li> <li>Plain text for simple clients</li> <li>Custom formats as needed</li> </ul> <p>RestMachine selects the appropriate format based on the <code>Accept</code> header and returns <code>406 Not Acceptable</code> if the requested format isn't supported.</p>"},{"location":"guide/content-negotiation/#basic-usage","title":"Basic Usage","text":""},{"location":"guide/content-negotiation/#the-accept-header","title":"The Accept Header","text":"<p>Clients specify their preferred format using the <code>Accept</code> header:</p> <pre><code>GET /users/123\nAccept: application/json\n</code></pre> <pre><code>GET /users/123\nAccept: text/html\n</code></pre>"},{"location":"guide/content-negotiation/#default-json-rendering","title":"Default JSON Rendering","text":"<p>By default, RestMachine automatically renders responses as JSON:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    return {\"id\": user_id, \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n</code></pre> <p>Request: <pre><code>GET /users/123\nAccept: application/json\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"id\": 123, \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n</code></pre></p>"},{"location":"guide/content-negotiation/#multiple-response-formats","title":"Multiple Response Formats","text":"<p>Use the <code>@app.provides</code> decorator to support multiple content types:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.get(\"/users/{user_id}\")\ndef get_user(path_params):\n    \"\"\"Return user data in the requested format.\"\"\"\n    user_id = path_params['user_id']\n    return {\n        \"id\": user_id,\n        \"name\": \"Alice\",\n        \"email\": \"alice@example.com\"\n    }\n\n@app.provides(\"text/html\")\ndef render_user_html(get_user):\n    \"\"\"Render user as HTML.\"\"\"\n    user = get_user\n    return f\"\"\"\n    &lt;div class=\"user\"&gt;\n        &lt;h1&gt;{user['name']}&lt;/h1&gt;\n        &lt;p&gt;ID: {user['id']}&lt;/p&gt;\n        &lt;p&gt;Email: {user['email']}&lt;/p&gt;\n    &lt;/div&gt;\n    \"\"\"\n\n@app.provides(\"text/plain\")\ndef render_user_text(get_user):\n    \"\"\"Render user as plain text.\"\"\"\n    user = get_user\n    return f\"User {user['id']}: {user['name']} ({user['email']})\"\n\n@app.provides(\"application/xml\")\ndef render_user_xml(get_user):\n    \"\"\"Render user as XML.\"\"\"\n    user = get_user\n    return f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;user&gt;\n    &lt;id&gt;{user['id']}&lt;/id&gt;\n    &lt;name&gt;{user['name']}&lt;/name&gt;\n    &lt;email&gt;{user['email']}&lt;/email&gt;\n&lt;/user&gt;\"\"\"\n</code></pre>"},{"location":"guide/content-negotiation/#how-it-works","title":"How It Works","text":"<ol> <li>Route handler returns the raw data (dictionary)</li> <li>Renderers transform the data based on the <code>Accept</code> header</li> <li>RestMachine selects the appropriate renderer automatically</li> <li>Response is returned with the correct <code>Content-Type</code> header</li> </ol>"},{"location":"guide/content-negotiation/#renderer-dependency-injection","title":"Renderer Dependency Injection","text":"<p>Renderers receive the route handler's return value as a dependency. The parameter name must match the handler function name:</p> <pre><code>@app.get(\"/data\")\ndef get_data():  # Handler name is \"get_data\"\n    return {\"value\": 42}\n\n@app.provides(\"text/html\")\ndef render_html(get_data):  # Parameter name matches handler\n    data = get_data\n    return f\"&lt;p&gt;Value: {data['value']}&lt;/p&gt;\"\n</code></pre>"},{"location":"guide/content-negotiation/#quality-values","title":"Quality Values","text":"<p>Clients can specify format preferences using quality values (<code>q</code>):</p> <pre><code>Accept: text/html;q=0.9, application/json;q=1.0, text/plain;q=0.8\n</code></pre> <p>RestMachine selects the format with the highest quality value that's supported:</p> <pre><code>app = RestApplication()\n\n@app.get(\"/resource\")\ndef get_resource():\n    return {\"message\": \"Hello\"}\n\n@app.provides(\"text/html\")\ndef render_html(get_resource):\n    return f\"&lt;h1&gt;{get_resource['message']}&lt;/h1&gt;\"\n\n@app.provides(\"text/plain\")\ndef render_text(get_resource):\n    return get_resource['message']\n</code></pre> <p>Request with quality values: <pre><code>GET /resource\nAccept: text/html;q=0.9, application/json;q=1.0, text/plain;q=0.8\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"message\": \"Hello\"}\n</code></pre></p> <p>RestMachine chose JSON because it has the highest quality value (<code>q=1.0</code>).</p>"},{"location":"guide/content-negotiation/#wildcard-accept-headers","title":"Wildcard Accept Headers","text":""},{"location":"guide/content-negotiation/#accept-all","title":"Accept All (<code>*/*</code>)","text":"<p>The <code>*/*</code> wildcard accepts any content type:</p> <pre><code>GET /resource\nAccept: */*\n</code></pre> <p>RestMachine will return the first available renderer (typically the route handler's default JSON response).</p>"},{"location":"guide/content-negotiation/#partial-wildcards-not-supported","title":"Partial Wildcards Not Supported","text":"<p>RestMachine does not support partial wildcards like <code>text/*</code>:</p> <pre><code>GET /resource\nAccept: text/*\n</code></pre> <p>Response: <pre><code>HTTP/1.1 406 Not Acceptable\n</code></pre></p>"},{"location":"guide/content-negotiation/#multiple-accept-types","title":"Multiple Accept Types","text":"<p>When multiple types are specified, RestMachine selects the first available one:</p> <pre><code>Accept: application/pdf, text/html, application/json\n</code></pre> <p>If <code>application/pdf</code> isn't supported but <code>text/html</code> is, RestMachine will return HTML.</p>"},{"location":"guide/content-negotiation/#406-not-acceptable","title":"406 Not Acceptable","text":"<p>When the client requests an unsupported format, RestMachine returns <code>406 Not Acceptable</code>:</p> <pre><code>app = RestApplication()\n\n@app.get(\"/data\")\ndef get_data():\n    return {\"value\": 123}\n\n@app.provides(\"text/html\")\ndef render_html(get_data):\n    return f\"&lt;p&gt;{get_data['value']}&lt;/p&gt;\"\n</code></pre> <p>Request: <pre><code>GET /data\nAccept: application/pdf\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 406 Not Acceptable\nContent-Type: text/plain\n\nNot Acceptable\n</code></pre></p>"},{"location":"guide/content-negotiation/#using-templates","title":"Using Templates","text":"<p>Combine content negotiation with Jinja2 templates for rich HTML rendering:</p> <pre><code>from restmachine import RestApplication, render\n\napp = RestApplication()\n\n@app.get(\"/users/{user_id}\")\ndef get_user(path_params):\n    user_id = path_params['user_id']\n    return {\n        \"id\": user_id,\n        \"name\": \"Alice\",\n        \"email\": \"alice@example.com\",\n        \"bio\": \"Software engineer\"\n    }\n\n@app.provides(\"text/html\")\ndef render_user_html(get_user):\n    \"\"\"Render user with a template.\"\"\"\n    return render(\n        template=\"user.html\",\n        package=\"templates\",\n        user=get_user\n    )\n</code></pre> <p>templates/user.html: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{{ user.name }}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"user-profile\"&gt;\n        &lt;h1&gt;{{ user.name }}&lt;/h1&gt;\n        &lt;p class=\"user-id\"&gt;ID: {{ user.id }}&lt;/p&gt;\n        &lt;p class=\"user-email\"&gt;Email: {{ user.email }}&lt;/p&gt;\n        &lt;p class=\"user-bio\"&gt;{{ user.bio }}&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>Request: <pre><code>GET /users/123\nAccept: text/html\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 200 OK\nContent-Type: text/html\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Alice&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"user-profile\"&gt;\n        &lt;h1&gt;Alice&lt;/h1&gt;\n        &lt;p class=\"user-id\"&gt;ID: 123&lt;/p&gt;\n        &lt;p class=\"user-email\"&gt;Email: alice@example.com&lt;/p&gt;\n        &lt;p class=\"user-bio\"&gt;Software engineer&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"guide/content-negotiation/#complete-example-blog-api","title":"Complete Example: Blog API","text":"<pre><code>from restmachine import RestApplication, render\nfrom datetime import datetime\n\napp = RestApplication()\n\n# Database initialized at startup\n@app.on_startup\ndef database():\n    return {\n        \"posts\": {\n            1: {\n                \"id\": 1,\n                \"title\": \"Getting Started with RestMachine\",\n                \"content\": \"RestMachine is a modern REST framework...\",\n                \"author\": \"Alice\",\n                \"created_at\": datetime(2024, 1, 15)\n            },\n            2: {\n                \"id\": 2,\n                \"title\": \"Content Negotiation Best Practices\",\n                \"content\": \"Content negotiation allows...\",\n                \"author\": \"Bob\",\n                \"created_at\": datetime(2024, 1, 20)\n            }\n        }\n    }\n\n@app.get(\"/posts\")\ndef list_posts(database):\n    \"\"\"List all blog posts.\"\"\"\n    return list(database[\"posts\"].values())\n\n@app.provides(\"text/html\")\ndef render_posts_html(list_posts):\n    \"\"\"Render posts list as HTML.\"\"\"\n    posts_list = list_posts  # list_posts is the data returned from the route handler\n    return render(\n        inline=\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;&lt;title&gt;Blog Posts&lt;/title&gt;&lt;/head&gt;\n        &lt;body&gt;\n            &lt;h1&gt;Blog Posts&lt;/h1&gt;\n            &lt;ul&gt;\n            {% for post in posts %}\n                &lt;li&gt;\n                    &lt;h2&gt;{{ post.title }}&lt;/h2&gt;\n                    &lt;p&gt;by {{ post.author }} on {{ post.created_at.strftime('%Y-%m-%d') }}&lt;/p&gt;\n                    &lt;p&gt;{{ post.content[:100] }}...&lt;/p&gt;\n                &lt;/li&gt;\n            {% endfor %}\n            &lt;/ul&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\",\n        posts=posts_list\n    )\n\n@app.provides(\"text/plain\")\ndef render_posts_text(list_posts):\n    \"\"\"Render posts list as plain text.\"\"\"\n    posts_list = list_posts\n    lines = [\"BLOG POSTS\\n\" + \"=\"*50 + \"\\n\"]\n    for post in posts_list:\n        lines.append(f\"{post['title']}\")\n        lines.append(f\"By {post['author']} on {post['created_at'].strftime('%Y-%m-%d')}\")\n        lines.append(f\"{post['content'][:100]}...\")\n        lines.append(\"-\" * 50)\n    return \"\\n\".join(lines)\n\n@app.provides(\"application/xml\")\ndef render_posts_xml(list_posts):\n    \"\"\"Render posts list as XML.\"\"\"\n    posts_list = list_posts\n    xml_posts = []\n    for post in posts_list:\n        xml_posts.append(f\"\"\"\n        &lt;post&gt;\n            &lt;id&gt;{post['id']}&lt;/id&gt;\n            &lt;title&gt;{post['title']}&lt;/title&gt;\n            &lt;author&gt;{post['author']}&lt;/author&gt;\n            &lt;content&gt;{post['content']}&lt;/content&gt;\n            &lt;created_at&gt;{post['created_at'].isoformat()}&lt;/created_at&gt;\n        &lt;/post&gt;\n        \"\"\")\n\n    return f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;posts&gt;\n    {''.join(xml_posts)}\n&lt;/posts&gt;\"\"\"\n\n@app.resource_exists\ndef post(path_params, database):\n    \"\"\"Get post by ID, returns None if not found.\"\"\"\n    post_id = int(path_params['post_id'])\n    return database[\"posts\"].get(post_id)\n\n@app.get(\"/posts/{post_id}\")\ndef get_post(post):\n    \"\"\"Get a single blog post. 404 handled automatically.\"\"\"\n    return post\n\n@app.provides(\"text/html\")\ndef render_post_html(get_post):\n    \"\"\"Render single post as HTML.\"\"\"\n    post = get_post  # get_post is the data returned from the route handler\n    return render(\n        inline=\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;&lt;title&gt;{{ post.title }}&lt;/title&gt;&lt;/head&gt;\n        &lt;body&gt;\n            &lt;article&gt;\n                &lt;h1&gt;{{ post.title }}&lt;/h1&gt;\n                &lt;p class=\"meta\"&gt;By {{ post.author }} on {{ post.created_at.strftime('%Y-%m-%d') }}&lt;/p&gt;\n                &lt;div class=\"content\"&gt;{{ post.content }}&lt;/div&gt;\n            &lt;/article&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\",\n        post=post\n    )\n</code></pre>"},{"location":"guide/content-negotiation/#testing-content-negotiation","title":"Testing Content Negotiation","text":""},{"location":"guide/content-negotiation/#testing-different-formats","title":"Testing Different Formats","text":"<pre><code>from restmachine import Request, HTTPMethod\nimport json\n\ndef test_json_response():\n    app = create_blog_app()\n\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/posts/1\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    assert response.headers.get(\"Content-Type\") == \"application/json\"\n    data = json.loads(response.body)\n    assert data[\"title\"] == \"Getting Started with RestMachine\"\n\ndef test_html_response():\n    app = create_blog_app()\n\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/posts/1\",\n        headers={\"Accept\": \"text/html\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    assert response.headers.get(\"Content-Type\") == \"text/html\"\n    assert \"&lt;h1&gt;Getting Started with RestMachine&lt;/h1&gt;\" in response.body\n\ndef test_xml_response():\n    app = create_blog_app()\n\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/posts/1\",\n        headers={\"Accept\": \"application/xml\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    assert response.headers.get(\"Content-Type\") == \"application/xml\"\n    assert \"&lt;title&gt;Getting Started with RestMachine&lt;/title&gt;\" in response.body\n</code></pre>"},{"location":"guide/content-negotiation/#testing-quality-values","title":"Testing Quality Values","text":"<pre><code>def test_quality_values():\n    app = create_blog_app()\n\n    # Prefer JSON over HTML\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/posts/1\",\n        headers={\"Accept\": \"text/html;q=0.9, application/json;q=1.0\"}\n    )\n    response = app.execute(request)\n\n    assert response.headers.get(\"Content-Type\") == \"application/json\"\n</code></pre>"},{"location":"guide/content-negotiation/#testing-unsupported-formats","title":"Testing Unsupported Formats","text":"<pre><code>def test_unsupported_format():\n    app = create_blog_app()\n\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/posts/1\",\n        headers={\"Accept\": \"application/pdf\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 406  # Not Acceptable\n</code></pre>"},{"location":"guide/content-negotiation/#best-practices","title":"Best Practices","text":""},{"location":"guide/content-negotiation/#1-keep-renderers-simple","title":"1. Keep Renderers Simple","text":"<p>Renderers should focus on formatting, not business logic:</p> <pre><code># Good\n@app.provides(\"text/html\")\ndef render_html(get_user):\n    user = get_user\n    return f\"&lt;h1&gt;{user['name']}&lt;/h1&gt;\"\n\n# Bad - doing business logic in renderer\n@app.provides(\"text/html\")\ndef render_html_bad(request):\n    user = database.get_user(request.path_params['user_id'])\n    user['processed'] = True  # Don't modify data in renderer\n    return f\"&lt;h1&gt;{user['name']}&lt;/h1&gt;\"\n</code></pre>"},{"location":"guide/content-negotiation/#2-use-templates-for-complex-html","title":"2. Use Templates for Complex HTML","text":"<p>For anything beyond simple HTML, use templates:</p> <pre><code>@app.provides(\"text/html\")\ndef render_html(get_resource):\n    return render(\n        template=\"resource.html\",\n        package=\"templates\",\n        resource=get_resource\n    )\n</code></pre>"},{"location":"guide/content-negotiation/#3-provide-json-as-default","title":"3. Provide JSON as Default","text":"<p>Always support JSON for API clients:</p> <pre><code>@app.get(\"/resource\")\ndef get_resource():\n    return {\"data\": \"value\"}  # Automatically JSON\n\n@app.provides(\"text/html\")  # Add HTML as an option\ndef render_html(get_resource):\n    return f\"&lt;p&gt;{get_resource['data']}&lt;/p&gt;\"\n</code></pre>"},{"location":"guide/content-negotiation/#4-handle-missing-resources-consistently","title":"4. Handle Missing Resources Consistently","text":"<p>Return appropriate status codes in all renderers:</p> <pre><code>@app.get(\"/posts/{post_id}\")\ndef get_post(post_id: int):\n    post = posts.get(post_id)\n    if not post:\n        return None, 404\n    return post\n\n@app.provides(\"text/html\")\ndef render_post_html(get_post):\n    post = get_post\n    if not post:\n        return \"&lt;h1&gt;404 - Post Not Found&lt;/h1&gt;\", 404\n    return f\"&lt;h1&gt;{post['title']}&lt;/h1&gt;\"\n</code></pre>"},{"location":"guide/content-negotiation/#5-document-supported-formats","title":"5. Document Supported Formats","text":"<p>Make it clear which formats your API supports:</p> <pre><code>@app.get(\"/api/docs\")\ndef api_docs():\n    \"\"\"\n    API Documentation\n\n    Supported formats:\n    - application/json (default)\n    - text/html (web interface)\n    - application/xml (legacy systems)\n    \"\"\"\n    return {\n        \"supported_formats\": [\n            \"application/json\",\n            \"text/html\",\n            \"application/xml\"\n        ]\n    }\n</code></pre>"},{"location":"guide/content-negotiation/#content-types-reference","title":"Content Types Reference","text":"Content Type Common Use Case Example <code>application/json</code> API responses (default) <code>{\"id\": 1, \"name\": \"Alice\"}</code> <code>text/html</code> Web pages <code>&lt;h1&gt;Alice&lt;/h1&gt;</code> <code>text/plain</code> Simple text <code>User: Alice</code> <code>application/xml</code> Legacy systems <code>&lt;user&gt;&lt;name&gt;Alice&lt;/name&gt;&lt;/user&gt;</code> <code>text/csv</code> Data export <code>id,name\\n1,Alice</code> <code>application/pdf</code> Documents Binary PDF data"},{"location":"guide/content-negotiation/#http-status-codes","title":"HTTP Status Codes","text":"Status Meaning When Used 200 OK Success Requested format is available and returned 406 Not Acceptable Unsupported format Client requested a format that's not supported"},{"location":"guide/content-negotiation/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Template Rendering for advanced HTML generation</li> <li>Explore Error Handling for custom error formats</li> <li>Read about Testing to test multiple content types</li> </ul>"},{"location":"guide/cors/","title":"CORS (Cross-Origin Resource Sharing)","text":"<p>RestMachine provides built-in CORS support with smart defaults, automatic method detection, and flexible configuration at app, router, or route level.</p>"},{"location":"guide/cors/#overview","title":"Overview","text":"<p>CORS is a browser security feature that controls which web applications can access your API from different origins. RestMachine handles:</p> <ul> <li>Automatic preflight responses - OPTIONS requests with proper CORS headers</li> <li>Method auto-detection - No need to manually specify allowed methods</li> <li>Smart defaults - Sensible allow/expose headers out of the box</li> <li>Three-tier configuration - App-level, router-level, or route-level</li> <li>Security validation - Prevents unsafe wildcard + credentials combinations</li> </ul>"},{"location":"guide/cors/#quick-start","title":"Quick Start","text":""},{"location":"guide/cors/#basic-cors-setup","title":"Basic CORS Setup","text":"<p>The simplest CORS configuration - just specify allowed origins:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n# Enable CORS for your frontend\napp.cors(origins=[\"https://app.example.com\"])\n\n@app.get(\"/api/data\")\ndef get_data():\n    return {\"message\": \"Hello from API\"}\n\n# That's it! Methods are auto-detected, headers use smart defaults\n</code></pre> <p>When a browser makes a request from <code>https://app.example.com</code>:</p> <ol> <li>Preflight (OPTIONS): RestMachine automatically responds with appropriate CORS headers</li> <li>Actual Request: CORS headers are added to your response</li> <li>Methods: Auto-detected from registered routes (GET, OPTIONS in this example)</li> </ol>"},{"location":"guide/cors/#configuration-levels","title":"Configuration Levels","text":"<p>RestMachine supports CORS configuration at three levels with inheritance:</p>"},{"location":"guide/cors/#1-app-level-global","title":"1. App-Level (Global)","text":"<p>Apply CORS to all routes in the application:</p> <pre><code>app = RestApplication()\n\n# All routes will have these CORS settings\napp.cors(\n    origins=[\"https://app.example.com\", \"https://admin.example.com\"],\n    credentials=True,\n    max_age=86400  # 24 hours\n)\n\n@app.get(\"/api/users\")\ndef list_users():\n    return {\"users\": [...]}\n\n@app.get(\"/api/posts\")\ndef list_posts():\n    return {\"posts\": [...]}\n</code></pre>"},{"location":"guide/cors/#2-router-level","title":"2. Router-Level","text":"<p>Apply CORS to all routes in a specific router:</p> <pre><code>from restmachine import Router\n\napp = RestApplication()\n\n# Public API router - allow all origins\npublic_api = Router()\npublic_api.cors(origins=\"*\")\n\n@public_api.get(\"/status\")\ndef get_status():\n    return {\"status\": \"ok\"}\n\n# Admin API router - restrict origins\nadmin_api = Router()\nadmin_api.cors(\n    origins=[\"https://admin.example.com\"],\n    credentials=True\n)\n\n@admin_api.get(\"/dashboard\")\ndef get_dashboard():\n    return {\"stats\": {...}}\n\napp.mount(\"/api/public\", public_api)\napp.mount(\"/api/admin\", admin_api)\n</code></pre>"},{"location":"guide/cors/#3-route-level-most-specific","title":"3. Route-Level (Most Specific)","text":"<p>Override CORS for specific endpoints:</p> <pre><code>app = RestApplication()\n\n# Default CORS for most routes\napp.cors(origins=[\"https://app.example.com\"])\n\n@app.get(\"/api/data\")\ndef get_data():\n    # Uses app-level CORS\n    return {\"data\": \"value\"}\n\n@app.post(\"/api/webhook\")\n@app.cors(origins=[\"https://external-service.com\"])\ndef webhook():\n    # Overrides app-level CORS for this endpoint only\n    return {\"received\": True}\n</code></pre> <p>Priority: Route-level &gt; Router-level &gt; App-level (most specific wins)</p>"},{"location":"guide/cors/#auto-detection-of-methods","title":"Auto-Detection of Methods","text":"<p>RestMachine automatically detects allowed methods from your registered routes:</p> <pre><code>app = RestApplication()\napp.cors(origins=[\"https://app.example.com\"])\n\n@app.get(\"/users/{id}\")\ndef get_user(id: str):\n    return {\"id\": id}\n\n@app.put(\"/users/{id}\")\ndef update_user(id: str, json_body):\n    return {\"id\": id, **json_body}\n\n@app.delete(\"/users/{id}\")\ndef delete_user(id: str):\n    return None\n\n# OPTIONS /users/123 automatically returns:\n# Allow: DELETE, GET, OPTIONS, PUT\n# Access-Control-Allow-Methods: DELETE, GET, OPTIONS, PUT\n</code></pre> <p>No need to manually specify methods - they're inferred from your routes!</p>"},{"location":"guide/cors/#manual-method-override","title":"Manual Method Override","text":"<p>Override auto-detection when needed:</p> <pre><code>@app.get(\"/admin/users\")\n@app.post(\"/admin/users\")\n@app.delete(\"/admin/users\")\n@app.cors(\n    origins=[\"https://admin.example.com\"],\n    methods=[\"GET\", \"POST\"]  # Don't expose DELETE via CORS\n)\ndef admin_users():\n    return {\"users\": [...]}\n</code></pre>"},{"location":"guide/cors/#configuration-options","title":"Configuration Options","text":""},{"location":"guide/cors/#origins","title":"Origins","text":"<p>Specify which origins can access your API:</p> <pre><code># Single origin\napp.cors(origins=\"https://app.example.com\")\n\n# Multiple origins\napp.cors(origins=[\n    \"https://app.example.com\",\n    \"https://admin.example.com\",\n    \"http://localhost:3000\"  # Development\n])\n\n# Allow all origins (use cautiously!)\napp.cors(origins=\"*\")\n</code></pre>"},{"location":"guide/cors/#credentials","title":"Credentials","text":"<p>Allow cookies and authorization headers:</p> <pre><code>app.cors(\n    origins=[\"https://app.example.com\"],\n    credentials=True  # Allows cookies, Authorization header\n)\n\n# Security note: Cannot use credentials=True with origins=\"*\"\n# This will raise ValueError - use specific origins instead\n</code></pre>"},{"location":"guide/cors/#development-with-credentials-origin-reflection","title":"Development with Credentials (Origin Reflection)","text":"<p>For development environments where you need credentials support from any origin (e.g., testing from multiple local ports), use <code>reflect_any_origin</code>:</p> <pre><code>import os\n\napp = RestApplication()\n\n# Development only: reflect any origin with credentials\nif os.getenv(\"ENV\") == \"development\":\n    app.cors(\n        origins=\"*\",\n        credentials=True,\n        reflect_any_origin=True  # WARNING: Development only!\n    )\nelse:\n    # Production: use explicit origins\n    app.cors(\n        origins=[\"https://app.example.com\"],\n        credentials=True\n    )\n</code></pre> <p>How it works: When <code>reflect_any_origin=True</code>, the framework reflects the request's <code>Origin</code> header in the <code>Access-Control-Allow-Origin</code> response header instead of sending <code>*</code>. This allows credentials to work while accepting any origin.</p> <p>\u26a0\ufe0f WARNING: Only use <code>reflect_any_origin=True</code> in development! In production, always specify explicit allowed origins for security.</p> <p>Use cases: - Local development with multiple ports (e.g., <code>http://localhost:3000</code>, <code>http://localhost:3001</code>) - Testing mobile apps with various emulator origins - Development environments where frontend origins frequently change</p>"},{"location":"guide/cors/#request-headers","title":"Request Headers","text":"<p>Control which headers clients can send:</p> <pre><code>app.cors(\n    origins=[\"https://app.example.com\"],\n    allow_headers=[\n        \"Content-Type\",\n        \"Authorization\",\n        \"X-API-Key\",\n        \"X-Request-ID\"\n    ]\n)\n\n# Default allow_headers (if not specified):\n# - Accept\n# - Accept-Language\n# - Content-Type\n# - Content-Language\n# - Authorization\n# - X-Requested-With\n</code></pre>"},{"location":"guide/cors/#response-headers","title":"Response Headers","text":"<p>Control which headers JavaScript can read:</p> <pre><code>app.cors(\n    origins=[\"https://app.example.com\"],\n    expose_headers=[\n        \"X-Request-ID\",\n        \"X-Rate-Limit-Remaining\",\n        \"X-Total-Count\"\n    ]\n)\n\n# Default expose_headers (if not specified):\n# - Content-Length\n# - Content-Type\n# - ETag\n# - Location\n# - X-Request-ID\n</code></pre>"},{"location":"guide/cors/#preflight-cache","title":"Preflight Cache","text":"<p>Control how long browsers cache preflight responses:</p> <pre><code>app.cors(\n    origins=[\"https://app.example.com\"],\n    max_age=86400  # 24 hours (default)\n)\n\n# For development (short cache)\napp.cors(origins=\"*\", max_age=300)  # 5 minutes\n\n# For production (long cache)\napp.cors(origins=[...], max_age=604800)  # 7 days\n</code></pre>"},{"location":"guide/cors/#complete-example","title":"Complete Example","text":"<p>Here's a production-ready CORS setup:</p> <pre><code>from restmachine import RestApplication, Router, Response\n\napp = RestApplication()\n\n# App-level CORS for most routes\napp.cors(\n    origins=[\n        \"https://app.example.com\",\n        \"https://www.example.com\",\n        \"http://localhost:3000\"  # Development\n    ],\n    credentials=True,\n    max_age=86400\n)\n\n# Public API router (no credentials)\npublic_api = Router()\npublic_api.cors(\n    origins=\"*\",\n    credentials=False,\n    max_age=3600\n)\n\n@public_api.get(\"/status\")\ndef api_status():\n    \"\"\"Public status endpoint.\"\"\"\n    return {\"status\": \"operational\", \"version\": \"1.0\"}\n\n@public_api.get(\"/docs\")\ndef api_docs():\n    \"\"\"Public API documentation.\"\"\"\n    return {\"endpoints\": [...]}\n\napp.mount(\"/api/v1/public\", public_api)\n\n# Protected routes (use app-level CORS with credentials)\n@app.get(\"/api/v1/user/profile\")\ndef get_profile(request):\n    \"\"\"User profile - requires authentication.\"\"\"\n    auth = request.headers.get(\"Authorization\")\n    if not auth:\n        return Response(401, {\"error\": \"Unauthorized\"})\n\n    return {\"user\": \"alice\", \"email\": \"alice@example.com\"}\n\n@app.post(\"/api/v1/user/settings\")\ndef update_settings(json_body):\n    \"\"\"Update user settings.\"\"\"\n    return {\"updated\": True, **json_body}\n\n# Webhook endpoint (different origin)\n@app.post(\"/api/v1/webhooks/github\")\n@app.cors(\n    origins=[\"https://github.com\"],\n    methods=[\"POST\"]\n)\ndef github_webhook(json_body):\n    \"\"\"GitHub webhook handler.\"\"\"\n    return {\"received\": True}\n\n# ASGI app\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n</code></pre>"},{"location":"guide/cors/#how-cors-works","title":"How CORS Works","text":""},{"location":"guide/cors/#preflight-requests","title":"Preflight Requests","text":"<p>When a browser makes a \"complex\" request (POST, PUT, DELETE, or custom headers), it first sends a preflight:</p> <pre><code>OPTIONS /api/users HTTP/1.1\nHost: api.example.com\nOrigin: https://app.example.com\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Content-Type, Authorization\n</code></pre> <p>RestMachine automatically responds:</p> <pre><code>HTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://app.example.com\nAccess-Control-Allow-Methods: GET, POST, OPTIONS\nAccess-Control-Allow-Headers: Content-Type, Authorization\nAccess-Control-Allow-Credentials: true\nAccess-Control-Max-Age: 86400\nAllow: GET, POST, OPTIONS\n</code></pre>"},{"location":"guide/cors/#actual-requests","title":"Actual Requests","text":"<p>After successful preflight, the browser makes the actual request:</p> <pre><code>POST /api/users HTTP/1.1\nHost: api.example.com\nOrigin: https://app.example.com\nContent-Type: application/json\nAuthorization: Bearer abc123\n\n{\"name\": \"Alice\"}\n</code></pre> <p>RestMachine adds CORS headers to your response:</p> <pre><code>HTTP/1.1 201 Created\nAccess-Control-Allow-Origin: https://app.example.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: X-Request-ID\nVary: Origin\nContent-Type: application/json\n\n{\"id\": \"123\", \"name\": \"Alice\"}\n</code></pre>"},{"location":"guide/cors/#security-considerations","title":"Security Considerations","text":""},{"location":"guide/cors/#validate-origins","title":"Validate Origins","text":"<p>Always use specific origins in production:</p> <pre><code># \u2705 Good: Specific origins\napp.cors(origins=[\n    \"https://app.example.com\",\n    \"https://admin.example.com\"\n])\n\n# \u26a0\ufe0f  Use cautiously: Wildcard (no credentials allowed)\napp.cors(origins=\"*\", credentials=False)\n\n# \u274c Invalid: Wildcard with credentials\napp.cors(origins=\"*\", credentials=True)  # Raises ValueError\n</code></pre>"},{"location":"guide/cors/#credentials-and-wildcards","title":"Credentials and Wildcards","text":"<p>You cannot use <code>credentials=True</code> with <code>origins=\"*\"</code> - this is a security requirement:</p> <pre><code># This will raise ValueError\ntry:\n    app.cors(origins=\"*\", credentials=True)\nexcept ValueError as e:\n    print(e)  # \"CORS: Cannot use wildcard origin '*' with credentials=True...\"\n</code></pre> <p>Exception for development: You can bypass this restriction using <code>reflect_any_origin=True</code>, which reflects the request's origin instead of sending <code>*</code>:</p> <pre><code># This is allowed for development\napp.cors(\n    origins=\"*\",\n    credentials=True,\n    reflect_any_origin=True  # Reflects origin instead of sending \"*\"\n)\n</code></pre> <p>\u26a0\ufe0f Production warning: Never use <code>reflect_any_origin=True</code> in production! It allows any origin to access your API with credentials, which is a security risk. Always use explicit origins in production.</p>"},{"location":"guide/cors/#origin-validation","title":"Origin Validation","text":"<p>RestMachine checks the <code>Origin</code> header against your configuration:</p> <pre><code>app.cors(origins=[\"https://app.example.com\"])\n\n# Request from https://app.example.com\n# \u2705 CORS headers added\n\n# Request from https://evil.com\n# \u274c No CORS headers added (browser blocks response)\n</code></pre>"},{"location":"guide/cors/#testing-cors","title":"Testing CORS","text":""},{"location":"guide/cors/#manual-testing-with-curl","title":"Manual Testing with curl","text":"<p>Test preflight request:</p> <pre><code>curl -X OPTIONS http://localhost:8000/api/users \\\n  -H \"Origin: https://app.example.com\" \\\n  -H \"Access-Control-Request-Method: POST\" \\\n  -H \"Access-Control-Request-Headers: Content-Type\" \\\n  -v\n</code></pre> <p>Test actual request:</p> <pre><code>curl -X POST http://localhost:8000/api/users \\\n  -H \"Origin: https://app.example.com\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"Alice\"}' \\\n  -v\n</code></pre>"},{"location":"guide/cors/#automated-testing","title":"Automated Testing","text":"<pre><code>from restmachine import Request, HTTPMethod\n\ndef test_cors_preflight():\n    \"\"\"Test CORS preflight request.\"\"\"\n    app = RestApplication()\n    app.cors(origins=[\"https://app.example.com\"])\n\n    @app.post(\"/api/data\")\n    def create_data(json_body):\n        return {\"created\": True}\n\n    # Preflight request\n    request = Request(\n        method=HTTPMethod.OPTIONS,\n        path=\"/api/data\",\n        headers={\n            \"Origin\": \"https://app.example.com\",\n            \"Access-Control-Request-Method\": \"POST\"\n        }\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 204\n    assert response.headers[\"Access-Control-Allow-Origin\"] == \"https://app.example.com\"\n    assert \"POST\" in response.headers[\"Access-Control-Allow-Methods\"]\n\ndef test_cors_actual_request():\n    \"\"\"Test CORS on actual request.\"\"\"\n    app = RestApplication()\n    app.cors(origins=[\"https://app.example.com\"], credentials=True)\n\n    @app.get(\"/api/data\")\n    def get_data():\n        return {\"data\": \"value\"}\n\n    # Actual request\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/api/data\",\n        headers={\"Origin\": \"https://app.example.com\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    assert response.headers[\"Access-Control-Allow-Origin\"] == \"https://app.example.com\"\n    assert response.headers[\"Access-Control-Allow-Credentials\"] == \"true\"\n    assert \"Origin\" in response.headers[\"Vary\"]\n</code></pre>"},{"location":"guide/cors/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/cors/#development-vs-production","title":"Development vs Production","text":"<pre><code>import os\n\napp = RestApplication()\n\n# Different CORS config for dev/prod\nif os.getenv(\"ENV\") == \"production\":\n    app.cors(\n        origins=[\n            \"https://app.example.com\",\n            \"https://www.example.com\"\n        ],\n        credentials=True,\n        max_age=86400\n    )\nelse:\n    # Permissive for development (with credentials support)\n    app.cors(\n        origins=\"*\",\n        credentials=True,\n        reflect_any_origin=True,  # Reflect origin for credentials\n        max_age=300\n    )\n</code></pre>"},{"location":"guide/cors/#multiple-frontends","title":"Multiple Frontends","text":"<pre><code>app = RestApplication()\n\n# Main web app\nweb_origins = [\n    \"https://app.example.com\",\n    \"https://www.example.com\"\n]\n\n# Mobile app\nmobile_origins = [\n    \"capacitor://localhost\",  # Capacitor\n    \"ionic://localhost\"       # Ionic\n]\n\n# Admin dashboard\nadmin_origins = [\n    \"https://admin.example.com\"\n]\n\n# Combine all allowed origins\nall_origins = web_origins + mobile_origins + admin_origins\n\napp.cors(\n    origins=all_origins,\n    credentials=True\n)\n</code></pre>"},{"location":"guide/cors/#api-gateway-pattern","title":"API Gateway Pattern","text":"<pre><code># Public gateway (no auth)\npublic = Router()\npublic.cors(origins=\"*\", max_age=3600)\n\n@public.get(\"/health\")\ndef health():\n    return {\"healthy\": True}\n\n# Authenticated API\napi = Router()\napi.cors(\n    origins=[\"https://app.example.com\"],\n    credentials=True\n)\n\n@api.get(\"/data\")\ndef get_data(request):\n    # Requires auth\n    return {\"data\": [...]}\n\napp.mount(\"/public\", public)\napp.mount(\"/api\", api)\n</code></pre>"},{"location":"guide/cors/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/cors/#cors-headers-not-appearing","title":"CORS Headers Not Appearing","text":"<p>Problem: No CORS headers in response</p> <p>Solutions: 1. Ensure <code>Origin</code> header is present in request 2. Check origin is in allowed list 3. Verify CORS is configured (<code>app.cors(...)</code> called)</p> <pre><code># Check your configuration\napp.cors(origins=[\"https://app.example.com\"])\n\n# Request must include Origin header\n# curl -H \"Origin: https://app.example.com\" ...\n</code></pre>"},{"location":"guide/cors/#preflight-failures","title":"Preflight Failures","text":"<p>Problem: OPTIONS requests failing</p> <p>Solutions: 1. Check if route exists for the path 2. Verify allowed methods include requested method 3. Ensure headers are allowed</p> <pre><code># Make sure route exists\n@app.post(\"/api/data\")  # \u2705 Route registered\ndef create_data():\n    pass\n\n# Allow required headers\napp.cors(\n    origins=[...],\n    allow_headers=[\"Content-Type\", \"Authorization\"]  # \u2705 Headers allowed\n)\n</code></pre>"},{"location":"guide/cors/#credentials-not-working","title":"Credentials Not Working","text":"<p>Problem: Cookies not sent with CORS requests</p> <p>Solutions: 1. Set <code>credentials=True</code> in CORS config 2. Use specific origins (not wildcard) 3. Frontend must use <code>credentials: 'include'</code></p> <pre><code># Backend\napp.cors(\n    origins=[\"https://app.example.com\"],  # \u2705 Specific origin\n    credentials=True                       # \u2705 Credentials enabled\n)\n\n# Frontend (JavaScript)\nfetch('https://api.example.com/data', {\n    credentials: 'include'  // \u2705 Include cookies\n})\n</code></pre>"},{"location":"guide/cors/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use Specific Origins in Production <pre><code># \u2705 Good\napp.cors(origins=[\"https://app.example.com\"])\n\n# \u26a0\ufe0f  Only for development\napp.cors(origins=\"*\")\n</code></pre></p> </li> <li> <p>Enable Credentials When Needed <pre><code>app.cors(\n    origins=[\"https://app.example.com\"],\n    credentials=True  # For cookies, auth headers\n)\n</code></pre></p> </li> <li> <p>Set Appropriate Cache Duration <pre><code># Development: short cache\napp.cors(origins=[...], max_age=300)\n\n# Production: longer cache\napp.cors(origins=[...], max_age=86400)\n</code></pre></p> </li> <li> <p>Limit Exposed Headers <pre><code># Only expose what clients need\napp.cors(\n    origins=[...],\n    expose_headers=[\"X-Request-ID\", \"X-Total-Count\"]\n)\n</code></pre></p> </li> <li> <p>Use Router-Level CORS for Organization <pre><code>public_api = Router()\npublic_api.cors(origins=\"*\")\n\nprivate_api = Router()\nprivate_api.cors(origins=[...], credentials=True)\n</code></pre></p> </li> </ol>"},{"location":"guide/cors/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication \u2192 - Use CORS with authentication</li> <li>Multi-Value Headers \u2192 - Advanced header handling</li> <li>Testing \u2192 - Test CORS configurations</li> <li>Deployment \u2192 - Deploy with CORS enabled</li> </ul>"},{"location":"guide/csp/","title":"Content Security Policy (CSP)","text":"<p>RestMachine provides built-in Content Security Policy support with auto-quoting, nonce generation, and flexible configuration at app, router, or route level.</p>"},{"location":"guide/csp/#overview","title":"Overview","text":"<p>CSP is a powerful security feature that helps prevent cross-site scripting (XSS) and other code injection attacks by controlling which resources browsers can load. RestMachine handles:</p> <ul> <li>Auto-quoting - Keywords like <code>'self'</code> and <code>'unsafe-inline'</code> are automatically quoted</li> <li>Nonce generation - Unique nonces for inline scripts/styles</li> <li>Preset policies - Pre-configured security levels (STRICT, BASIC, RELAXED)</li> <li>Dynamic sources - Callable functions for runtime CSP configuration</li> <li>Report-only mode - Test policies without blocking resources</li> <li>Three-tier configuration - App-level, router-level, or route-level</li> </ul>"},{"location":"guide/csp/#quick-start","title":"Quick Start","text":""},{"location":"guide/csp/#basic-csp-setup","title":"Basic CSP Setup","text":"<p>The simplest CSP configuration - allow only resources from your own domain:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n# Enable CSP - allow resources only from same origin\napp.csp(default_src=[\"self\"])\n\n@app.get(\"/page\")\ndef get_page():\n    return {\"page\": \"content\"}\n\n# Response will include: Content-Security-Policy: default-src 'self'\n</code></pre> <p>Notice how <code>\"self\"</code> in the code becomes <code>'self'</code> (quoted) in the header - RestMachine automatically quotes CSP keywords for you.</p>"},{"location":"guide/csp/#using-presets","title":"Using Presets","text":"<p>RestMachine includes pre-configured security levels:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine.csp import CSPPreset\n\napp = RestApplication()\n\n# STRICT: Most secure - blocks most external resources\napp.csp(preset=CSPPreset.STRICT)\n\n# BASIC: Allow only same-origin resources\napp.csp(preset=CSPPreset.BASIC)\n\n# RELAXED: Allow inline styles (common in many apps)\napp.csp(preset=CSPPreset.RELAXED)\n\n# DEVELOPMENT: Very permissive, report-only mode\napp.csp(preset=CSPPreset.DEVELOPMENT)\n</code></pre>"},{"location":"guide/csp/#configuration-levels","title":"Configuration Levels","text":"<p>RestMachine supports CSP configuration at three levels with inheritance:</p>"},{"location":"guide/csp/#1-app-level-global","title":"1. App-Level (Global)","text":"<p>Apply CSP to all routes in the application:</p> <pre><code>app = RestApplication()\n\n# All routes will have this CSP policy\napp.csp(\n    default_src=[\"self\"],\n    script_src=[\"self\", \"https://cdn.jsdelivr.net\"],\n    style_src=[\"self\", \"unsafe-inline\"],\n    img_src=[\"self\", \"data:\", \"https:\"]\n)\n\n@app.get(\"/page\")\ndef get_page():\n    from restmachine import render\n    return render(template=\"page.html\", package=\"templates\")\n</code></pre>"},{"location":"guide/csp/#2-router-level","title":"2. Router-Level","text":"<p>Apply CSP to all routes in a specific router:</p> <pre><code>from restmachine import Router\n\napp = RestApplication()\n\n# Public pages - relaxed CSP\npublic_router = Router()\npublic_router.csp(\n    default_src=[\"self\"],\n    script_src=[\"self\", \"https://cdn.example.com\"],\n    style_src=[\"self\", \"unsafe-inline\"]\n)\n\n@public_router.get(\"/home\")\ndef home():\n    from restmachine import render\n    return render(template=\"home.html\", package=\"templates\")\n\n# Admin pages - strict CSP\nadmin_router = Router()\nadmin_router.csp(\n    default_src=[\"self\"],\n    script_src=[\"self\"],  # No CDNs\n    style_src=[\"self\"]    # No inline styles\n)\n\n@admin_router.get(\"/dashboard\")\ndef dashboard():\n    from restmachine import render\n    return render(template=\"admin.html\", package=\"templates\")\n\napp.mount(\"/\", public_router)\napp.mount(\"/admin\", admin_router)\n</code></pre>"},{"location":"guide/csp/#3-route-level","title":"3. Route-Level","text":"<p>Override CSP for specific endpoints:</p> <pre><code>app = RestApplication()\n\n# Default CSP for all routes\napp.csp(default_src=[\"self\"])\n\n@app.get(\"/page\")\ndef get_page():\n    return {\"page\": \"basic\"}\n\n# Override for specific route\n@app.get(\"/special\")\n@app.csp(\n    default_src=[\"self\"],\n    script_src=[\"self\", \"https://special-cdn.com\"]\n)\ndef get_special():\n    return {\"page\": \"special\"}\n</code></pre> <p>Hierarchy: Route-level \u2192 Router-level \u2192 App-level (most specific wins)</p>"},{"location":"guide/csp/#auto-quoting","title":"Auto-Quoting","text":"<p>RestMachine automatically quotes CSP values based on their type:</p>"},{"location":"guide/csp/#keywords-auto-quoted","title":"Keywords (Auto-Quoted)","text":"<p>CSP keywords are automatically quoted:</p> <pre><code>app.csp(\n    default_src=[\"self\"],                    # \u2192 'self'\n    script_src=[\"self\", \"unsafe-inline\"],    # \u2192 'self' 'unsafe-inline'\n    style_src=[\"unsafe-eval\"],               # \u2192 'unsafe-eval'\n    object_src=[\"none\"]                      # \u2192 'none'\n)\n\n# Result: default-src 'self'; script-src 'self' 'unsafe-inline'; ...\n</code></pre> <p>Supported keywords: <code>self</code>, <code>unsafe-inline</code>, <code>unsafe-eval</code>, <code>none</code>, <code>strict-dynamic</code>, <code>unsafe-hashes</code>, <code>report-sample</code>, <code>unsafe-allow-redirects</code>, <code>wasm-unsafe-eval</code></p>"},{"location":"guide/csp/#urls-and-domains-not-quoted","title":"URLs and Domains (Not Quoted)","text":"<p>URLs, domains, and schemes don't need quotes:</p> <pre><code>app.csp(\n    script_src=[\n        \"self\",                          # \u2192 'self'\n        \"https://cdn.jsdelivr.net\",      # \u2192 https://cdn.jsdelivr.net\n        \"https://code.jquery.com\"        # \u2192 https://code.jquery.com\n    ],\n    img_src=[\n        \"self\",                          # \u2192 'self'\n        \"data:\",                         # \u2192 data:\n        \"*.example.com\",                 # \u2192 *.example.com\n        \"https:\"                         # \u2192 https:\n    ]\n)\n</code></pre>"},{"location":"guide/csp/#already-quoted-values-preserved","title":"Already-Quoted Values (Preserved)","text":"<p>If you quote values yourself, RestMachine preserves them:</p> <pre><code>app.csp(\n    script_src=[\"'self'\", \"'unsafe-inline'\"]  # Already quoted - preserved\n)\n</code></pre>"},{"location":"guide/csp/#nonces-and-hashes-auto-quoted","title":"Nonces and Hashes (Auto-Quoted)","text":"<p>Nonces and hashes are automatically quoted:</p> <pre><code># When nonce=True, RestMachine generates: 'nonce-abc123xyz'\n# When using hashes: 'sha256-...'\n</code></pre>"},{"location":"guide/csp/#nonce-support","title":"Nonce Support","text":"<p>CSP nonces allow specific inline scripts/styles while blocking others - a powerful security pattern.</p>"},{"location":"guide/csp/#basic-nonce-usage","title":"Basic Nonce Usage","text":"<p>Enable nonces for inline scripts and styles:</p> <pre><code>app = RestApplication()\n\n@app.get(\"/page\")\n@app.csp(\n    script_src=[\"self\"],\n    style_src=[\"self\"],\n    nonce=True  # Generate nonce for this route\n)\ndef get_page(request):\n    # Access the nonce in your handler\n    nonce = request.csp_nonce\n\n    return render_template(\n        \"page.html\",\n        csp_nonce=nonce  # Pass to template\n    )\n</code></pre>"},{"location":"guide/csp/#using-nonce-in-templates","title":"Using Nonce in Templates","text":"<p>Jinja2 template example:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;!-- Inline style with nonce - allowed --&gt;\n    &lt;style nonce=\"{{ csp_nonce }}\"&gt;\n        .special { color: red; }\n    &lt;/style&gt;\n\n    &lt;!-- Inline style without nonce - blocked by CSP --&gt;\n    &lt;style&gt;\n        .blocked { color: blue; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Inline script with nonce - allowed --&gt;\n    &lt;script nonce=\"{{ csp_nonce }}\"&gt;\n        console.log(\"This works!\");\n    &lt;/script&gt;\n\n    &lt;!-- Inline script without nonce - blocked by CSP --&gt;\n    &lt;script&gt;\n        console.log(\"This is blocked!\");\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"guide/csp/#how-nonces-work","title":"How Nonces Work","text":"<ol> <li>Generation: RestMachine generates a unique nonce per request (32-byte URL-safe string)</li> <li>Header: Nonce is added to CSP header: <code>script-src 'self' 'nonce-abc123...'</code></li> <li>Access: Nonce is available as <code>request.csp_nonce</code> in handler</li> <li>Template: Pass nonce to templates for inline script/style tags</li> <li>Validation: Browser only executes inline code with matching nonce</li> </ol> <p>Security benefit: Attackers can't guess the nonce, so injected scripts won't execute.</p>"},{"location":"guide/csp/#dynamic-csp-with-providers","title":"Dynamic CSP with Providers","text":"<p>For complex scenarios where CSP needs to change per request:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine.csp import CSPConfig\n\napp = RestApplication()\n\n@app.csp_provider\ndef get_csp_for_request(request):\n    \"\"\"Return different CSP based on request properties.\"\"\"\n\n    # Admin pages get stricter CSP\n    if request.path.startswith(\"/admin\"):\n        return CSPConfig(\n            default_src=[\"self\"],\n            script_src=[\"self\"],\n            style_src=[\"self\"]\n        )\n\n    # Public pages can use CDNs\n    if request.path.startswith(\"/public\"):\n        return CSPConfig(\n            default_src=[\"self\"],\n            script_src=[\"self\", \"https://cdn.example.com\"],\n            style_src=[\"self\", \"unsafe-inline\"]\n        )\n\n    # Default policy\n    return CSPConfig(default_src=[\"self\"])\n\n@app.get(\"/admin/dashboard\")\ndef admin_dashboard():\n    return {\"admin\": True}\n\n@app.get(\"/public/page\")\ndef public_page():\n    return {\"public\": True}\n</code></pre> <p>Provider priority: Provider \u2192 Route \u2192 Router \u2192 App (provider overrides all)</p>"},{"location":"guide/csp/#callable-sources","title":"Callable Sources","text":"<p>Sources can be callable functions for runtime determination:</p> <pre><code>def get_allowed_cdns():\n    \"\"\"Load allowed CDNs from database or config.\"\"\"\n    return [\n        \"self\",\n        \"https://cdn1.example.com\",\n        \"https://cdn2.example.com\"\n    ]\n\napp.csp(script_src=get_allowed_cdns)\n</code></pre> <p>The function is called when building each CSP header, allowing dynamic configuration.</p>"},{"location":"guide/csp/#report-only-mode","title":"Report-Only Mode","text":"<p>Test CSP policies without blocking resources:</p> <pre><code>app = RestApplication()\n\n# Report violations but don't block\napp.csp(\n    default_src=[\"self\"],\n    script_src=[\"self\"],\n    report_only=True,              # Don't block, just report\n    report_uri=\"/csp-violations\"   # Where to send reports\n)\n\n@app.post(\"/csp-violations\")\ndef handle_csp_report(body: dict):\n    \"\"\"Receive CSP violation reports.\"\"\"\n    logger.warning(f\"CSP violation: {body}\")\n    return {\"status\": \"received\"}\n</code></pre> <p>Use cases: - Testing new policies before enforcement - Monitoring for CSP issues in production - Gradual CSP rollout</p>"},{"location":"guide/csp/#csp-directives","title":"CSP Directives","text":"<p>RestMachine supports all major CSP directives:</p>"},{"location":"guide/csp/#fetch-directives","title":"Fetch Directives","text":"<p>Control where resources can be loaded from:</p> <pre><code>app.csp(\n    default_src=[\"self\"],              # Default for all fetch directives\n    script_src=[\"self\", \"https://cdn.example.com\"],\n    style_src=[\"self\", \"unsafe-inline\"],\n    img_src=[\"self\", \"data:\", \"https:\"],\n    font_src=[\"self\", \"https://fonts.gstatic.com\"],\n    connect_src=[\"self\", \"https://api.example.com\"],\n    frame_src=[\"self\", \"https://www.youtube.com\"],\n    object_src=[\"none\"],               # Block plugins\n    media_src=[\"self\", \"https://media.example.com\"],\n    worker_src=[\"self\"]                # Web workers\n)\n</code></pre>"},{"location":"guide/csp/#document-directives","title":"Document Directives","text":"<p>Control document properties:</p> <pre><code>app.csp(\n    base_uri=[\"self\"]  # Restrict &lt;base&gt; tag URLs\n)\n</code></pre>"},{"location":"guide/csp/#navigation-directives","title":"Navigation Directives","text":"<p>Control form submissions:</p> <pre><code>app.csp(\n    form_action=[\"self\", \"https://external-form.com\"]\n)\n</code></pre>"},{"location":"guide/csp/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/csp/#pattern-1-basic-security","title":"Pattern 1: Basic Security","text":"<p>Allow only same-origin resources:</p> <pre><code>app.csp(default_src=[\"self\"])\n</code></pre>"},{"location":"guide/csp/#pattern-2-cdn-support","title":"Pattern 2: CDN Support","text":"<p>Allow resources from trusted CDNs:</p> <pre><code>app.csp(\n    default_src=[\"self\"],\n    script_src=[\"self\", \"https://cdn.jsdelivr.net\"],\n    style_src=[\"self\", \"https://cdn.jsdelivr.net\"],\n    font_src=[\"self\", \"https://fonts.gstatic.com\"]\n)\n</code></pre>"},{"location":"guide/csp/#pattern-3-third-party-integrations","title":"Pattern 3: Third-Party Integrations","text":"<p>Allow specific third-party services:</p> <pre><code>app.csp(\n    default_src=[\"self\"],\n    script_src=[\n        \"self\",\n        \"https://www.google-analytics.com\",\n        \"https://www.googletagmanager.com\"\n    ],\n    img_src=[\n        \"self\",\n        \"data:\",  # Data URIs for inline images\n        \"https://www.google-analytics.com\"\n    ],\n    connect_src=[\n        \"self\",\n        \"https://www.google-analytics.com\"\n    ]\n)\n</code></pre>"},{"location":"guide/csp/#pattern-4-development-setup","title":"Pattern 4: Development Setup","text":"<p>Permissive for development with reporting:</p> <pre><code>import os\n\napp = RestApplication()\n\nif os.getenv(\"ENV\") == \"development\":\n    app.csp(preset=CSPPreset.DEVELOPMENT)\nelse:\n    app.csp(preset=CSPPreset.STRICT)\n</code></pre>"},{"location":"guide/csp/#pattern-5-inline-scripts-with-nonces","title":"Pattern 5: Inline Scripts with Nonces","text":"<p>Allow inline scripts safely:</p> <pre><code>@app.get(\"/page\")\n@app.csp(\n    script_src=[\"self\"],\n    style_src=[\"self\"],\n    nonce=True\n)\ndef get_page(request):\n    return render_template(\"page.html\", csp_nonce=request.csp_nonce)\n</code></pre>"},{"location":"guide/csp/#security-best-practices","title":"Security Best Practices","text":""},{"location":"guide/csp/#1-start-strict-then-relax","title":"1. Start Strict, Then Relax","text":"<p>Start with a strict policy and relax as needed:</p> <pre><code># Start with this\napp.csp(default_src=[\"self\"])\n\n# If you need CDNs, add them specifically\napp.csp(\n    default_src=[\"self\"],\n    script_src=[\"self\", \"https://trusted-cdn.com\"]\n)\n</code></pre>"},{"location":"guide/csp/#2-avoid-unsafe-inline","title":"2. Avoid unsafe-inline","text":"<p>Use nonces instead of <code>unsafe-inline</code>:</p> <pre><code># \u274c Bad: Opens XSS vulnerabilities\napp.csp(script_src=[\"self\", \"unsafe-inline\"])\n\n# \u2705 Good: Use nonces\napp.csp(script_src=[\"self\"], nonce=True)\n</code></pre>"},{"location":"guide/csp/#3-test-with-report-only","title":"3. Test with Report-Only","text":"<p>Test policies before enforcement:</p> <pre><code># Phase 1: Test with report-only\napp.csp(\n    default_src=[\"self\"],\n    report_only=True,\n    report_uri=\"/csp-violations\"\n)\n\n# Phase 2: After testing, enforce\napp.csp(default_src=[\"self\"])\n</code></pre>"},{"location":"guide/csp/#4-block-objectembed","title":"4. Block Object/Embed","text":"<p>Block plugins to prevent Flash/Java attacks:</p> <pre><code>app.csp(\n    default_src=[\"self\"],\n    object_src=[\"none\"]  # Block plugins\n)\n</code></pre>"},{"location":"guide/csp/#5-use-https-for-cdns","title":"5. Use HTTPS for CDNs","text":"<p>Always use HTTPS URLs for external resources:</p> <pre><code># \u2705 Good\napp.csp(script_src=[\"self\", \"https://cdn.example.com\"])\n\n# \u274c Bad: Allows HTTP (insecure)\napp.csp(script_src=[\"self\", \"http://cdn.example.com\"])\n</code></pre>"},{"location":"guide/csp/#debugging-csp","title":"Debugging CSP","text":""},{"location":"guide/csp/#browser-developer-tools","title":"Browser Developer Tools","text":"<ol> <li>Open browser developer console</li> <li>Look for CSP violation errors:    <pre><code>Refused to load the script 'https://evil.com/script.js'\nbecause it violates the following Content Security Policy directive: \"script-src 'self'\"\n</code></pre></li> </ol>"},{"location":"guide/csp/#report-only-mode_1","title":"Report-Only Mode","text":"<p>Use report-only to see violations without blocking:</p> <pre><code>app.csp(\n    default_src=[\"self\"],\n    report_only=True,\n    report_uri=\"/csp-violations\"\n)\n\n@app.post(\"/csp-violations\")\ndef log_violations(body: dict):\n    print(f\"CSP Violation: {body}\")\n    return {\"ok\": True}\n</code></pre>"},{"location":"guide/csp/#common-issues","title":"Common Issues","text":"<p>Issue: Inline styles/scripts blocked Solution: Use nonces or move to external files</p> <p>Issue: Third-party scripts blocked Solution: Add their domain to script-src</p> <p>Issue: Data URIs blocked Solution: Add <code>data:</code> to img-src</p> <p>Issue: WebSocket connections blocked Solution: Add WebSocket URL to connect-src</p>"},{"location":"guide/csp/#migration-from-other-frameworks","title":"Migration from Other Frameworks","text":""},{"location":"guide/csp/#from-flask-talisman","title":"From Flask-Talisman","text":"<pre><code># Flask-Talisman\ntalisman = Talisman(\n    app,\n    content_security_policy={\n        'default-src': \"'self'\",\n        'script-src': [\"'self'\", 'https://cdn.com']\n    }\n)\n\n# RestMachine (no manual quoting needed!)\napp.csp(\n    default_src=[\"self\"],\n    script_src=[\"self\", \"https://cdn.com\"]\n)\n</code></pre>"},{"location":"guide/csp/#from-django-csp","title":"From Django CSP","text":"<pre><code># Django settings.py\nCSP_DEFAULT_SRC = (\"'self'\",)\nCSP_SCRIPT_SRC = (\"'self'\", \"https://cdn.com\")\n\n# RestMachine\napp.csp(\n    default_src=[\"self\"],\n    script_src=[\"self\", \"https://cdn.com\"]\n)\n</code></pre>"},{"location":"guide/csp/#additional-resources","title":"Additional Resources","text":"<ul> <li>MDN: Content Security Policy</li> <li>CSP Quick Reference</li> <li>CSP Evaluator - Test your policies</li> <li>Report URI - CSP violation reporting service</li> </ul>"},{"location":"guide/csp/#summary","title":"Summary","text":"<p>RestMachine's CSP support provides:</p> <p>\u2705 Auto-quoting - No manual quoting of keywords \u2705 Nonce generation - Secure inline scripts/styles \u2705 Presets - Quick security levels \u2705 Flexible configuration - App/router/route levels \u2705 Dynamic policies - CSP providers and callable sources \u2705 Report-only mode - Test before enforcing \u2705 Best practices - Built-in security patterns</p>"},{"location":"guide/dependency-injection/","title":"Dependency Injection","text":"<p>RestMachine features pytest-style dependency injection that makes your code clean, testable, and maintainable. Dependencies are automatically resolved and cached during request processing.</p>"},{"location":"guide/dependency-injection/#basic-dependencies","title":"Basic Dependencies","text":""},{"location":"guide/dependency-injection/#defining-dependencies","title":"Defining Dependencies","text":"<p>Use the <code>@app.dependency()</code> decorator to define a dependency:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.dependency()\ndef database():\n    return {\"users\": [], \"posts\": []}\n\n@app.get('/users')\ndef list_users(database):\n    return {\"users\": database[\"users\"]}\n</code></pre> <p>Dependencies are injected by matching parameter names with dependency function names.</p>"},{"location":"guide/dependency-injection/#dependency-caching","title":"Dependency Caching","text":"<p>By default, dependencies are cached per request:</p> <pre><code>@app.dependency()\ndef get_timestamp():\n    from datetime import datetime\n    print(\"Creating timestamp...\")\n    return datetime.now()\n\n@app.dependency()\ndef request_logger(get_timestamp):\n    print(f\"Request at: {get_timestamp}\")\n    return \"logger\"\n\n@app.get('/example')\ndef example_handler(get_timestamp, request_logger):\n    # get_timestamp is only created once per request\n    return {\"timestamp\": str(get_timestamp)}\n\n# Output when request is made:\n# Creating timestamp...\n# Request at: 2024-01-15 10:30:00\n</code></pre>"},{"location":"guide/dependency-injection/#nested-dependencies","title":"Nested Dependencies","text":"<p>Dependencies can depend on other dependencies:</p> <pre><code>@app.dependency()\ndef config():\n    return {\n        \"db_host\": \"localhost\",\n        \"db_port\": 5432,\n        \"db_name\": \"myapp\"\n    }\n\n@app.dependency()\ndef database_url(config):\n    return f\"postgresql://{config['db_host']}:{config['db_port']}/{config['db_name']}\"\n\n@app.dependency()\ndef database(database_url):\n    print(f\"Connecting to {database_url}\")\n    # In real app, create actual connection\n    return {\"connected\": True, \"url\": database_url}\n\n@app.get('/status')\ndef status(database):\n    return database\n</code></pre>"},{"location":"guide/dependency-injection/#accessing-request-data","title":"Accessing Request Data","text":"<p>Use specific dependencies instead of the generic <code>request</code> object:</p> <pre><code>@app.dependency()\ndef current_user(request_headers):\n    # Extract user from authentication header\n    auth_header = request_headers.get('authorization', '')\n\n    if auth_header.startswith('Bearer '):\n        token = auth_header[7:]\n        # In real app, validate token and get user\n        return {\"id\": \"123\", \"name\": \"Alice\", \"token\": token}\n\n    return None\n\n@app.get('/profile')\ndef get_profile(current_user):\n    if not current_user:\n        from restmachine import Response\n        return Response(401, '{\"error\": \"Unauthorized\"}')\n\n    return current_user\n</code></pre>"},{"location":"guide/dependency-injection/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>Access path and query parameters using built-in dependencies:</p> <pre><code>@app.dependency()\ndef user_id(path_params):\n    return path_params.get('user_id')\n\n@app.dependency()\ndef pagination(query_params):\n    page = int(query_params.get('page', '1'))\n    limit = int(query_params.get('limit', '20'))\n    offset = (page - 1) * limit\n    return {\"page\": page, \"limit\": limit, \"offset\": offset}\n\n@app.get('/users')\ndef list_users(pagination, database):\n    users = database[\"users\"]\n    start = pagination[\"offset\"]\n    end = start + pagination[\"limit\"]\n    return {\n        \"users\": users[start:end],\n        \"page\": pagination[\"page\"],\n        \"total\": len(users)\n    }\n\n# Use @app.resource_exists for automatic 404 handling\n@app.resource_exists\ndef user_exists(user_id, database):\n    return next((u for u in database[\"users\"] if u[\"id\"] == user_id), None)\n\n@app.get('/users/{user_id}')\ndef get_user(user_exists):\n    # user_exists decorator handles 404 automatically\n    return user_exists\n</code></pre>"},{"location":"guide/dependency-injection/#session-scoped-dependencies","title":"Session-Scoped Dependencies","text":"<p>For resources that should be shared across requests (like database connections), use startup handlers:</p> <pre><code>@app.on_startup\ndef database():\n    print(\"Opening database connection...\")\n    # In real app, create connection pool\n    return {\n        \"pool\": \"connection_pool\",\n        \"users\": [\n            {\"id\": \"1\", \"name\": \"Alice\"},\n            {\"id\": \"2\", \"name\": \"Bob\"}\n        ]\n    }\n\n@app.on_shutdown\ndef close_database(database):\n    print(\"Closing database connection...\")\n    # In real app, close connection pool\n\n@app.get('/users')\ndef list_users(database):\n    # Same database instance used across all requests\n    return {\"users\": database[\"users\"]}\n</code></pre> <p>Session vs Request Scope</p> <ul> <li><code>@app.on_startup</code> dependencies are created once when the application starts</li> <li><code>@app.dependency()</code> dependencies are created per request and cached for that request</li> <li>Choose session scope for expensive resources (database pools, caches)</li> <li>Choose request scope for request-specific data (current user, pagination)</li> </ul>"},{"location":"guide/dependency-injection/#validation-dependencies","title":"Validation Dependencies","text":"<p>Combine dependency injection with validation for clean request handling:</p> <pre><code>from pydantic import BaseModel, EmailStr, Field\n\nclass UserCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    email: EmailStr\n    age: int = Field(..., ge=0, le=150)\n\n@app.validates\ndef validate_user(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n@app.dependency()\ndef unique_email(validate_user: UserCreate, database):\n    # Check if email already exists\n    existing = next(\n        (u for u in database[\"users\"] if u[\"email\"] == validate_user.email),\n        None\n    )\n    if existing:\n        from restmachine import Response\n        raise ValueError(\"Email already registered\")\n\n    return validate_user.email\n\n@app.post('/users')\ndef create_user(validate_user: UserCreate, unique_email: str, database):\n    user = validate_user.model_dump()\n    user[\"id\"] = str(len(database[\"users\"]) + 1)\n    database[\"users\"].append(user)\n    return user, 201\n</code></pre>"},{"location":"guide/dependency-injection/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guide/dependency-injection/#factory-dependencies","title":"Factory Dependencies","text":"<p>Create dependencies that return different implementations:</p> <pre><code>@app.dependency()\ndef storage(request_headers):\n    # Choose storage based on environment or request\n    env = request_headers.get('X-Environment', 'production')\n\n    if env == 'test':\n        return {\"type\": \"memory\", \"data\": {}}\n    else:\n        return {\"type\": \"postgres\", \"connection\": \"...\"}\n\n@app.get('/data')\ndef get_data(storage):\n    return {\"storage_type\": storage[\"type\"]}\n</code></pre>"},{"location":"guide/dependency-injection/#conditional-dependencies","title":"Conditional Dependencies","text":"<p>Dependencies that may or may not be available:</p> <pre><code>@app.dependency()\ndef optional_feature(request_headers):\n    feature_flag = request_headers.get('X-Enable-Feature')\n    if feature_flag == 'true':\n        return {\"enabled\": True, \"config\": {...}}\n    return None\n\n@app.get('/feature')\ndef use_feature(optional_feature):\n    if optional_feature:\n        return {\"status\": \"enabled\", \"config\": optional_feature[\"config\"]}\n    return {\"status\": \"disabled\"}\n</code></pre>"},{"location":"guide/dependency-injection/#optional-dependencies","title":"Optional Dependencies","text":"<p>Use default values for optional dependencies:</p> <pre><code>@app.dependency()\ndef cache():\n    # Simulate cache that might not be available\n    return None  # Cache not configured\n\n@app.get('/data')\ndef get_data(cache=None, database=None):\n    if cache:\n        return {\"source\": \"cache\", \"data\": cache.get(\"data\")}\n\n    if database:\n        return {\"source\": \"database\", \"data\": database[\"users\"]}\n\n    return {\"source\": \"none\", \"data\": []}\n</code></pre>"},{"location":"guide/dependency-injection/#repository-pattern","title":"Repository Pattern","text":"<p>Use dependency injection to implement clean repository patterns:</p> <pre><code>class UserRepository:\n    def __init__(self, database):\n        self.database = database\n\n    def get_all(self):\n        return self.database[\"users\"]\n\n    def get_by_id(self, user_id):\n        return next(\n            (u for u in self.database[\"users\"] if u[\"id\"] == user_id),\n            None\n        )\n\n    def create(self, user_data):\n        user = {**user_data, \"id\": str(len(self.database[\"users\"]) + 1)}\n        self.database[\"users\"].append(user)\n        return user\n\n    def delete(self, user_id):\n        self.database[\"users\"] = [\n            u for u in self.database[\"users\"] if u[\"id\"] != user_id\n        ]\n\n@app.dependency()\ndef user_repository(database):\n    return UserRepository(database)\n\n@app.get('/users')\ndef list_users(user_repository: UserRepository):\n    return {\"users\": user_repository.get_all()}\n\n@app.resource_exists\ndef user_from_repo(path_params, user_repository: UserRepository):\n    user_id = path_params.get('user_id')\n    return user_repository.get_by_id(user_id)\n\n@app.get('/users/{user_id}')\ndef get_user(user_from_repo):\n    # resource_exists decorator handles 404 automatically\n    return user_from_repo\n\n@app.post('/users')\ndef create_user(validate_user: UserCreate, user_repository: UserRepository):\n    user = user_repository.create(validate_user.model_dump())\n    return user, 201\n</code></pre>"},{"location":"guide/dependency-injection/#service-pattern","title":"Service Pattern","text":"<p>Build services on top of repositories:</p> <pre><code>class UserService:\n    def __init__(self, user_repository, email_service):\n        self.user_repository = user_repository\n        self.email_service = email_service\n\n    def register_user(self, user_data):\n        # Create user\n        user = self.user_repository.create(user_data)\n\n        # Send welcome email\n        self.email_service.send_welcome(user[\"email\"])\n\n        return user\n\n    def get_user_with_stats(self, user_id):\n        user = self.user_repository.get_by_id(user_id)\n        if not user:\n            return None\n\n        # Add computed statistics\n        return {\n            **user,\n            \"stats\": {\n                \"posts\": 0,  # Would query posts\n                \"followers\": 0  # Would query followers\n            }\n        }\n\n@app.dependency()\ndef email_service():\n    class EmailService:\n        def send_welcome(self, email):\n            print(f\"Sending welcome email to {email}\")\n\n    return EmailService()\n\n@app.dependency()\ndef user_service(user_repository, email_service):\n    return UserService(user_repository, email_service)\n\n@app.post('/register')\ndef register(validate_user: UserCreate, user_service: UserService):\n    user = user_service.register_user(validate_user.model_dump())\n    return user, 201\n\n@app.resource_exists\ndef user_stats_data(path_params, user_service: UserService):\n    user_id = path_params.get('user_id')\n    return user_service.get_user_with_stats(user_id)\n\n@app.get('/users/{user_id}/stats')\ndef user_stats(user_stats_data):\n    # resource_exists decorator handles 404 automatically\n    return user_stats_data\n</code></pre>"},{"location":"guide/dependency-injection/#testing-with-dependency-overrides","title":"Testing with Dependency Overrides","text":"<p>Override dependencies for testing:</p> <pre><code># app.py\napp = RestApplication()\n\n@app.dependency()\ndef database():\n    # Production database\n    return create_real_database()\n\n@app.get('/users')\ndef list_users(database):\n    return {\"users\": database.get_all_users()}\n\n# test_app.py\nimport pytest\nfrom restmachine import Request\n\ndef test_list_users():\n    # Create test database\n    test_db = {\n        \"users\": [\n            {\"id\": \"1\", \"name\": \"Test User\"}\n        ]\n    }\n\n    # Override database dependency\n    @app.dependency()\n    def database():\n        return test_db\n\n    # Test the endpoint\n    request = Request(method='GET', path='/users')\n    response = app.execute(request)\n\n    import json\n    data = json.loads(response.body)\n    assert len(data[\"users\"]) == 1\n    assert data[\"users\"][0][\"name\"] == \"Test User\"\n</code></pre>"},{"location":"guide/dependency-injection/#complete-example","title":"Complete Example","text":"<p>Here's a complete example combining all concepts:</p> <pre><code>from restmachine import RestApplication, Request, Response\nfrom pydantic import BaseModel, EmailStr\nimport json\n\napp = RestApplication()\n\n# Models\nclass UserCreate(BaseModel):\n    name: str\n    email: EmailStr\n\nclass User(UserCreate):\n    id: str\n\n# Session-scoped dependencies\n@app.on_startup\ndef database():\n    return {\n        \"users\": [\n            {\"id\": \"1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            {\"id\": \"2\", \"name\": \"Bob\", \"email\": \"bob@example.com\"}\n        ]\n    }\n\n@app.on_shutdown\ndef close_database(database):\n    print(\"Cleaning up database...\")\n\n# Repositories\nclass UserRepository:\n    def __init__(self, database):\n        self.database = database\n\n    def get_all(self, offset=0, limit=20):\n        return self.database[\"users\"][offset:offset+limit]\n\n    def get_by_id(self, user_id):\n        return next((u for u in self.database[\"users\"] if u[\"id\"] == user_id), None)\n\n    def get_by_email(self, email):\n        return next((u for u in self.database[\"users\"] if u[\"email\"] == email), None)\n\n    def create(self, user_data):\n        user = {**user_data, \"id\": str(len(self.database[\"users\"]) + 1)}\n        self.database[\"users\"].append(user)\n        return user\n\n    def count(self):\n        return len(self.database[\"users\"])\n\n# Request-scoped dependencies\n@app.dependency()\ndef user_repository(database):\n    return UserRepository(database)\n\n@app.dependency()\ndef pagination(query_params):\n    page = int(query_params.get('page', '1'))\n    limit = int(query_params.get('limit', '20'))\n    offset = (page - 1) * limit\n    return {\"page\": page, \"limit\": limit, \"offset\": offset}\n\n@app.dependency()\ndef current_user(request_headers, user_repository: UserRepository):\n    auth_header = request_headers.get('authorization', '')\n    if not auth_header.startswith('Bearer '):\n        return None\n\n    # In real app, validate token\n    user_id = auth_header[7:]  # Simplified: token is user_id\n    return user_repository.get_by_id(user_id)\n\n# Validation dependencies\n@app.validates\ndef validate_user(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n@app.dependency()\ndef unique_email(validate_user: UserCreate, user_repository: UserRepository):\n    existing = user_repository.get_by_email(validate_user.email)\n    if existing:\n        raise ValueError(f\"Email {validate_user.email} already registered\")\n    return validate_user\n\n# Routes\n@app.get('/users')\ndef list_users(pagination, user_repository: UserRepository):\n    users = user_repository.get_all(\n        offset=pagination[\"offset\"],\n        limit=pagination[\"limit\"]\n    )\n    total = user_repository.count()\n\n    return {\n        \"users\": users,\n        \"page\": pagination[\"page\"],\n        \"total\": total,\n        \"pages\": (total + pagination[\"limit\"] - 1) // pagination[\"limit\"]\n    }\n\n@app.resource_exists\ndef user_by_id(path_params, user_repository: UserRepository):\n    user_id = path_params.get('user_id')\n    return user_repository.get_by_id(user_id)\n\n@app.get('/users/{user_id}')\ndef get_user(user_by_id):\n    # resource_exists decorator handles 404 automatically\n    return user_by_id\n\n@app.post('/users')\ndef create_user(unique_email: UserCreate, user_repository: UserRepository):\n    user = user_repository.create(unique_email.model_dump())\n    return user, 201\n\n@app.get('/profile')\ndef get_profile(current_user):\n    if not current_user:\n        return Response(401, json.dumps({\"error\": \"Unauthorized\"}))\n\n    return {\n        \"user\": current_user,\n        \"message\": \"This is your profile\"\n    }\n\n# Error handler for validation errors\n@app.error_handler(400)\ndef validation_error(request, message, **kwargs):\n    return {\"error\": \"Validation failed\", \"details\": message}\n\n# Run with ASGI\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n</code></pre>"},{"location":"guide/dependency-injection/#best-practices","title":"Best Practices","text":""},{"location":"guide/dependency-injection/#1-naming-conventions","title":"1. Naming Conventions","text":"<p>Use clear, descriptive names for dependencies:</p> <pre><code># Good\n@app.dependency()\ndef current_user(request_headers):\n    ...\n\n@app.dependency()\ndef database_connection():\n    ...\n\n# Avoid\n@app.dependency()\ndef dep1():\n    ...\n\n@app.dependency()\ndef get_data():  # Too generic\n    ...\n</code></pre>"},{"location":"guide/dependency-injection/#2-scope-selection","title":"2. Scope Selection","text":"<p>Choose the right scope for each dependency:</p> <pre><code># Session scope: Expensive resources shared across requests\n@app.on_startup\ndef database_pool():\n    return create_connection_pool()\n\n@app.on_startup\ndef cache_client():\n    return create_redis_client()\n\n# Request scope: Request-specific data\n@app.dependency()\ndef current_user(request_headers):\n    return extract_user_from_token(request_headers)\n\n@app.dependency()\ndef request_id(request_headers):\n    return request_headers.get('X-Request-ID', generate_id())\n</code></pre>"},{"location":"guide/dependency-injection/#3-dependency-organization","title":"3. Dependency Organization","text":"<p>Group related dependencies:</p> <pre><code># auth.py\n@app.dependency()\ndef current_user(request_headers):\n    ...\n\n@app.dependency()\ndef require_admin(current_user):\n    if not current_user or not current_user.get('is_admin'):\n        raise PermissionError(\"Admin access required\")\n    return current_user\n\n# database.py\n@app.on_startup\ndef database():\n    ...\n\n@app.dependency()\ndef user_repository(database):\n    ...\n\n@app.dependency()\ndef post_repository(database):\n    ...\n</code></pre>"},{"location":"guide/dependency-injection/#4-error-handling","title":"4. Error Handling","text":"<p>Handle dependency errors gracefully:</p> <pre><code>@app.dependency()\ndef database():\n    try:\n        return create_database_connection()\n    except ConnectionError as e:\n        print(f\"Database connection failed: {e}\")\n        raise\n\n@app.dependency()\ndef current_user(request_headers):\n    try:\n        return validate_token(request_headers.get('authorization'))\n    except InvalidTokenError:\n        return None  # Return None instead of raising\n\n@app.get('/protected')\ndef protected_route(current_user):\n    if not current_user:\n        from restmachine import Response\n        return Response(401, '{\"error\": \"Unauthorized\"}')\n    return {\"user\": current_user}\n</code></pre>"},{"location":"guide/dependency-injection/#5-type-hints","title":"5. Type Hints","text":"<p>Use type hints for better IDE support and clarity:</p> <pre><code>from typing import Optional, Dict, Any\n\n@app.dependency()\ndef database() -&gt; Dict[str, Any]:\n    return {\"users\": [], \"posts\": []}\n\n@app.dependency()\ndef current_user(request_headers) -&gt; Optional[Dict[str, Any]]:\n    auth_header = request_headers.get('authorization')\n    if not auth_header:\n        return None\n    return {\"id\": \"123\", \"name\": \"User\"}\n\n@app.get('/profile')\ndef get_profile(current_user: Optional[Dict[str, Any]]):\n    if not current_user:\n        from restmachine import Response\n        return Response(401, '{\"error\": \"Unauthorized\"}')\n    return current_user\n</code></pre>"},{"location":"guide/dependency-injection/#next-steps","title":"Next Steps","text":"<ul> <li>Validation \u2192 - Learn about request validation with Pydantic</li> <li>Authentication \u2192 - Implement authentication and authorization</li> <li>Testing \u2192 - Test your application with dependency overrides</li> <li>Advanced Features \u2192 - Deep dive into lifecycle management</li> </ul>"},{"location":"guide/deployment-asgi/","title":"ASGI Deployment","text":"<p>RestMachine applications can be deployed using any ASGI server. This guide covers generic ASGI deployment with examples using popular servers.</p>"},{"location":"guide/deployment-asgi/#what-is-asgi","title":"What is ASGI?","text":"<p>ASGI (Asynchronous Server Gateway Interface) is the Python standard for async web servers and applications. It enables:</p> <ul> <li>High-performance async request handling</li> <li>HTTP/2 and HTTP/3 support (server-dependent)</li> <li>Long-polling and server-sent events</li> </ul>"},{"location":"guide/deployment-asgi/#creating-an-asgi-application","title":"Creating an ASGI Application","text":"<p>Convert your RestMachine application to ASGI:</p> <pre><code>from restmachine import RestApplication, ASGIAdapter\n\n# Create your application\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello, World!\"}\n\n# Create ASGI adapter\nasgi_app = ASGIAdapter(app)\n</code></pre> <p>Save this as <code>app.py</code> and you can run it with any ASGI server.</p>"},{"location":"guide/deployment-asgi/#choosing-an-asgi-server","title":"Choosing an ASGI Server","text":"<p>Popular ASGI servers include:</p> Server HTTP/1.1 HTTP/2 HTTP/3 Auto-reload Best For Uvicorn \u2713 Limited \u2717 \u2713 Development, production HTTP/1.1 Hypercorn \u2713 \u2713 \u2713 \u2717 HTTP/2, HTTP/3 support Daphne \u2713 \u2717 \u2717 \u2717 Django Channels integration"},{"location":"guide/deployment-asgi/#uvicorn","title":"Uvicorn","text":"<p>Uvicorn is a lightning-fast ASGI server built on uvloop and httptools.</p>"},{"location":"guide/deployment-asgi/#installation","title":"Installation","text":"<pre><code>pip install uvicorn\n# Or with standard extras for production\npip install 'uvicorn[standard]'\n</code></pre>"},{"location":"guide/deployment-asgi/#basic-usage","title":"Basic Usage","text":"<pre><code># Run application\nuvicorn app:asgi_app\n\n# Development mode with auto-reload\nuvicorn app:asgi_app --reload\n\n# Production with multiple workers\nuvicorn app:asgi_app --host 0.0.0.0 --port 8000 --workers 4\n</code></pre>"},{"location":"guide/deployment-asgi/#configuration","title":"Configuration","text":"<pre><code># Custom host and port\nuvicorn app:asgi_app --host 0.0.0.0 --port 8000\n\n# With SSL\nuvicorn app:asgi_app --ssl-keyfile ./key.pem --ssl-certfile ./cert.pem\n\n# Logging\nuvicorn app:asgi_app --log-level info\n\n# Connection limits\nuvicorn app:asgi_app --limit-concurrency 1000\n</code></pre>"},{"location":"guide/deployment-asgi/#programmatic-usage","title":"Programmatic Usage","text":"<pre><code>import uvicorn\nfrom restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello!\"}\n\nasgi_app = ASGIAdapter(app)\n\nif __name__ == \"__main__\":\n    uvicorn.run(\n        asgi_app,\n        host=\"0.0.0.0\",\n        port=8000,\n        workers=4\n    )\n</code></pre>"},{"location":"guide/deployment-asgi/#hypercorn","title":"Hypercorn","text":"<p>Hypercorn is an ASGI server with full HTTP/2 and HTTP/3 support.</p>"},{"location":"guide/deployment-asgi/#installation_1","title":"Installation","text":"<pre><code>pip install hypercorn\n# For HTTP/3 support\npip install 'hypercorn[h3]'\n</code></pre>"},{"location":"guide/deployment-asgi/#basic-usage_1","title":"Basic Usage","text":"<pre><code># Run application\nhypercorn app:asgi_app\n\n# Custom host and port\nhypercorn app:asgi_app --bind 0.0.0.0:8000\n\n# Multiple workers\nhypercorn app:asgi_app --workers 4\n\n# HTTP/2 with SSL\nhypercorn app:asgi_app \\\n  --bind 0.0.0.0:8443 \\\n  --keyfile ./key.pem \\\n  --certfile ./cert.pem\n</code></pre>"},{"location":"guide/deployment-asgi/#configuration_1","title":"Configuration","text":"<pre><code># Logging\nhypercorn app:asgi_app --log-level info --access-log -\n\n# Keep-alive timeout\nhypercorn app:asgi_app --keep-alive-timeout 5\n\n# Graceful shutdown\nhypercorn app:asgi_app --graceful-timeout 30\n</code></pre>"},{"location":"guide/deployment-asgi/#programmatic-usage_1","title":"Programmatic Usage","text":"<pre><code>import asyncio\nfrom hypercorn.config import Config\nfrom hypercorn.asyncio import serve\nfrom restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello!\"}\n\nasgi_app = ASGIAdapter(app)\n\nif __name__ == \"__main__\":\n    config = Config()\n    config.bind = [\"0.0.0.0:8000\"]\n    asyncio.run(serve(asgi_app, config))\n</code></pre>"},{"location":"guide/deployment-asgi/#production-deployment","title":"Production Deployment","text":""},{"location":"guide/deployment-asgi/#using-systemd","title":"Using Systemd","text":"<p>Create a systemd service file:</p> <p>/etc/systemd/system/myapp.service:</p> <pre><code>[Unit]\nDescription=My RestMachine Application\nAfter=network.target\n\n[Service]\nType=notify\nUser=www-data\nGroup=www-data\nWorkingDirectory=/var/www/myapp\nEnvironment=\"PATH=/var/www/myapp/venv/bin\"\nExecStart=/var/www/myapp/venv/bin/uvicorn app:asgi_app --host 0.0.0.0 --port 8000 --workers 4\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Enable and start:</p> <pre><code>sudo systemctl enable myapp\nsudo systemctl start myapp\nsudo systemctl status myapp\n</code></pre>"},{"location":"guide/deployment-asgi/#behind-a-reverse-proxy","title":"Behind a Reverse Proxy","text":"<p>Use Nginx as a reverse proxy:</p> <p>/etc/nginx/sites-available/myapp:</p> <pre><code>upstream backend {\n    server 127.0.0.1:8000;\n}\n\nserver {\n    listen 80;\n    server_name example.com;\n\n    location / {\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre>"},{"location":"guide/deployment-asgi/#docker-deployment","title":"Docker Deployment","text":"<p>Create a Dockerfile:</p> <pre><code>FROM python:3.11-slim\n\nWORKDIR /app\n\n# Install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application\nCOPY . .\n\n# Expose port\nEXPOSE 8000\n\n# Run with uvicorn\nCMD [\"uvicorn\", \"app:asgi_app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\", \"--workers\", \"4\"]\n</code></pre> <p>Build and run:</p> <pre><code>docker build -t myapp .\ndocker run -p 8000:8000 myapp\n</code></pre>"},{"location":"guide/deployment-asgi/#environment-configuration","title":"Environment Configuration","text":"<p>Use environment variables for configuration:</p> <pre><code>import os\nfrom restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n# Configuration from environment\nHOST = os.getenv(\"HOST\", \"0.0.0.0\")\nPORT = int(os.getenv(\"PORT\", \"8000\"))\nWORKERS = int(os.getenv(\"WORKERS\", \"4\"))\nLOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"info\")\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello!\"}\n\nasgi_app = ASGIAdapter(app)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        asgi_app,\n        host=HOST,\n        port=PORT,\n        workers=WORKERS,\n        log_level=LOG_LEVEL\n    )\n</code></pre>"},{"location":"guide/deployment-asgi/#lifecycle-management","title":"Lifecycle Management","text":"<p>RestMachine supports startup and shutdown handlers for resource management:</p> <pre><code>from restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n@app.on_startup\ndef database():\n    \"\"\"Initialize database connection pool at startup.\"\"\"\n    print(\"Opening database connection...\")\n    return create_connection_pool()\n\n@app.on_shutdown\ndef close_database(database):\n    \"\"\"Close database connections at shutdown.\"\"\"\n    print(\"Closing database connection...\")\n    database.close()\n\n@app.get(\"/users\")\ndef list_users(database):\n    # Database connection is reused across requests\n    return {\"users\": database.query_all()}\n\nasgi_app = ASGIAdapter(app)\n</code></pre> <p>ASGI servers automatically call startup handlers when the server starts and shutdown handlers when it stops.</p>"},{"location":"guide/deployment-asgi/#health-checks","title":"Health Checks","text":"<p>Implement health check endpoints for monitoring:</p> <pre><code>@app.get(\"/health\")\ndef health_check():\n    \"\"\"Liveness probe.\"\"\"\n    return {\"status\": \"healthy\"}\n\n@app.get(\"/ready\")\ndef readiness_check(database):\n    \"\"\"Readiness probe.\"\"\"\n    if not database.is_connected():\n        return {\"status\": \"not ready\"}, 503\n    return {\"status\": \"ready\"}\n</code></pre> <p>Use these endpoints with orchestrators like Kubernetes:</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /health\n    port: 8000\n  initialDelaySeconds: 10\n  periodSeconds: 30\n\nreadinessProbe:\n  httpGet:\n    path: /ready\n    port: 8000\n  initialDelaySeconds: 5\n  periodSeconds: 10\n</code></pre>"},{"location":"guide/deployment-asgi/#performance-tips","title":"Performance Tips","text":""},{"location":"guide/deployment-asgi/#worker-count","title":"Worker Count","text":"<p>Set workers based on CPU cores:</p> <pre><code># Common formula: (2 x CPU cores) + 1\n# For 4 cores:\nuvicorn app:asgi_app --workers 9\n</code></pre> <p>Or dynamically:</p> <pre><code>import multiprocessing\n\nworkers = (multiprocessing.cpu_count() * 2) + 1\n</code></pre>"},{"location":"guide/deployment-asgi/#connection-limits","title":"Connection Limits","text":"<p>Configure connection limits for high-traffic applications:</p> <pre><code>uvicorn app:asgi_app --limit-concurrency 1000 --limit-max-requests 10000\n</code></pre>"},{"location":"guide/deployment-asgi/#logging","title":"Logging","text":"<p>Control logging verbosity:</p> <pre><code># Production - less verbose\nuvicorn app:asgi_app --log-level warning --no-access-log\n\n# Development - more verbose\nuvicorn app:asgi_app --log-level debug\n</code></pre>"},{"location":"guide/deployment-asgi/#complete-example","title":"Complete Example","text":"<p>Here's a complete production-ready example:</p> <pre><code># app.py\nimport os\nimport logging\nfrom restmachine import RestApplication, ASGIAdapter\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n# Create application\napp = RestApplication()\n\n@app.on_startup\ndef database():\n    \"\"\"Initialize database connection pool.\"\"\"\n    logger.info(\"Connecting to database...\")\n    # Return database connection pool\n    # Note: create_db_pool() is a placeholder - implement based on your database\n    return create_db_pool()\n\n@app.on_shutdown\ndef close_database(database):\n    \"\"\"Close database connections.\"\"\"\n    logger.info(\"Closing database connections...\")\n    database.close()\n\n@app.get(\"/\")\ndef home():\n    \"\"\"Root endpoint.\"\"\"\n    return {\"status\": \"ok\", \"version\": \"1.0.0\"}\n\n@app.get(\"/health\")\ndef health():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"healthy\"}\n\n@app.get(\"/users\")\ndef list_users(database):\n    \"\"\"List all users.\"\"\"\n    users = database.query_all_users()\n    return {\"users\": users}\n\n# Create ASGI app\nasgi_app = ASGIAdapter(app)\n\n# For running directly\nif __name__ == \"__main__\":\n    import uvicorn\n\n    # Get configuration from environment\n    host = os.getenv(\"HOST\", \"0.0.0.0\")\n    port = int(os.getenv(\"PORT\", \"8000\"))\n    workers = int(os.getenv(\"WORKERS\", \"4\"))\n    log_level = os.getenv(\"LOG_LEVEL\", \"info\")\n\n    uvicorn.run(\n        asgi_app,\n        host=host,\n        port=port,\n        workers=workers,\n        log_level=log_level\n    )\n</code></pre> <p>Run in development:</p> <pre><code>python app.py\n</code></pre> <p>Run in production:</p> <pre><code>export WORKERS=8\nexport LOG_LEVEL=warning\nuvicorn app:asgi_app --host 0.0.0.0 --port 8000 --workers 8\n</code></pre>"},{"location":"guide/deployment-asgi/#next-steps","title":"Next Steps","text":"<ul> <li>Lambda Deployment \u2192 - Deploy to AWS Lambda</li> <li>Lifecycle Management \u2192 - Advanced startup/shutdown patterns</li> <li>Performance Optimization \u2192 - Tuning tips</li> <li>Testing \u2192 - Test your ASGI application</li> </ul>"},{"location":"guide/deployment-lambda/","title":"AWS Lambda Deployment","text":"<p>Deploy RestMachine applications to AWS Lambda for serverless, scalable REST APIs. RestMachine provides seamless integration with API Gateway, Application Load Balancer (ALB), and Lambda Function URLs.</p>"},{"location":"guide/deployment-lambda/#installation","title":"Installation","text":"<p>Install RestMachine with AWS support:</p> <pre><code>pip install 'restmachine[aws]'\n</code></pre> <p>Or install separately:</p> <pre><code>pip install restmachine restmachine-aws\n</code></pre>"},{"location":"guide/deployment-lambda/#quick-start","title":"Quick Start","text":"<p>Create a Lambda handler:</p> <pre><code># lambda_function.py\nfrom restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\n\n# Create application\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello from Lambda!\"}\n\n@app.get(\"/users/{user_id}\")\ndef get_user(path_params):\n    return {\"id\": path_params['user_id']}\n\n# Create Lambda handler\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    \"\"\"AWS Lambda handler function.\"\"\"\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"guide/deployment-lambda/#api-gateway-integration","title":"API Gateway Integration","text":"<p>RestMachine automatically detects and handles different API Gateway event formats.</p>"},{"location":"guide/deployment-lambda/#http-api-v2-recommended","title":"HTTP API (v2) - Recommended","text":"<p>Modern, cost-effective API Gateway:</p> <pre><code># SAM template.yaml\nAWSTemplateFormatVersion: '2010-09-09'\nTransform: AWS::Serverless-2016-10-31\n\nResources:\n  RestMachineApi:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      Handler: lambda_function.lambda_handler\n      Runtime: python3.11\n      Events:\n        ApiEvent:\n          Type: HttpApi\n          Properties:\n            Path: /{proxy+}\n            Method: ANY\n</code></pre>"},{"location":"guide/deployment-lambda/#rest-api-v1","title":"REST API (v1)","text":"<p>Traditional API Gateway:</p> <pre><code>Events:\n  RestApi:\n    Type: Api  # REST API (v1)\n    Properties:\n      Path: /{proxy+}\n      Method: ANY\n</code></pre>"},{"location":"guide/deployment-lambda/#lambda-function-urls","title":"Lambda Function URLs","text":"<p>Direct HTTPS endpoint:</p> <pre><code>FunctionUrlConfig:\n  AuthType: NONE  # or AWS_IAM\n</code></pre>"},{"location":"guide/deployment-lambda/#application-load-balancer","title":"Application Load Balancer","text":"<p>ALB events are detected automatically - no special configuration needed.</p>"},{"location":"guide/deployment-lambda/#deployment-methods","title":"Deployment Methods","text":""},{"location":"guide/deployment-lambda/#aws-sam-recommended","title":"AWS SAM (Recommended)","text":"<p>template.yaml:</p> <pre><code>AWSTemplateFormatVersion: '2010-09-09'\nTransform: AWS::Serverless-2016-10-31\n\nResources:\n  MyApi:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      Handler: lambda_function.lambda_handler\n      Runtime: python3.11\n      Timeout: 30\n      MemorySize: 512\n      Environment:\n        Variables:\n          LOG_LEVEL: INFO\n      Events:\n        HttpApi:\n          Type: HttpApi\n          Properties:\n            Path: /{proxy+}\n            Method: ANY\n</code></pre> <p>requirements.txt:</p> <pre><code>restmachine[aws]\n</code></pre> <p>Deploy:</p> <pre><code>sam build\nsam deploy --guided\n</code></pre>"},{"location":"guide/deployment-lambda/#serverless-framework","title":"Serverless Framework","text":"<p>serverless.yml:</p> <pre><code>service: restmachine-api\n\nprovider:\n  name: aws\n  runtime: python3.11\n  stage: ${opt:stage, 'dev'}\n  region: us-east-1\n\nfunctions:\n  api:\n    handler: lambda_function.lambda_handler\n    events:\n      - httpApi:\n          path: /{proxy+}\n          method: ANY\n</code></pre> <p>Deploy:</p> <pre><code>serverless deploy --stage prod\n</code></pre>"},{"location":"guide/deployment-lambda/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"guide/deployment-lambda/#startup-handlers","title":"Startup Handlers","text":"<p>Startup handlers run once per Lambda cold start:</p> <pre><code>app = RestApplication()\n\n@app.on_startup\ndef database():\n    \"\"\"Initialize database connection (runs once per cold start).\"\"\"\n    import boto3\n    dynamodb = boto3.resource('dynamodb')\n    return dynamodb.Table('users')\n\n@app.get(\"/users/{user_id}\")\ndef get_user(path_params, database):\n    \"\"\"Use database connection from startup handler.\"\"\"\n    response = database.get_item(Key={'id': path_params['user_id']})\n    return response.get('Item', {})\n</code></pre> <p>Cold starts: Startup handlers run once when Lambda initializes a new container.</p> <p>Warm invocations: Subsequent requests reuse the startup handler results.</p>"},{"location":"guide/deployment-lambda/#shutdown-handlers","title":"Shutdown Handlers","text":"<p>For resource cleanup when Lambda containers terminate, RestMachine supports Lambda Extensions. See the AWS package documentation for advanced Lambda Extension support.</p>"},{"location":"guide/deployment-lambda/#database-integration","title":"Database Integration","text":""},{"location":"guide/deployment-lambda/#dynamodb","title":"DynamoDB","text":"<pre><code>import boto3\n\n@app.on_startup\ndef dynamodb():\n    \"\"\"Initialize DynamoDB client.\"\"\"\n    table_name = os.getenv('TABLE_NAME', 'users')\n    return boto3.resource('dynamodb').Table(table_name)\n\n@app.get(\"/items/{item_id}\")\ndef get_item(path_params, dynamodb):\n    response = dynamodb.get_item(Key={'id': path_params['item_id']})\n    return response.get('Item', {})\n\n@app.post(\"/items\")\ndef create_item(json_body, dynamodb):\n    dynamodb.put_item(Item=json_body)\n    return json_body, 201\n</code></pre>"},{"location":"guide/deployment-lambda/#rds-with-secrets-manager","title":"RDS with Secrets Manager","text":"<pre><code>import boto3\nimport json\nimport psycopg2\n\n@app.on_startup\ndef database():\n    \"\"\"Get RDS credentials and connect.\"\"\"\n    secrets = boto3.client('secretsmanager')\n    secret = secrets.get_secret_value(SecretId='rds-credentials')\n    creds = json.loads(secret['SecretString'])\n\n    return psycopg2.connect(\n        host=creds['host'],\n        database=creds['database'],\n        user=creds['username'],\n        password=creds['password']\n    )\n</code></pre>"},{"location":"guide/deployment-lambda/#configuration","title":"Configuration","text":""},{"location":"guide/deployment-lambda/#environment-variables","title":"Environment Variables","text":"<pre><code>import os\n\nTABLE_NAME = os.getenv('TABLE_NAME', 'default-table')\nLOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')\n\n@app.on_startup\ndef dynamodb():\n    import boto3\n    return boto3.resource('dynamodb').Table(TABLE_NAME)\n</code></pre> <p>SAM template:</p> <pre><code>Environment:\n  Variables:\n    TABLE_NAME: !Ref MyDynamoDBTable\n    LOG_LEVEL: INFO\n</code></pre>"},{"location":"guide/deployment-lambda/#local-testing","title":"Local Testing","text":""},{"location":"guide/deployment-lambda/#sam-local","title":"SAM Local","text":"<p>Test locally with SAM CLI:</p> <pre><code># Start local API\nsam local start-api\n\n# Test endpoint\ncurl http://localhost:3000/users/123\n</code></pre>"},{"location":"guide/deployment-lambda/#direct-invocation","title":"Direct Invocation","text":"<pre><code># test_lambda.py\nfrom lambda_function import lambda_handler\n\ndef test_get_user():\n    event = {\n        \"version\": \"2.0\",\n        \"routeKey\": \"GET /users/{user_id}\",\n        \"rawPath\": \"/users/123\",\n        \"pathParameters\": {\"user_id\": \"123\"},\n        \"requestContext\": {\n            \"http\": {\"method\": \"GET\", \"path\": \"/users/123\"}\n        }\n    }\n\n    response = lambda_handler(event, None)\n    assert response['statusCode'] == 200\n</code></pre>"},{"location":"guide/deployment-lambda/#complete-example","title":"Complete Example","text":"<pre><code># lambda_function.py\nimport os\nimport logging\nimport boto3\nfrom restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\nfrom pydantic import BaseModel\n\n# Configure logging\nlogger = logging.getLogger()\nlogger.setLevel(os.getenv('LOG_LEVEL', 'INFO'))\n\n# Create application\napp = RestApplication()\n\n# Startup handler\n@app.on_startup\ndef dynamodb():\n    \"\"\"Initialize DynamoDB (runs once per cold start).\"\"\"\n    table_name = os.getenv('TABLE_NAME', 'users')\n    logger.info(f\"Connecting to table: {table_name}\")\n    return boto3.resource('dynamodb').Table(table_name)\n\n# Validation\nclass UserCreate(BaseModel):\n    id: str\n    name: str\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n# Routes\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\"}\n\n@app.get(\"/users/{user_id}\")\ndef get_user(path_params, dynamodb):\n    try:\n        response = dynamodb.get_item(Key={'id': path_params['user_id']})\n        item = response.get('Item')\n        if not item:\n            return {\"error\": \"User not found\"}, 404\n        return item\n    except Exception as e:\n        logger.error(f\"Error: {e}\")\n        return {\"error\": \"Internal server error\"}, 500\n\n@app.post(\"/users\")\ndef create_user(user_create: UserCreate, dynamodb):\n    try:\n        dynamodb.put_item(Item=user_create.model_dump())\n        return user_create.model_dump(), 201\n    except Exception as e:\n        logger.error(f\"Error: {e}\")\n        return {\"error\": \"Internal server error\"}, 500\n\n# Create adapter and handler\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    \"\"\"AWS Lambda handler function.\"\"\"\n    return adapter.handle_event(event, context)\n</code></pre> <p>Complete SAM template:</p> <pre><code>AWSTemplateFormatVersion: '2010-09-09'\nTransform: AWS::Serverless-2016-10-31\n\nParameters:\n  Environment:\n    Type: String\n    Default: dev\n    AllowedValues: [dev, staging, prod]\n\nResources:\n  UsersTable:\n    Type: AWS::DynamoDB::Table\n    Properties:\n      TableName: !Sub users-${Environment}\n      BillingMode: PAY_PER_REQUEST\n      AttributeDefinitions:\n        - AttributeName: id\n          AttributeType: S\n      KeySchema:\n        - AttributeName: id\n          KeyType: HASH\n\n  ApiFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      Handler: lambda_function.lambda_handler\n      Runtime: python3.11\n      Timeout: 30\n      MemorySize: 512\n      Environment:\n        Variables:\n          TABLE_NAME: !Ref UsersTable\n          LOG_LEVEL: INFO\n      Policies:\n        - DynamoDBCrudPolicy:\n            TableName: !Ref UsersTable\n      Events:\n        HttpApi:\n          Type: HttpApi\n          Properties:\n            Path: /{proxy+}\n            Method: ANY\n\nOutputs:\n  ApiUrl:\n    Description: API Gateway endpoint URL\n    Value: !Sub 'https://${ServerlessHttpApi}.execute-api.${AWS::Region}.amazonaws.com'\n</code></pre>"},{"location":"guide/deployment-lambda/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guide/deployment-lambda/#lambda-configuration","title":"Lambda Configuration","text":"<p>Configure memory (more memory = more CPU):</p> <pre><code>MemorySize: 1024  # MB (128-10240)\nTimeout: 30       # seconds (1-900)\n</code></pre>"},{"location":"guide/deployment-lambda/#cold-start-optimization","title":"Cold Start Optimization","text":"<ol> <li>Use startup handlers to initialize connections once</li> <li>Package only needed dependencies - smaller packages load faster</li> <li>Use Lambda Layers for dependencies</li> <li>Keep functions warm with provisioned concurrency (for critical paths)</li> </ol>"},{"location":"guide/deployment-lambda/#reuse-connections","title":"Reuse Connections","text":"<pre><code># Good - connection reused across invocations\n@app.on_startup\ndef database():\n    return boto3.resource('dynamodb')\n\n# Bad - creates new connection each request\n@app.get(\"/users\")\ndef get_users():\n    db = boto3.resource('dynamodb')  # Don't do this!\n</code></pre>"},{"location":"guide/deployment-lambda/#best-practices","title":"Best Practices","text":""},{"location":"guide/deployment-lambda/#1-use-environment-variables","title":"1. Use Environment Variables","text":"<pre><code>TABLE_NAME = os.getenv('TABLE_NAME')\nLOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')\n</code></pre>"},{"location":"guide/deployment-lambda/#2-implement-health-checks","title":"2. Implement Health Checks","text":"<pre><code>@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\", \"version\": \"1.0.0\"}\n</code></pre>"},{"location":"guide/deployment-lambda/#3-log-structured-data","title":"3. Log Structured Data","text":"<pre><code>import json\nlogger.info(json.dumps({\n    \"event\": \"user_created\",\n    \"user_id\": user_id\n}))\n</code></pre>"},{"location":"guide/deployment-lambda/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<pre><code>try:\n    result = database.query(...)\n    return result\nexcept Exception as e:\n    logger.error(f\"Error: {e}\", exc_info=True)\n    return {\"error\": \"Internal server error\"}, 500\n</code></pre>"},{"location":"guide/deployment-lambda/#5-use-iam-for-permissions","title":"5. Use IAM for Permissions","text":"<p>Grant least-privilege permissions:</p> <pre><code>Policies:\n  - DynamoDBCrudPolicy:\n      TableName: !Ref MyTable\n  - Statement:\n      - Effect: Allow\n        Action: secretsmanager:GetSecretValue\n        Resource: !Ref MySecret\n</code></pre>"},{"location":"guide/deployment-lambda/#monitoring","title":"Monitoring","text":""},{"location":"guide/deployment-lambda/#cloudwatch-logs","title":"CloudWatch Logs","text":"<p>Logs automatically sent to CloudWatch:</p> <pre><code>import logging\nlogger = logging.getLogger()\nlogger.info(\"Processing request\")\n</code></pre>"},{"location":"guide/deployment-lambda/#cloudwatch-metrics","title":"CloudWatch Metrics","text":"<p>Track: - Invocations - Duration - Errors - Throttles - Cold starts</p>"},{"location":"guide/deployment-lambda/#x-ray-tracing","title":"X-Ray Tracing","text":"<p>Enable in SAM:</p> <pre><code>Tracing: Active\n</code></pre>"},{"location":"guide/deployment-lambda/#next-steps","title":"Next Steps","text":"<ul> <li>ASGI Deployment \u2192 - Deploy with ASGI servers</li> <li>Lifecycle Management \u2192 - Advanced startup/shutdown patterns</li> <li>Performance \u2192 - Optimization techniques</li> </ul>"},{"location":"guide/error-handling/","title":"Error Handling","text":"<p>RestMachine provides flexible error handling through custom error handlers, automatic HTTP status code mapping, and rich error responses. Learn how to handle errors gracefully and provide meaningful feedback to API consumers.</p>"},{"location":"guide/error-handling/#basic-error-responses","title":"Basic Error Responses","text":""},{"location":"guide/error-handling/#automatic-error-handling","title":"Automatic Error Handling","text":"<p>RestMachine automatically handles common errors using declarative decorators:</p> <pre><code>from restmachine import RestApplication, Request, Response\nfrom pydantic import BaseModel, EmailStr\n\napp = RestApplication()\n\n@app.on_startup\ndef database():\n    return {\"users\": {\"1\": {\"id\": \"1\", \"name\": \"Alice\"}}}\n\n@app.resource_exists\ndef user(path_params, database):\n    \"\"\"Returns None if not found, triggering automatic 404.\"\"\"\n    user_id = path_params['user_id']\n    return database[\"users\"].get(user_id)\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    \"\"\"404 handled automatically by resource_exists decorator.\"\"\"\n    return {\"user\": user}\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    name: str\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    \"\"\"Validates request, returns 400/422 automatically on error.\"\"\"\n    return UserCreate.model_validate(json_body)\n\n@app.post('/users')\ndef create_user(user_create: UserCreate):\n    \"\"\"Validation errors handled automatically.\"\"\"\n    return {\"created\": user_create.model_dump()}, 201\n</code></pre>"},{"location":"guide/error-handling/#http-status-codes","title":"HTTP Status Codes","text":"<p>Use appropriate status codes for different error types:</p> <pre><code># 400 Bad Request - Client error (validation, malformed request)\nreturn Response(400, '{\"error\": \"Invalid input\"}')\n\n# 401 Unauthorized - Missing or invalid authentication\nreturn Response(401, '{\"error\": \"Authentication required\"}')\n\n# 403 Forbidden - Authenticated but not authorized\nreturn Response(403, '{\"error\": \"Access denied\"}')\n\n# 404 Not Found - Resource doesn't exist\nreturn Response(404, '{\"error\": \"Resource not found\"}')\n\n# 409 Conflict - Resource conflict (duplicate email, etc.)\nreturn Response(409, '{\"error\": \"Email already exists\"}')\n\n# 422 Unprocessable Entity - Semantic validation error\nreturn Response(422, '{\"error\": \"Invalid date range\"}')\n\n# 500 Internal Server Error - Server error\nreturn Response(500, '{\"error\": \"Internal server error\"}')\n\n# 503 Service Unavailable - Temporary unavailability\nreturn Response(503, '{\"error\": \"Service temporarily unavailable\"}')\n</code></pre>"},{"location":"guide/error-handling/#custom-error-handlers","title":"Custom Error Handlers","text":""},{"location":"guide/error-handling/#defining-error-handlers","title":"Defining Error Handlers","text":"<p>Use <code>@app.error_handler()</code> to customize error responses:</p> <pre><code>@app.error_handler(404)\ndef not_found_handler(request, message, **kwargs):\n    \"\"\"Custom 404 error response.\"\"\"\n    return {\n        \"error\": \"Not Found\",\n        \"message\": message,\n        \"path\": request.path,\n        \"method\": request.method\n    }\n\n@app.error_handler(400)\ndef bad_request_handler(request, message, **kwargs):\n    \"\"\"Custom 400 error response.\"\"\"\n    return {\n        \"error\": \"Bad Request\",\n        \"message\": message,\n        \"timestamp\": \"2024-01-15T10:30:00Z\"\n    }\n\n@app.error_handler(500)\ndef server_error_handler(request, message, **kwargs):\n    \"\"\"Custom 500 error response.\"\"\"\n    # Log the error\n    import logging\n    logging.error(f\"Server error: {message}\", extra={'path': request.path})\n\n    return {\n        \"error\": \"Internal Server Error\",\n        \"message\": \"An unexpected error occurred\"\n    }\n</code></pre>"},{"location":"guide/error-handling/#error-handler-parameters","title":"Error Handler Parameters","text":"<p>Error handlers receive:</p> <pre><code>@app.error_handler(400)\ndef validation_error(request, message, **kwargs):\n    \"\"\"\n    Parameters:\n    - request: The Request object\n    - message: Error message string\n    - **kwargs: Additional context (exc_info, validation_error, etc.)\n    \"\"\"\n\n    # Access request details\n    path = request.path\n    method = request.method\n    headers = request.headers\n\n    # Access additional context\n    exc_info = kwargs.get('exc_info')  # Exception info if available\n    validation_error = kwargs.get('validation_error')  # Pydantic error\n\n    return {\n        \"error\": \"Validation Error\",\n        \"message\": message,\n        \"path\": path\n    }\n</code></pre>"},{"location":"guide/error-handling/#exception-based-error-handling","title":"Exception-Based Error Handling","text":""},{"location":"guide/error-handling/#raising-exceptions","title":"Raising Exceptions","text":"<p>Raise exceptions in dependencies or handlers:</p> <pre><code>@app.dependency()\ndef current_user(request: Request):\n    auth_header = request.headers.get('authorization')\n\n    if not auth_header:\n        raise ValueError(\"Authentication required\")\n\n    token = auth_header.replace('Bearer ', '')\n\n    if not validate_token(token):\n        raise ValueError(\"Invalid token\")\n\n    return get_user_from_token(token)\n\n@app.get('/profile')\ndef get_profile(current_user):\n    # current_user dependency raises ValueError if auth fails\n    return {\"user\": current_user}\n\n# Handle ValueError exceptions\n@app.error_handler(401)\ndef unauthorized_handler(request, message, **kwargs):\n    return {\n        \"error\": \"Unauthorized\",\n        \"message\": message\n    }\n</code></pre>"},{"location":"guide/error-handling/#custom-exceptions","title":"Custom Exceptions","text":"<p>Define custom exception classes:</p> <pre><code>class AuthenticationError(Exception):\n    \"\"\"Raised when authentication fails.\"\"\"\n    pass\n\nclass AuthorizationError(Exception):\n    \"\"\"Raised when user lacks permissions.\"\"\"\n    pass\n\nclass ResourceNotFoundError(Exception):\n    \"\"\"Raised when resource doesn't exist.\"\"\"\n    pass\n\nclass ValidationError(Exception):\n    \"\"\"Raised when validation fails.\"\"\"\n    def __init__(self, message, errors=None):\n        super().__init__(message)\n        self.errors = errors or []\n\n# Use in dependencies\n@app.dependency()\ndef current_user(request: Request):\n    auth_header = request.headers.get('authorization')\n\n    if not auth_header:\n        raise AuthenticationError(\"Missing authentication header\")\n\n    return validate_and_get_user(auth_header)\n\n# Handle custom exceptions\n@app.error_handler(401)\ndef auth_error_handler(request, message, **kwargs):\n    exc_info = kwargs.get('exc_info')\n\n    if exc_info and isinstance(exc_info[1], AuthenticationError):\n        return {\n            \"error\": \"Authentication Failed\",\n            \"message\": str(exc_info[1]),\n            \"hint\": \"Include 'Authorization: Bearer &lt;token&gt;' header\"\n        }\n\n    return {\"error\": \"Unauthorized\", \"message\": message}\n</code></pre>"},{"location":"guide/error-handling/#validation-error-handling","title":"Validation Error Handling","text":""},{"location":"guide/error-handling/#pydantic-validation-errors","title":"Pydantic Validation Errors","text":"<p>Handle Pydantic validation errors gracefully:</p> <pre><code>from pydantic import BaseModel, EmailStr, Field, ValidationError as PydanticValidationError\n\nclass UserCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    email: EmailStr\n    age: int = Field(..., ge=18, le=120)\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    \"\"\"Validates request body, returns 422 automatically on validation error.\"\"\"\n    return UserCreate.model_validate(json_body)\n\n@app.error_handler(400)\ndef validation_error_handler(request, message, **kwargs):\n    \"\"\"Handle Pydantic validation errors.\"\"\"\n    validation_error = kwargs.get('validation_error')\n\n    if validation_error and isinstance(validation_error, PydanticValidationError):\n        errors = []\n        for error in validation_error.errors():\n            errors.append({\n                \"field\": '.'.join(str(loc) for loc in error['loc']),\n                \"message\": error['msg'],\n                \"type\": error['type']\n            })\n\n        return {\n            \"error\": \"Validation Error\",\n            \"message\": \"Request validation failed\",\n            \"details\": errors\n        }\n\n    return {\n        \"error\": \"Bad Request\",\n        \"message\": message\n    }\n</code></pre>"},{"location":"guide/error-handling/#field-level-errors","title":"Field-Level Errors","text":"<p>Provide detailed field-level error information:</p> <pre><code>@app.error_handler(400)\ndef detailed_validation_error(request, message, **kwargs):\n    \"\"\"Provide detailed validation errors.\"\"\"\n    validation_error = kwargs.get('validation_error')\n\n    if not validation_error:\n        return {\"error\": \"Bad Request\", \"message\": message}\n\n    # Format Pydantic errors\n    from pydantic import ValidationError\n    if isinstance(validation_error, ValidationError):\n        field_errors = {}\n\n        for error in validation_error.errors():\n            field = '.'.join(str(loc) for loc in error['loc'])\n            field_errors[field] = {\n                \"message\": error['msg'],\n                \"value\": error.get('input'),\n                \"type\": error['type']\n            }\n\n        return {\n            \"error\": \"Validation Error\",\n            \"message\": \"One or more fields failed validation\",\n            \"field_errors\": field_errors\n        }\n\n    return {\"error\": \"Bad Request\", \"message\": message}\n</code></pre>"},{"location":"guide/error-handling/#error-context-and-logging","title":"Error Context and Logging","text":""},{"location":"guide/error-handling/#adding-error-context","title":"Adding Error Context","text":"<p>Include useful context in error responses:</p> <pre><code>import uuid\nfrom datetime import datetime\n\n@app.dependency()\ndef request_id(request: Request) -&gt; str:\n    \"\"\"Generate or extract request ID.\"\"\"\n    return request.headers.get('x-request-id', str(uuid.uuid4()))\n\n@app.error_handler(500)\ndef server_error_with_context(request, message, **kwargs):\n    \"\"\"Server error with tracking information.\"\"\"\n    import logging\n\n    request_id = request.headers.get('x-request-id', 'unknown')\n    timestamp = datetime.now().isoformat()\n\n    # Log detailed error\n    exc_info = kwargs.get('exc_info')\n    if exc_info:\n        logging.error(\n            f\"Server error [{request_id}]: {message}\",\n            exc_info=exc_info,\n            extra={\n                'request_id': request_id,\n                'path': request.path,\n                'method': request.method\n            }\n        )\n\n    # Return safe error response\n    return {\n        \"error\": \"Internal Server Error\",\n        \"message\": \"An unexpected error occurred\",\n        \"request_id\": request_id,\n        \"timestamp\": timestamp\n    }\n</code></pre>"},{"location":"guide/error-handling/#structured-logging","title":"Structured Logging","text":"<p>Implement structured error logging:</p> <pre><code>import logging\nimport json\n\n# Configure structured logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(message)s'\n)\n\nlogger = logging.getLogger(__name__)\n\nclass StructuredMessage:\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs\n\n    def __str__(self):\n        return json.dumps(self.kwargs)\n\n@app.error_handler(500)\ndef logged_server_error(request, message, **kwargs):\n    \"\"\"Log structured error information.\"\"\"\n    exc_info = kwargs.get('exc_info')\n\n    log_data = {\n        \"level\": \"error\",\n        \"message\": message,\n        \"request\": {\n            \"method\": request.method,\n            \"path\": request.path,\n            \"headers\": dict(request.headers)\n        },\n        \"timestamp\": datetime.now().isoformat()\n    }\n\n    if exc_info:\n        log_data[\"exception\"] = {\n            \"type\": exc_info[0].__name__,\n            \"message\": str(exc_info[1])\n        }\n\n    logger.error(StructuredMessage(**log_data))\n\n    return {\n        \"error\": \"Internal Server Error\",\n        \"message\": \"An unexpected error occurred\"\n    }\n</code></pre>"},{"location":"guide/error-handling/#error-response-formats","title":"Error Response Formats","text":""},{"location":"guide/error-handling/#consistent-error-format","title":"Consistent Error Format","text":"<p>Use a consistent error response format:</p> <pre><code>def error_response(error_type: str, message: str, **extras):\n    \"\"\"Create consistent error response.\"\"\"\n    response = {\n        \"error\": error_type,\n        \"message\": message,\n        \"timestamp\": datetime.now().isoformat()\n    }\n    response.update(extras)\n    return response\n\n@app.error_handler(400)\ndef bad_request(request, message, **kwargs):\n    return error_response(\"Bad Request\", message, path=request.path)\n\n@app.error_handler(401)\ndef unauthorized(request, message, **kwargs):\n    return error_response(\"Unauthorized\", message)\n\n@app.error_handler(403)\ndef forbidden(request, message, **kwargs):\n    return error_response(\"Forbidden\", message, required_role=\"admin\")\n\n@app.error_handler(404)\ndef not_found(request, message, **kwargs):\n    return error_response(\"Not Found\", message, path=request.path)\n</code></pre>"},{"location":"guide/error-handling/#rfc-7807-problem-details","title":"RFC 7807 Problem Details","text":"<p>Implement RFC 7807 Problem Details format:</p> <pre><code>@app.error_handler(400)\ndef problem_details_bad_request(request, message, **kwargs):\n    \"\"\"RFC 7807 Problem Details format.\"\"\"\n    return {\n        \"type\": \"https://api.example.com/errors/bad-request\",\n        \"title\": \"Bad Request\",\n        \"status\": 400,\n        \"detail\": message,\n        \"instance\": request.path\n    }\n\n@app.error_handler(404)\ndef problem_details_not_found(request, message, **kwargs):\n    return {\n        \"type\": \"https://api.example.com/errors/not-found\",\n        \"title\": \"Not Found\",\n        \"status\": 404,\n        \"detail\": message,\n        \"instance\": request.path\n    }\n\n@app.error_handler(422)\ndef problem_details_validation(request, message, **kwargs):\n    validation_error = kwargs.get('validation_error')\n    errors = []\n\n    if validation_error:\n        from pydantic import ValidationError\n        if isinstance(validation_error, ValidationError):\n            for error in validation_error.errors():\n                errors.append({\n                    \"field\": '.'.join(str(loc) for loc in error['loc']),\n                    \"reason\": error['msg']\n                })\n\n    return {\n        \"type\": \"https://api.example.com/errors/validation\",\n        \"title\": \"Validation Error\",\n        \"status\": 422,\n        \"detail\": message,\n        \"instance\": request.path,\n        \"errors\": errors\n    }\n</code></pre>"},{"location":"guide/error-handling/#cascading-error-handlers","title":"Cascading Error Handlers","text":""},{"location":"guide/error-handling/#fallback-handlers","title":"Fallback Handlers","text":"<p>Define fallback error handlers:</p> <pre><code># Specific handler for 404\n@app.error_handler(404)\ndef not_found(request, message, **kwargs):\n    return {\"error\": \"Not Found\", \"message\": message}\n\n# Generic handler for all 4xx errors\n@app.error_handler(400)\n@app.error_handler(401)\n@app.error_handler(403)\n@app.error_handler(422)\ndef client_error(request, message, **kwargs):\n    \"\"\"Fallback for client errors.\"\"\"\n    return {\n        \"error\": \"Client Error\",\n        \"message\": message,\n        \"path\": request.path\n    }\n\n# Generic handler for all 5xx errors\n@app.error_handler(500)\n@app.error_handler(502)\n@app.error_handler(503)\ndef server_error(request, message, **kwargs):\n    \"\"\"Fallback for server errors.\"\"\"\n    import logging\n    logging.error(f\"Server error: {message}\")\n\n    return {\n        \"error\": \"Server Error\",\n        \"message\": \"An unexpected error occurred\"\n    }\n</code></pre>"},{"location":"guide/error-handling/#debug-mode-errors","title":"Debug Mode Errors","text":""},{"location":"guide/error-handling/#development-vs-production","title":"Development vs Production","text":"<p>Show detailed errors in development only:</p> <pre><code>import os\n\nDEBUG = os.environ.get('DEBUG', 'false').lower() == 'true'\n\n@app.error_handler(500)\ndef debug_aware_error(request, message, **kwargs):\n    \"\"\"Show stack trace in debug mode only.\"\"\"\n    import traceback\n\n    exc_info = kwargs.get('exc_info')\n\n    if DEBUG and exc_info:\n        # Development: show detailed error\n        return {\n            \"error\": \"Internal Server Error\",\n            \"message\": message,\n            \"exception\": {\n                \"type\": exc_info[0].__name__,\n                \"message\": str(exc_info[1]),\n                \"traceback\": traceback.format_exception(*exc_info)\n            }\n        }\n\n    # Production: hide details\n    return {\n        \"error\": \"Internal Server Error\",\n        \"message\": \"An unexpected error occurred\"\n    }\n</code></pre>"},{"location":"guide/error-handling/#complete-example","title":"Complete Example","text":"<p>Here's a complete error handling setup:</p> <pre><code>from restmachine import RestApplication, Request, Response\nfrom pydantic import BaseModel, EmailStr, ValidationError as PydanticValidationError\nfrom datetime import datetime\nimport logging\nimport json\n\napp = RestApplication()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Custom exceptions\nclass AuthenticationError(Exception):\n    pass\n\nclass AuthorizationError(Exception):\n    pass\n\n# Models\nclass UserCreate(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n\n# Database\n@app.on_startup\ndef database():\n    return {\"users\": []}\n\n# Helpers\ndef error_response(error_type: str, message: str, status_code: int, **extras):\n    \"\"\"Create consistent error response.\"\"\"\n    response = {\n        \"error\": error_type,\n        \"message\": message,\n        \"status\": status_code,\n        \"timestamp\": datetime.now().isoformat()\n    }\n    response.update(extras)\n    return response\n\n# Error handlers\n@app.error_handler(400)\ndef bad_request_handler(request, message, **kwargs):\n    \"\"\"Handle validation and bad request errors.\"\"\"\n    validation_error = kwargs.get('validation_error')\n\n    if validation_error and isinstance(validation_error, PydanticValidationError):\n        errors = [\n            {\n                \"field\": '.'.join(str(loc) for loc in error['loc']),\n                \"message\": error['msg']\n            }\n            for error in validation_error.errors()\n        ]\n\n        return error_response(\n            \"Validation Error\",\n            \"Request validation failed\",\n            400,\n            details=errors\n        )\n\n    return error_response(\"Bad Request\", message, 400, path=request.path)\n\n@app.error_handler(401)\ndef unauthorized_handler(request, message, **kwargs):\n    \"\"\"Handle authentication errors.\"\"\"\n    exc_info = kwargs.get('exc_info')\n\n    if exc_info and isinstance(exc_info[1], AuthenticationError):\n        return error_response(\n            \"Authentication Failed\",\n            str(exc_info[1]),\n            401,\n            hint=\"Include 'Authorization: Bearer &lt;token&gt;' header\"\n        )\n\n    return error_response(\"Unauthorized\", message, 401)\n\n@app.error_handler(403)\ndef forbidden_handler(request, message, **kwargs):\n    \"\"\"Handle authorization errors.\"\"\"\n    return error_response(\"Forbidden\", message, 403, path=request.path)\n\n@app.error_handler(404)\ndef not_found_handler(request, message, **kwargs):\n    \"\"\"Handle not found errors.\"\"\"\n    return error_response(\"Not Found\", message, 404, path=request.path)\n\n@app.error_handler(409)\ndef conflict_handler(request, message, **kwargs):\n    \"\"\"Handle resource conflict errors.\"\"\"\n    return error_response(\"Conflict\", message, 409)\n\n@app.error_handler(500)\ndef server_error_handler(request, message, **kwargs):\n    \"\"\"Handle server errors.\"\"\"\n    exc_info = kwargs.get('exc_info')\n\n    # Log error\n    if exc_info:\n        logger.error(\n            f\"Server error: {message}\",\n            exc_info=exc_info,\n            extra={'path': request.path, 'method': request.method}\n        )\n\n    return error_response(\n        \"Internal Server Error\",\n        \"An unexpected error occurred\",\n        500\n    )\n\n# Validation\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n# Dependencies\n@app.dependency()\ndef current_user(request: Request):\n    auth_header = request.headers.get('authorization', '')\n\n    if not auth_header.startswith('Bearer '):\n        raise AuthenticationError(\"Missing or invalid authentication header\")\n\n    # Simplified token validation\n    return {\"id\": \"1\", \"name\": \"Alice\"}\n\n# Routes\n@app.post('/users')\ndef create_user(user_create: UserCreate, database):\n    # Check for duplicate email\n    existing = next(\n        (u for u in database[\"users\"] if u[\"email\"] == user_create.email),\n        None\n    )\n\n    if existing:\n        return Response(\n            409,\n            json.dumps(error_response(\n                \"Conflict\",\n                f\"User with email {user_create.email} already exists\",\n                409\n            ))\n        )\n\n    user = user_create.model_dump()\n    user[\"id\"] = str(len(database[\"users\"]) + 1)\n    database[\"users\"].append(user)\n\n    return user, 201\n\n@app.resource_exists\ndef user(path_params, database):\n    \"\"\"Returns None if not found, triggering automatic 404.\"\"\"\n    user_id = path_params['user_id']\n    return next((u for u in database[\"users\"] if u[\"id\"] == user_id), None)\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    \"\"\"404 handled automatically by resource_exists decorator.\"\"\"\n    return user\n\n@app.get('/protected')\ndef protected_resource(current_user):\n    return {\"user\": current_user, \"message\": \"Access granted\"}\n\n# ASGI\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n</code></pre>"},{"location":"guide/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"guide/error-handling/#1-use-appropriate-status-codes","title":"1. Use Appropriate Status Codes","text":"<p>Map errors to correct HTTP status codes:</p> <pre><code># Client errors (4xx)\n- 400: Malformed request, validation errors\n- 401: Missing or invalid authentication\n- 403: Authenticated but lacking permissions\n- 404: Resource not found\n- 409: Resource conflict\n- 422: Semantic validation error\n- 429: Rate limit exceeded\n\n# Server errors (5xx)\n- 500: Unexpected server error\n- 502: Bad gateway\n- 503: Service unavailable\n- 504: Gateway timeout\n</code></pre>"},{"location":"guide/error-handling/#2-dont-leak-sensitive-information","title":"2. Don't Leak Sensitive Information","text":"<p>Hide internal details in production:</p> <pre><code>@app.error_handler(500)\ndef safe_server_error(request, message, **kwargs):\n    # DON'T: Expose internal details\n    # return {\"error\": str(exc_info[1]), \"stack\": traceback}\n\n    # DO: Return generic message\n    return {\"error\": \"Internal Server Error\", \"message\": \"An error occurred\"}\n</code></pre>"},{"location":"guide/error-handling/#3-log-all-server-errors","title":"3. Log All Server Errors","text":"<p>Always log server errors for debugging:</p> <pre><code>@app.error_handler(500)\ndef logged_error(request, message, **kwargs):\n    logger.error(f\"Server error: {message}\", exc_info=kwargs.get('exc_info'))\n    return {\"error\": \"Internal Server Error\"}\n</code></pre>"},{"location":"guide/error-handling/#4-provide-actionable-error-messages","title":"4. Provide Actionable Error Messages","text":"<p>Help users fix the problem:</p> <pre><code># Bad\nreturn {\"error\": \"Invalid input\"}\n\n# Good\nreturn {\n    \"error\": \"Validation Error\",\n    \"message\": \"Email field is required\",\n    \"field\": \"email\"\n}\n</code></pre>"},{"location":"guide/error-handling/#5-use-consistent-error-format","title":"5. Use Consistent Error Format","text":"<p>Maintain consistent structure across all errors:</p> <pre><code>{\n    \"error\": \"Error Type\",\n    \"message\": \"Human-readable message\",\n    \"timestamp\": \"ISO 8601 timestamp\",\n    \"path\": \"/api/endpoint\",\n    \"details\": {}  # Optional additional context\n}\n</code></pre>"},{"location":"guide/error-handling/#next-steps","title":"Next Steps","text":"<ul> <li>Testing \u2192 - Test error handling</li> <li>Content Negotiation \u2192 - Error responses in different formats</li> <li>Deployment \u2192 - Production error handling</li> <li>Advanced Features \u2192 - Understanding the error flow</li> </ul>"},{"location":"guide/etags/","title":"Conditional Requests (ETags)","text":"<p>Conditional requests using ETags and Last-Modified headers allow clients to cache resources efficiently and prevent lost updates with optimistic concurrency control. RestMachine provides built-in support for these HTTP caching mechanisms.</p>"},{"location":"guide/etags/#overview","title":"Overview","text":"<p>ETags (Entity Tags) are identifiers assigned to specific versions of a resource. They enable:</p> <ul> <li>Efficient Caching: Clients can avoid downloading unchanged resources</li> <li>Optimistic Concurrency: Prevent conflicting updates to the same resource</li> <li>Bandwidth Savings: Return <code>304 Not Modified</code> instead of full responses</li> </ul>"},{"location":"guide/etags/#basic-etag-usage","title":"Basic ETag Usage","text":""},{"location":"guide/etags/#generating-etags","title":"Generating ETags","text":"<p>Use the <code>@app.generate_etag</code> decorator to create ETags for your resources:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.resource_exists\ndef document(path_params, database):\n    \"\"\"Get document by ID, returns None if not found.\"\"\"\n    doc_id = path_params.get(\"doc_id\")\n    return database.get(doc_id)\n\n@app.generate_etag\ndef document_etag(document):\n    \"\"\"Generate ETag based on document version.\"\"\"\n    if document:\n        return f'\"{document[\"id\"]}-v{document[\"version\"]}\"'\n    return None\n\n@app.get(\"/documents/{doc_id}\")\ndef get_document(document):\n    \"\"\"404 handled automatically by resource_exists decorator.\"\"\"\n    return document\n</code></pre>"},{"location":"guide/etags/#how-it-works","title":"How It Works","text":"<ol> <li>Client requests a resource</li> <li>Server generates an ETag and includes it in the <code>ETag</code> header</li> <li>Client caches the resource with its ETag</li> <li>On subsequent requests, client sends the ETag in conditional headers</li> <li>Server returns <code>304 Not Modified</code> if the resource hasn't changed</li> </ol>"},{"location":"guide/etags/#conditional-get-requests","title":"Conditional GET Requests","text":""},{"location":"guide/etags/#if-none-match-header","title":"If-None-Match Header","text":"<p>Clients use <code>If-None-Match</code> to check if a resource has changed:</p> <pre><code>app = RestApplication()\n\n@app.on_startup\ndef database():\n    return {\n        \"documents\": {\n            \"doc1\": {\"id\": \"doc1\", \"title\": \"Document 1\", \"version\": 1}\n        }\n    }\n\n@app.resource_exists\ndef document(path_params, database):\n    doc_id = path_params.get(\"doc_id\")\n    return database[\"documents\"].get(doc_id)\n\n@app.generate_etag\ndef document_etag(document):\n    \"\"\"Generate ETag from document version.\"\"\"\n    if document:\n        return f'\"{document[\"version\"]}\"'\n    return None\n\n@app.get(\"/documents/{doc_id}\")\ndef get_document(document):\n    return document\n</code></pre> <p>Request Flow:</p> <pre><code># First request\nGET /documents/doc1\nAccept: application/json\n\n# Response\nHTTP/1.1 200 OK\nETag: \"1\"\nContent-Type: application/json\n\n{\"id\": \"doc1\", \"title\": \"Document 1\", \"version\": 1}\n\n# Second request (with ETag)\nGET /documents/doc1\nAccept: application/json\nIf-None-Match: \"1\"\n\n# Response (resource unchanged)\nHTTP/1.1 304 Not Modified\nETag: \"1\"\n</code></pre>"},{"location":"guide/etags/#optimistic-concurrency-control","title":"Optimistic Concurrency Control","text":""},{"location":"guide/etags/#if-match-header","title":"If-Match Header","text":"<p>Use <code>If-Match</code> to prevent lost updates - the request only succeeds if the ETag matches:</p> <pre><code>app = RestApplication()\n\n@app.on_startup\ndef database():\n    return {\n        \"documents\": {\n            \"doc1\": {\"id\": \"doc1\", \"content\": \"Original\", \"version\": 1}\n        }\n    }\n\n@app.resource_exists\ndef document(path_params, database):\n    doc_id = path_params.get(\"doc_id\")\n    return database[\"documents\"].get(doc_id)\n\n@app.generate_etag\ndef document_etag(document):\n    \"\"\"Generate ETag from document version.\"\"\"\n    if document:\n        return f'\"{document[\"version\"]}\"'\n    return None\n\n@app.put(\"/documents/{doc_id}\")\ndef update_document(document, json_body, path_params, database):\n    \"\"\"Update document and increment version.\"\"\"\n    doc_id = path_params[\"doc_id\"]\n\n    # Update the document\n    database[\"documents\"][doc_id].update(json_body)\n    database[\"documents\"][doc_id][\"version\"] += 1\n\n    return database[\"documents\"][doc_id]\n</code></pre> <p>Request Flow:</p> <pre><code># Update request with correct ETag\nPUT /documents/doc1\nContent-Type: application/json\nIf-Match: \"1\"\n\n{\"content\": \"Updated content\"}\n\n# Response (success)\nHTTP/1.1 200 OK\nETag: \"2\"\n\n{\"id\": \"doc1\", \"content\": \"Updated content\", \"version\": 2}\n\n# Conflicting update with old ETag\nPUT /documents/doc1\nContent-Type: application/json\nIf-Match: \"1\"\n\n{\"content\": \"Conflicting update\"}\n\n# Response (precondition failed)\nHTTP/1.1 412 Precondition Failed\n</code></pre>"},{"location":"guide/etags/#last-modified-headers","title":"Last-Modified Headers","text":"<p>Use <code>@app.last_modified</code> for time-based conditional requests:</p> <pre><code>from datetime import datetime\n\n@app.last_modified\ndef document_modified_time(document):\n    \"\"\"Get last modified time of document.\"\"\"\n    if document:\n        return document[\"updated_at\"]\n    return None\n\n@app.get(\"/documents/{doc_id}\")\ndef get_document(document):\n    return document\n</code></pre> <p>Request Flow:</p> <pre><code># First request\nGET /documents/doc1\n\n# Response\nHTTP/1.1 200 OK\nLast-Modified: Wed, 21 Oct 2015 07:28:00 GMT\n\n{\"id\": \"doc1\", \"title\": \"Document 1\"}\n\n# Conditional request\nGET /documents/doc1\nIf-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT\n\n# Response (not modified)\nHTTP/1.1 304 Not Modified\nLast-Modified: Wed, 21 Oct 2015 07:28:00 GMT\n</code></pre>"},{"location":"guide/etags/#combining-etags-and-last-modified","title":"Combining ETags and Last-Modified","text":"<p>You can use both mechanisms together for maximum flexibility:</p> <pre><code>from datetime import datetime\n\n@app.generate_etag\ndef document_etag(document):\n    \"\"\"Generate ETag from document version.\"\"\"\n    if document:\n        return f'\"{document[\"version\"]}\"'\n    return None\n\n@app.last_modified\ndef document_modified_time(document):\n    \"\"\"Get last modified time of document.\"\"\"\n    if document:\n        return document[\"updated_at\"]\n    return None\n\n@app.get(\"/documents/{doc_id}\")\ndef get_document(document):\n    return document\n</code></pre> <p>The server checks both conditions and returns <code>304 Not Modified</code> only if both indicate the resource is unchanged.</p>"},{"location":"guide/etags/#etag-generation-strategies","title":"ETag Generation Strategies","text":""},{"location":"guide/etags/#version-based-etags","title":"Version-Based ETags","text":"<p>Use version numbers for simple, predictable ETags:</p> <pre><code>@app.generate_etag\ndef version_etag(document):\n    \"\"\"Generate ETag from version number.\"\"\"\n    if document:\n        return f'\"{document[\"version\"]}\"'\n    return None\n</code></pre>"},{"location":"guide/etags/#hash-based-etags","title":"Hash-Based ETags","text":"<p>Generate ETags from content hashes:</p> <pre><code>import hashlib\nimport json\n\n@app.generate_etag\ndef content_hash_etag(document):\n    \"\"\"Generate ETag from content hash.\"\"\"\n    if document:\n        # Create hash of document content\n        content = json.dumps(document, sort_keys=True)\n        hash_value = hashlib.md5(content.encode()).hexdigest()\n        return f'\"{hash_value}\"'\n    return None\n</code></pre>"},{"location":"guide/etags/#timestamp-based-etags","title":"Timestamp-Based ETags","text":"<p>Use modification timestamps:</p> <pre><code>@app.generate_etag\ndef timestamp_etag(document):\n    \"\"\"Generate ETag from timestamp.\"\"\"\n    if document:\n        timestamp = int(document[\"updated_at\"].timestamp())\n        return f'\"{timestamp}\"'\n    return None\n</code></pre>"},{"location":"guide/etags/#complete-example-blog-api-with-etags","title":"Complete Example: Blog API with ETags","text":"<pre><code>from restmachine import RestApplication\nfrom datetime import datetime\nimport hashlib\nimport json\n\napp = RestApplication()\n\n# Database initialized at startup\n@app.on_startup\ndef database():\n    return {\n        \"posts\": {\n            1: {\n                \"id\": 1,\n                \"title\": \"First Post\",\n                \"content\": \"Hello, World!\",\n                \"version\": 1,\n                \"updated_at\": datetime.now()\n            }\n        }\n    }\n\n@app.resource_exists\ndef post(path_params, database):\n    \"\"\"Get post by ID, returns None if not found.\"\"\"\n    post_id = path_params.get(\"post_id\")\n    if post_id:\n        return database[\"posts\"].get(int(post_id))\n    return None\n\n@app.generate_etag\ndef post_etag(post):\n    \"\"\"Generate ETag for blog posts.\"\"\"\n    if post:\n        # Combine ID and version for ETag\n        return f'\"{post[\"id\"]}-{post[\"version\"]}\"'\n    return None\n\n@app.last_modified\ndef post_last_modified(post):\n    \"\"\"Get last modified time for blog posts.\"\"\"\n    if post:\n        return post[\"updated_at\"]\n    return None\n\n@app.get(\"/posts/{post_id}\")\ndef get_post(post):\n    \"\"\"Get a blog post. 404 and conditional requests handled automatically.\"\"\"\n    return post\n\n@app.put(\"/posts/{post_id}\")\ndef update_post(post, json_body, path_params, database):\n    \"\"\"Update a blog post (requires matching ETag via If-Match header).\"\"\"\n    post_id = int(path_params[\"post_id\"])\n\n    # Update post and increment version\n    database[\"posts\"][post_id].update(json_body)\n    database[\"posts\"][post_id][\"version\"] += 1\n    database[\"posts\"][post_id][\"updated_at\"] = datetime.now()\n\n    return database[\"posts\"][post_id]\n\n@app.post(\"/posts\")\ndef create_post(json_body, database):\n    \"\"\"Create a new blog post.\"\"\"\n    post_id = max(database[\"posts\"].keys()) + 1\n    post = {\n        \"id\": post_id,\n        \"version\": 1,\n        \"updated_at\": datetime.now(),\n        **json_body\n    }\n    database[\"posts\"][post_id] = post\n    return post, 201\n</code></pre>"},{"location":"guide/etags/#testing-conditional-requests","title":"Testing Conditional Requests","text":""},{"location":"guide/etags/#testing-etags","title":"Testing ETags","text":"<pre><code>from restmachine import Request, HTTPMethod\n\ndef test_etag_caching():\n    app = create_blog_app()  # From example above\n\n    # First request\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/posts/1\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    etag = response.headers.get(\"ETag\")\n    assert etag is not None\n\n    # Conditional request with same ETag\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/posts/1\",\n        headers={\n            \"Accept\": \"application/json\",\n            \"If-None-Match\": etag\n        }\n    )\n    response = app.execute(request)\n\n    # Should return 304 Not Modified\n    assert response.status_code == 304\n</code></pre>"},{"location":"guide/etags/#testing-optimistic-concurrency","title":"Testing Optimistic Concurrency","text":"<pre><code>def test_concurrent_updates():\n    app = create_blog_app()\n\n    # Get current ETag\n    response = app.execute(Request(\n        method=HTTPMethod.GET,\n        path=\"/posts/1\",\n        headers={\"Accept\": \"application/json\"}\n    ))\n    etag = response.headers.get(\"ETag\")\n\n    # First update succeeds\n    response = app.execute(Request(\n        method=HTTPMethod.PUT,\n        path=\"/posts/1\",\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"If-Match\": etag\n        },\n        body='{\"title\": \"Updated Title\"}'\n    ))\n    assert response.status_code == 200\n\n    # Second update with old ETag fails\n    response = app.execute(Request(\n        method=HTTPMethod.PUT,\n        path=\"/posts/1\",\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"If-Match\": etag  # Old ETag\n        },\n        body='{\"title\": \"Conflicting Update\"}'\n    ))\n    assert response.status_code == 412  # Precondition Failed\n</code></pre>"},{"location":"guide/etags/#best-practices","title":"Best Practices","text":""},{"location":"guide/etags/#1-always-quote-etags","title":"1. Always Quote ETags","text":"<p>ETags should be quoted strings per HTTP specification:</p> <pre><code># Good\nreturn f'\"{version}\"'\n\n# Bad\nreturn str(version)\n</code></pre>"},{"location":"guide/etags/#2-use-strong-etags","title":"2. Use Strong ETags","text":"<p>Strong ETags indicate byte-for-byte equality:</p> <pre><code># Strong ETag (default)\nreturn '\"abc123\"'\n\n# Weak ETag (indicates semantic equivalence)\nreturn 'W/\"abc123\"'\n</code></pre>"},{"location":"guide/etags/#3-invalidate-etags-on-updates","title":"3. Invalidate ETags on Updates","text":"<p>Increment version or regenerate hash after any modification:</p> <pre><code>@app.put(\"/documents/{doc_id}\")\ndef update_document(document, json_body, path_params, database):\n    doc_id = path_params[\"doc_id\"]\n    database[\"documents\"][doc_id].update(json_body)\n    # IMPORTANT: Invalidate the ETag\n    database[\"documents\"][doc_id][\"version\"] += 1\n    return database[\"documents\"][doc_id]\n</code></pre>"},{"location":"guide/etags/#4-handle-missing-etags-gracefully","title":"4. Handle Missing ETags Gracefully","text":"<p>Not all resources need ETags:</p> <pre><code>@app.dependency()\ndef resource_path(request):\n    return request.path\n\n@app.generate_etag\ndef maybe_etag(resource_path):\n    # Return None if ETag doesn't make sense\n    if resource_path.startswith(\"/stream/\"):\n        return None  # Streaming resources don't use ETags\n    # Otherwise generate ETag\n    return generate_etag_for_resource()\n</code></pre>"},{"location":"guide/etags/#http-status-codes","title":"HTTP Status Codes","text":"Status Meaning When Used 200 OK Resource returned ETag doesn't match or no conditional header 304 Not Modified Resource unchanged If-None-Match matches current ETag 412 Precondition Failed Condition not met If-Match doesn't match current ETag"},{"location":"guide/etags/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Multi-Value Headers for advanced header handling</li> <li>Explore Performance Optimization with caching strategies</li> <li>Read about State Machine for understanding conditional request flow</li> </ul>"},{"location":"guide/openapi/","title":"OpenAPI (Swagger) Generation","text":"<p>RestMachine automatically generates OpenAPI 3.0 specifications from your application code. This enables automatic API documentation, client SDK generation, and integration with tools like Swagger UI.</p>"},{"location":"guide/openapi/#quick-start","title":"Quick Start","text":"<p>Generate an OpenAPI spec from your application:</p> <pre><code>from restmachine import RestApplication\nfrom pydantic import BaseModel, EmailStr\n\napp = RestApplication()\n\nclass UserCreate(BaseModel):\n    name: str\n    email: EmailStr\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n@app.on_startup\ndef database():\n    return {\"users\": {}}\n\n@app.resource_exists\ndef user(path_params, database):\n    user_id = path_params.get('user_id')\n    return database[\"users\"].get(user_id)\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    \"\"\"Get a user by ID.\"\"\"\n    return user\n\n@app.post('/users')\ndef create_user(user_create: UserCreate, database):\n    \"\"\"Create a new user.\"\"\"\n    user_id = str(len(database[\"users\"]) + 1)\n    user = {\"id\": user_id, **user_create.model_dump()}\n    database[\"users\"][user_id] = user\n    return user, 201\n\n# Generate OpenAPI spec\nopenapi_json = app.generate_openapi_json(\n    title=\"User API\",\n    version=\"1.0.0\",\n    description=\"API for managing users\"\n)\n\n# Or save to file\napp.save_openapi_json(\n    filename=\"openapi.json\",\n    docs_dir=\"docs\",\n    title=\"User API\",\n    version=\"1.0.0\"\n)\n</code></pre>"},{"location":"guide/openapi/#generating-specifications","title":"Generating Specifications","text":""},{"location":"guide/openapi/#generate-as-json-string","title":"Generate as JSON String","text":"<p>Get the OpenAPI spec as a JSON string:</p> <pre><code>openapi_json = app.generate_openapi_json(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"My awesome API\"\n)\n\n# Parse if needed\nimport json\nspec = json.loads(openapi_json)\nprint(spec[\"info\"][\"title\"])  # \"My API\"\n</code></pre>"},{"location":"guide/openapi/#save-to-file","title":"Save to File","text":"<p>Save the spec directly to a file:</p> <pre><code>file_path = app.save_openapi_json(\n    filename=\"openapi.json\",     # Output filename\n    docs_dir=\"docs\",              # Output directory\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"API documentation\"\n)\n\nprint(f\"OpenAPI spec saved to: {file_path}\")\n# Output: OpenAPI spec saved to: docs/openapi.json\n</code></pre>"},{"location":"guide/openapi/#automatic-schema-detection","title":"Automatic Schema Detection","text":"<p>RestMachine automatically detects schemas from:</p>"},{"location":"guide/openapi/#path-parameters","title":"Path Parameters","text":"<p>Path parameters are extracted from route patterns:</p> <pre><code>@app.get('/users/{user_id}')\ndef get_user(path_params):\n    return {\"user_id\": path_params['user_id']}\n</code></pre> <p>OpenAPI output: <pre><code>{\n  \"paths\": {\n    \"/users/{user_id}\": {\n      \"get\": {\n        \"parameters\": [\n          {\n            \"name\": \"user_id\",\n            \"in\": \"path\",\n            \"required\": true,\n            \"schema\": {\"type\": \"string\"}\n          }\n        ]\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"guide/openapi/#path-parameters-with-validation","title":"Path Parameters with Validation","text":"<p>Use Pydantic models for typed path parameters:</p> <pre><code>from pydantic import BaseModel\n\nclass PathParams(BaseModel):\n    user_id: str\n    post_id: int\n\n@app.validates\ndef path_params_model(path_params) -&gt; PathParams:\n    return PathParams.model_validate(path_params)\n\n@app.get('/users/{user_id}/posts/{post_id}')\ndef get_post(path_params_model: PathParams):\n    return {\n        \"user_id\": path_params_model.user_id,\n        \"post_id\": path_params_model.post_id\n    }\n</code></pre> <p>OpenAPI output includes type information: <pre><code>{\n  \"parameters\": [\n    {\n      \"name\": \"user_id\",\n      \"in\": \"path\",\n      \"required\": true,\n      \"schema\": {\"type\": \"string\"}\n    },\n    {\n      \"name\": \"post_id\",\n      \"in\": \"path\",\n      \"required\": true,\n      \"schema\": {\"type\": \"integer\"}\n    }\n  ]\n}\n</code></pre></p>"},{"location":"guide/openapi/#query-parameters","title":"Query Parameters","text":"<p>Query parameter schemas are detected from validation dependencies:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass ListParams(BaseModel):\n    page: int = Field(default=1, ge=1, description=\"Page number\")\n    limit: int = Field(default=20, ge=1, le=100, description=\"Items per page\")\n    sort_by: str | None = Field(default=None, description=\"Sort field\")\n\n@app.validates\ndef list_params(query_params) -&gt; ListParams:\n    return ListParams.model_validate(query_params)\n\n@app.get('/users')\ndef list_users(list_params: ListParams, database):\n    \"\"\"List users with pagination.\"\"\"\n    return {\"users\": [], \"page\": list_params.page}\n</code></pre> <p>OpenAPI includes query parameter definitions: <pre><code>{\n  \"parameters\": [\n    {\n      \"name\": \"page\",\n      \"in\": \"query\",\n      \"required\": false,\n      \"schema\": {\"type\": \"integer\", \"minimum\": 1, \"default\": 1},\n      \"description\": \"Page number\"\n    },\n    {\n      \"name\": \"limit\",\n      \"in\": \"query\",\n      \"required\": false,\n      \"schema\": {\"type\": \"integer\", \"minimum\": 1, \"maximum\": 100, \"default\": 20},\n      \"description\": \"Items per page\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"guide/openapi/#request-bodies","title":"Request Bodies","text":"<p>Request body schemas from validation dependencies:</p> <pre><code>from pydantic import BaseModel, EmailStr, Field\n\nclass UserCreate(BaseModel):\n    name: str = Field(min_length=1, max_length=100, description=\"User's full name\")\n    email: EmailStr = Field(description=\"User's email address\")\n    age: int = Field(ge=18, le=120, description=\"User's age\")\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n@app.post('/users')\ndef create_user(user_create: UserCreate):\n    \"\"\"Create a new user.\"\"\"\n    return {\"created\": user_create.model_dump()}, 201\n</code></pre> <p>OpenAPI includes request body schema: <pre><code>{\n  \"requestBody\": {\n    \"required\": true,\n    \"content\": {\n      \"application/json\": {\n        \"schema\": {\n          \"$ref\": \"#/components/schemas/UserCreate\"\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"UserCreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 100,\n            \"description\": \"User's full name\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"description\": \"User's email address\"\n          },\n          \"age\": {\n            \"type\": \"integer\",\n            \"minimum\": 18,\n            \"maximum\": 120,\n            \"description\": \"User's age\"\n          }\n        },\n        \"required\": [\"name\", \"email\", \"age\"]\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"guide/openapi/#response-schemas","title":"Response Schemas","text":"<p>Document response schemas using type hints:</p> <pre><code>from pydantic import BaseModel\nfrom typing import List\n\nclass User(BaseModel):\n    id: str\n    name: str\n    email: str\n\nclass UserList(BaseModel):\n    users: List[User]\n    total: int\n\n@app.get('/users')\ndef list_users() -&gt; UserList:\n    \"\"\"List all users.\"\"\"\n    return UserList(users=[], total=0)\n</code></pre>"},{"location":"guide/openapi/#using-docstrings","title":"Using Docstrings","text":"<p>Handler docstrings become operation descriptions:</p> <pre><code>@app.get('/users/{user_id}')\ndef get_user(user):\n    \"\"\"\n    Get a user by ID.\n\n    Returns user information including name, email, and creation date.\n    Returns 404 if the user is not found.\n    \"\"\"\n    return user\n\n@app.post('/users')\ndef create_user(user_create: UserCreate):\n    \"\"\"\n    Create a new user.\n\n    Validates the user data and creates a new user account.\n    Email must be unique. Returns 422 for validation errors.\n    \"\"\"\n    return {\"created\": True}, 201\n</code></pre> <p>These docstrings appear in the OpenAPI spec: <pre><code>{\n  \"paths\": {\n    \"/users/{user_id}\": {\n      \"get\": {\n        \"summary\": \"Get a user by ID\",\n        \"description\": \"Returns user information including name, email, and creation date.\\nReturns 404 if the user is not found.\"\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"guide/openapi/#integration-with-swagger-ui","title":"Integration with Swagger UI","text":""},{"location":"guide/openapi/#serving-openapi-spec","title":"Serving OpenAPI Spec","text":"<p>Serve the OpenAPI spec from your API:</p> <pre><code>@app.get('/openapi.json')\ndef get_openapi_spec():\n    \"\"\"Return OpenAPI specification.\"\"\"\n    import json\n    return json.loads(app.generate_openapi_json(\n        title=\"My API\",\n        version=\"1.0.0\"\n    ))\n</code></pre>"},{"location":"guide/openapi/#using-swagger-ui","title":"Using Swagger UI","text":"<p>Add Swagger UI to visualize your API:</p> <pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n# Your API routes...\n\n@app.get('/openapi.json')\ndef openapi_spec():\n    \"\"\"OpenAPI specification endpoint.\"\"\"\n    import json\n    return json.loads(app.generate_openapi_json(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API documentation\"\n    ))\n\n@app.get('/docs')\ndef swagger_ui():\n    \"\"\"Swagger UI documentation page.\"\"\"\n    return \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;API Documentation&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"swagger-ui\"&gt;&lt;/div&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n            SwaggerUIBundle({\n                url: '/openapi.json',\n                dom_id: '#swagger-ui',\n            });\n        &lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre> <p>Access Swagger UI at <code>http://localhost:8000/docs</code>.</p>"},{"location":"guide/openapi/#using-redoc","title":"Using ReDoc","text":"<p>Alternative documentation with ReDoc:</p> <pre><code>@app.get('/redoc')\ndef redoc_ui():\n    \"\"\"ReDoc documentation page.\"\"\"\n    return \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;API Documentation&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;redoc spec-url=\"/openapi.json\"&gt;&lt;/redoc&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/npm/redoc@latest/bundles/redoc.standalone.js\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre>"},{"location":"guide/openapi/#build-time-generation","title":"Build-Time Generation","text":"<p>Generate OpenAPI specs during your build process:</p> <pre><code># scripts/generate_openapi.py\nfrom my_app import app\n\nif __name__ == \"__main__\":\n    app.save_openapi_json(\n        filename=\"openapi.json\",\n        docs_dir=\"docs\",\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"Production API documentation\"\n    )\n    print(\"OpenAPI spec generated!\")\n</code></pre> <p>Run during build: <pre><code>python scripts/generate_openapi.py\n</code></pre></p>"},{"location":"guide/openapi/#client-sdk-generation","title":"Client SDK Generation","text":"<p>Use the OpenAPI spec to generate client SDKs:</p>"},{"location":"guide/openapi/#using-openapi-generator","title":"Using OpenAPI Generator","text":"<pre><code># Generate TypeScript client\nopenapi-generator-cli generate \\\n    -i docs/openapi.json \\\n    -g typescript-axios \\\n    -o clients/typescript\n\n# Generate Python client\nopenapi-generator-cli generate \\\n    -i docs/openapi.json \\\n    -g python \\\n    -o clients/python\n\n# Generate Java client\nopenapi-generator-cli generate \\\n    -i docs/openapi.json \\\n    -g java \\\n    -o clients/java\n</code></pre>"},{"location":"guide/openapi/#using-openapi-typescript-codegen","title":"Using OpenAPI TypeScript Codegen","text":"<pre><code>npx openapi-typescript-codegen \\\n    --input docs/openapi.json \\\n    --output src/api \\\n    --client axios\n</code></pre>"},{"location":"guide/openapi/#complete-example","title":"Complete Example","text":"<p>Full API with OpenAPI documentation:</p> <pre><code>from restmachine import RestApplication\nfrom pydantic import BaseModel, EmailStr, Field\nfrom typing import List\n\napp = RestApplication()\n\n# Models\nclass UserCreate(BaseModel):\n    name: str = Field(min_length=1, description=\"User's name\")\n    email: EmailStr = Field(description=\"User's email\")\n\nclass User(BaseModel):\n    id: str\n    name: str\n    email: str\n\nclass UserList(BaseModel):\n    users: List[User]\n    total: int\n\n# Database\n@app.on_startup\ndef database():\n    return {\n        \"users\": {\n            \"1\": {\"id\": \"1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n        }\n    }\n\n# Validation\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n@app.resource_exists\ndef user(path_params, database):\n    user_id = path_params.get('user_id')\n    return database[\"users\"].get(user_id)\n\n# Routes\n@app.get('/users')\ndef list_users(database) -&gt; UserList:\n    \"\"\"\n    List all users.\n\n    Returns a paginated list of all registered users.\n    \"\"\"\n    users_list = [User(**u) for u in database[\"users\"].values()]\n    return UserList(users=users_list, total=len(users_list))\n\n@app.get('/users/{user_id}')\ndef get_user(user) -&gt; User:\n    \"\"\"\n    Get a user by ID.\n\n    Returns user details including name and email.\n    Returns 404 if user not found.\n    \"\"\"\n    return User(**user)\n\n@app.post('/users')\ndef create_user(user_create: UserCreate, database):\n    \"\"\"\n    Create a new user.\n\n    Creates a new user account with the provided information.\n    Email must be unique. Returns 422 for validation errors.\n    \"\"\"\n    user_id = str(len(database[\"users\"]) + 1)\n    user = {\"id\": user_id, **user_create.model_dump()}\n    database[\"users\"][user_id] = user\n    return User(**user), 201\n\n@app.delete('/users/{user_id}')\ndef delete_user(user, path_params, database):\n    \"\"\"\n    Delete a user.\n\n    Permanently removes a user account.\n    Returns 404 if user not found.\n    \"\"\"\n    user_id = path_params['user_id']\n    del database[\"users\"][user_id]\n    return None\n\n# OpenAPI endpoint\n@app.get('/openapi.json')\ndef openapi_spec():\n    \"\"\"OpenAPI 3.0 specification.\"\"\"\n    import json\n    return json.loads(app.generate_openapi_json(\n        title=\"User Management API\",\n        version=\"1.0.0\",\n        description=\"API for managing user accounts\"\n    ))\n\n# Documentation UI\n@app.get('/docs')\ndef swagger_ui():\n    \"\"\"Interactive API documentation.\"\"\"\n    return \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;User API Documentation&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"swagger-ui\"&gt;&lt;/div&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n            SwaggerUIBundle({\n                url: '/openapi.json',\n                dom_id: '#swagger-ui',\n            });\n        &lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n# Save spec to file (optional - useful for CI/CD)\nif __name__ == \"__main__\":\n    app.save_openapi_json(\n        filename=\"openapi.json\",\n        docs_dir=\"docs\",\n        title=\"User Management API\",\n        version=\"1.0.0\",\n        description=\"API for managing user accounts\"\n    )\n    print(\"OpenAPI spec saved to docs/openapi.json\")\n</code></pre>"},{"location":"guide/openapi/#best-practices","title":"Best Practices","text":""},{"location":"guide/openapi/#1-use-pydantic-models","title":"1. Use Pydantic Models","text":"<p>Always use Pydantic models for comprehensive schema generation:</p> <pre><code># Good - generates complete schema\nclass UserCreate(BaseModel):\n    name: str\n    email: EmailStr\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n# Less ideal - schema inference limited\n@app.post('/users')\ndef create_user(json_body):\n    return {\"created\": True}\n</code></pre>"},{"location":"guide/openapi/#2-add-field-descriptions","title":"2. Add Field Descriptions","text":"<p>Use Field descriptions for better documentation:</p> <pre><code>from pydantic import Field\n\nclass UserCreate(BaseModel):\n    name: str = Field(\n        min_length=1,\n        max_length=100,\n        description=\"User's full name\"\n    )\n    email: EmailStr = Field(\n        description=\"User's email address (must be unique)\"\n    )\n</code></pre>"},{"location":"guide/openapi/#3-write-clear-docstrings","title":"3. Write Clear Docstrings","text":"<p>Document your endpoints with clear docstrings:</p> <pre><code>@app.get('/users/{user_id}')\ndef get_user(user):\n    \"\"\"\n    Get user by ID.\n\n    Retrieves detailed information about a specific user.\n\n    Returns:\n        User object with id, name, and email\n\n    Errors:\n        404: User not found\n    \"\"\"\n    return user\n</code></pre>"},{"location":"guide/openapi/#4-version-your-api","title":"4. Version Your API","text":"<p>Include version in your OpenAPI spec:</p> <pre><code>app.generate_openapi_json(\n    title=\"My API\",\n    version=\"2.1.0\",  # Use semantic versioning\n    description=\"Production API v2\"\n)\n</code></pre>"},{"location":"guide/openapi/#5-generate-at-build-time","title":"5. Generate at Build Time","text":"<p>Generate specs during deployment:</p> <pre><code># In your CI/CD pipeline\npython -c \"from app import app; app.save_openapi_json()\"\n</code></pre>"},{"location":"guide/openapi/#next-steps","title":"Next Steps","text":"<ul> <li>Testing \u2192 - Test your API</li> <li>Deployment \u2192 - Deploy with documentation</li> <li>Validation \u2192 - Request validation with Pydantic</li> <li>Content Negotiation \u2192 - Multiple response formats</li> </ul>"},{"location":"guide/testing/","title":"Testing Your Application","text":"<p>RestMachine provides comprehensive testing utilities to help you write robust tests for your REST APIs. This guide covers both simple testing patterns and the advanced 4-layer testing architecture.</p>"},{"location":"guide/testing/#quick-start","title":"Quick Start","text":""},{"location":"guide/testing/#direct-request-testing","title":"Direct Request Testing","text":"<p>The simplest way to test your RestMachine application is to create requests directly and execute them:</p> <pre><code>from restmachine import RestApplication, Request, HTTPMethod\n\ndef test_get_user():\n    app = RestApplication()\n\n    @app.get(\"/users/{user_id}\")\n    def get_user(user_id: int):\n        return {\"id\": user_id, \"name\": \"Test User\"}\n\n    # Create a request\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/users/123\",\n        headers={\"Accept\": \"application/json\"}\n    )\n\n    # Execute the request\n    response = app.execute(request)\n\n    # Assert the response\n    assert response.status_code == 200\n    assert response.body == '{\"id\": 123, \"name\": \"Test User\"}'\n</code></pre>"},{"location":"guide/testing/#testing-with-pytest","title":"Testing with Pytest","text":"<p>RestMachine works seamlessly with pytest:</p> <pre><code>import pytest\nfrom restmachine import RestApplication, Request, HTTPMethod\nimport json\n\n@pytest.fixture\ndef app():\n    \"\"\"Create a test application.\"\"\"\n    app = RestApplication()\n\n    @app.get(\"/health\")\n    def health():\n        return {\"status\": \"ok\"}\n\n    @app.get(\"/users\")\n    def list_users():\n        return [\n            {\"id\": 1, \"name\": \"Alice\"},\n            {\"id\": 2, \"name\": \"Bob\"}\n        ]\n\n    return app\n\ndef test_health_check(app):\n    \"\"\"Test health endpoint.\"\"\"\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/health\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    data = json.loads(response.body)\n    assert data[\"status\"] == \"ok\"\n\ndef test_list_users(app):\n    \"\"\"Test user listing.\"\"\"\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/users\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    users = json.loads(response.body)\n    assert len(users) == 2\n    assert users[0][\"name\"] == \"Alice\"\n</code></pre>"},{"location":"guide/testing/#advanced-testing-with-dsl","title":"Advanced Testing with DSL","text":"<p>RestMachine provides a powerful Domain-Specific Language (DSL) for testing, based on Dave Farley's 4-layer testing architecture.</p>"},{"location":"guide/testing/#4-layer-architecture","title":"4-Layer Architecture","text":"<ol> <li>Test Layer - Your actual test methods</li> <li>DSL Layer - Business-focused API operations</li> <li>Driver Layer - How to execute requests</li> <li>System Under Test - Your RestMachine application</li> </ol>"},{"location":"guide/testing/#using-the-dsl","title":"Using the DSL","text":"<p>The DSL provides a fluent, readable API for testing:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine.testing import RestApiDsl, RestMachineDriver\n\ndef test_create_user_with_dsl():\n    # Create app\n    app = RestApplication()\n\n    @app.post(\"/users\")\n    def create_user(json_body: dict):\n        return {\"id\": 1, **json_body}, 201\n\n    # Create DSL client\n    driver = RestMachineDriver(app)\n    api = RestApiDsl(driver)\n\n    # Create request using fluent API\n    request = (api.post(\"/users\")\n        .with_json_body({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        .accepts(\"application/json\"))\n\n    # Execute and verify\n    response = api.execute(request)\n\n    assert response.status_code == 201\n    data = response.get_json_body()\n    assert data[\"name\"] == \"Alice\"\n    assert data[\"email\"] == \"alice@example.com\"\n</code></pre>"},{"location":"guide/testing/#business-focused-methods","title":"Business-Focused Methods","text":"<p>The DSL includes business-focused methods that hide HTTP details:</p> <pre><code>from restmachine.testing import RestApiDsl, RestMachineDriver\n\ndef test_resource_operations():\n    app = RestApplication()\n\n    @app.get(\"/items/{item_id}\")\n    def get_item(item_id: int):\n        return {\"id\": item_id, \"name\": \"Test Item\"}\n\n    @app.post(\"/items\")\n    def create_item(json_body: dict):\n        return {\"id\": 1, **json_body}, 201\n\n    api = RestApiDsl(RestMachineDriver(app))\n\n    # Get a resource\n    response = api.get_resource(\"/items/123\")\n    item = api.expect_successful_retrieval(response)\n    assert item[\"id\"] == 123\n\n    # Create a resource\n    response = api.create_resource(\"/items\", {\"name\": \"New Item\"})\n    created = api.expect_successful_creation(response)\n    assert created[\"name\"] == \"New Item\"\n\n    # Update a resource\n    response = api.update_resource(\"/items/1\", {\"name\": \"Updated\"})\n    api.expect_successful_modification(response)\n\n    # Delete a resource\n    response = api.delete_resource(\"/items/1\")\n    api.expect_successful_deletion(response)\n</code></pre>"},{"location":"guide/testing/#multi-driver-testing","title":"Multi-Driver Testing","text":"<p>Test your application across multiple environments (direct, ASGI, HTTP) automatically:</p>"},{"location":"guide/testing/#setup-multi-driver-tests","title":"Setup Multi-Driver Tests","text":"<pre><code>from restmachine import RestApplication\nfrom restmachine.testing import MultiDriverTestBase\n\nclass TestUserApi(MultiDriverTestBase):\n    \"\"\"Test user API across all drivers.\"\"\"\n\n    def create_app(self) -&gt; RestApplication:\n        \"\"\"Create the application to test.\"\"\"\n        app = RestApplication()\n\n        @app.get(\"/users/{user_id}\")\n        def get_user(user_id: int):\n            return {\"id\": user_id, \"name\": f\"User {user_id}\"}\n\n        @app.post(\"/users\")\n        def create_user(json_body: dict):\n            return {\"id\": 1, **json_body}, 201\n\n        return app\n\n    def test_get_user(self, api):\n        \"\"\"Test getting a user (runs on all drivers).\"\"\"\n        api_client, driver_name = api\n\n        response = api_client.get_resource(\"/users/42\")\n        user = api_client.expect_successful_retrieval(response)\n\n        assert user[\"id\"] == 42\n        assert user[\"name\"] == \"User 42\"\n\n    def test_create_user(self, api):\n        \"\"\"Test creating a user (runs on all drivers).\"\"\"\n        api_client, driver_name = api\n\n        user_data = {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n        response = api_client.create_resource(\"/users\", user_data)\n\n        created = api_client.expect_successful_creation(response)\n        assert created[\"name\"] == \"Alice\"\n        assert created[\"email\"] == \"alice@example.com\"\n</code></pre>"},{"location":"guide/testing/#driver-specific-tests","title":"Driver-Specific Tests","text":"<p>Skip or run tests only on specific drivers:</p> <pre><code>from restmachine.testing import MultiDriverTestBase, skip_driver, only_drivers\n\nclass TestAdvancedFeatures(MultiDriverTestBase):\n\n    def create_app(self) -&gt; RestApplication:\n        # ... create app\n\n    @skip_driver(\"mock\")\n    def test_real_http_only(self, api):\n        \"\"\"This test skips the mock driver.\"\"\"\n        api_client, driver_name = api\n        # Test real HTTP-specific features\n        pass\n\n    @only_drivers([\"uvicorn\", \"hypercorn\"])\n    def test_asgi_only(self, api):\n        \"\"\"This test runs only on ASGI drivers.\"\"\"\n        api_client, driver_name = api\n        # Test ASGI-specific features\n        pass\n</code></pre>"},{"location":"guide/testing/#testing-dependencies","title":"Testing Dependencies","text":""},{"location":"guide/testing/#mocking-dependencies","title":"Mocking Dependencies","text":"<p>Replace dependencies with mocks for testing:</p> <pre><code>def test_with_mock_database():\n    app = RestApplication()\n\n    # Mock database dependency\n    @app.dependency()\n    def database():\n        return {\"users\": [{\"id\": 1, \"name\": \"Test\"}]}\n\n    @app.get(\"/users\")\n    def get_users(database):\n        return database[\"users\"]\n\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/users\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    users = json.loads(response.body)\n    assert len(users) == 1\n</code></pre>"},{"location":"guide/testing/#testing-startup-handlers","title":"Testing Startup Handlers","text":"<p>Startup handlers run automatically during testing:</p> <pre><code>def test_startup_handlers():\n    app = RestApplication()\n\n    @app.on_startup\n    def test_config():\n        return {\"api_key\": \"test-key-123\"}\n\n    @app.get(\"/config\")\n    def get_config(test_config):\n        return test_config\n\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/config\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    config = json.loads(response.body)\n    assert config[\"api_key\"] == \"test-key-123\"\n</code></pre>"},{"location":"guide/testing/#testing-error-handling","title":"Testing Error Handling","text":""},{"location":"guide/testing/#testing-validation-errors","title":"Testing Validation Errors","text":"<pre><code>from pydantic import BaseModel\n\ndef test_validation_errors():\n    app = RestApplication()\n\n    class CreateUser(BaseModel):\n        name: str\n        email: str\n        age: int\n\n    @app.validates\n    def create_user_data(json_body) -&gt; CreateUser:\n        return CreateUser.model_validate(json_body)\n\n    @app.post(\"/users\")\n    def create_user(create_user_data: CreateUser):\n        return create_user_data.model_dump(), 201\n\n    # Invalid data (missing required field)\n    request = Request(\n        method=HTTPMethod.POST,\n        path=\"/users\",\n        headers={\"Content-Type\": \"application/json\"},\n        body='{\"name\": \"Alice\"}'  # Missing email and age\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 400\n    error = json.loads(response.body)\n    assert \"email\" in str(error)\n</code></pre>"},{"location":"guide/testing/#testing-authorization","title":"Testing Authorization","text":"<pre><code>def test_unauthorized_access():\n    app = RestApplication()\n\n    @app.authorized\n    def check_auth(request):\n        token = request.headers.get(\"authorization\")\n        if not token or not token.startswith(\"Bearer \"):\n            return None  # Unauthorized\n        return {\"user\": \"alice\"}\n\n    @app.get(\"/protected\")\n    def protected_route(check_auth):\n        return {\"message\": \"Access granted\"}\n\n    # Without auth token\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/protected\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n    assert response.status_code == 401\n\n    # With valid token\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/protected\",\n        headers={\n            \"Accept\": \"application/json\",\n            \"Authorization\": \"Bearer valid-token\"\n        }\n    )\n    response = app.execute(request)\n    assert response.status_code == 200\n</code></pre>"},{"location":"guide/testing/#testing-with-different-content-types","title":"Testing with Different Content Types","text":""},{"location":"guide/testing/#json-responses","title":"JSON Responses","text":"<pre><code>def test_json_response():\n    app = RestApplication()\n\n    @app.get(\"/data\")\n    def get_data():\n        return {\"message\": \"Hello\", \"count\": 42}\n\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/data\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n\n    assert response.headers.get(\"Content-Type\") == \"application/json\"\n    data = json.loads(response.body)\n    assert data[\"message\"] == \"Hello\"\n</code></pre>"},{"location":"guide/testing/#xml-responses","title":"XML Responses","text":"<pre><code>def test_xml_response():\n    app = RestApplication()\n\n    @app.get(\"/data\")\n    def get_data():\n        return {\"message\": \"Hello\"}\n\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/data\",\n        headers={\"Accept\": \"application/xml\"}\n    )\n    response = app.execute(request)\n\n    assert response.headers.get(\"Content-Type\") == \"application/xml\"\n    assert b\"&lt;message&gt;Hello&lt;/message&gt;\" in response.body\n</code></pre>"},{"location":"guide/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"guide/testing/#testing-with-real-databases","title":"Testing with Real Databases","text":"<pre><code>import pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n@pytest.fixture\ndef database():\n    \"\"\"Create test database.\"\"\"\n    engine = create_engine(\"sqlite:///:memory:\")\n    Session = sessionmaker(bind=engine)\n    session = Session()\n    # Create tables, seed data\n    yield session\n    session.close()\n\ndef test_with_database(database):\n    app = RestApplication()\n\n    @app.dependency()\n    def db():\n        return database\n\n    @app.get(\"/users\")\n    def get_users(db):\n        # Query real database\n        users = db.query(User).all()\n        return [{\"id\": u.id, \"name\": u.name} for u in users]\n\n    # Test with real database\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/users\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n    assert response.status_code == 200\n</code></pre>"},{"location":"guide/testing/#best-practices","title":"Best Practices","text":""},{"location":"guide/testing/#1-use-fixtures-for-common-setup","title":"1. Use Fixtures for Common Setup","text":"<pre><code>@pytest.fixture\ndef auth_app():\n    \"\"\"App with authentication configured.\"\"\"\n    app = RestApplication()\n\n    @app.dependency()\n    def current_user():\n        return {\"id\": 1, \"name\": \"Test User\"}\n\n    @app.get(\"/me\")\n    def get_current_user(current_user):\n        return current_user\n\n    return app\n\ndef test_current_user(auth_app):\n    # Use the fixture\n    request = Request(\n        method=HTTPMethod.GET,\n        path=\"/me\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = auth_app.execute(request)\n    assert response.status_code == 200\n</code></pre>"},{"location":"guide/testing/#2-test-edge-cases","title":"2. Test Edge Cases","text":"<pre><code>def test_edge_cases():\n    app = RestApplication()\n\n    @app.get(\"/users/{user_id}\")\n    def get_user(user_id: int):\n        if user_id &lt;= 0:\n            return {\"error\": \"Invalid ID\"}, 400\n        if user_id &gt; 1000:\n            return None, 404\n        return {\"id\": user_id}\n\n    # Test negative ID\n    response = app.execute(Request(\n        method=HTTPMethod.GET,\n        path=\"/users/-1\",\n        headers={\"Accept\": \"application/json\"}\n    ))\n    assert response.status_code == 400\n\n    # Test large ID\n    response = app.execute(Request(\n        method=HTTPMethod.GET,\n        path=\"/users/9999\",\n        headers={\"Accept\": \"application/json\"}\n    ))\n    assert response.status_code == 404\n</code></pre>"},{"location":"guide/testing/#3-use-parametrized-tests","title":"3. Use Parametrized Tests","text":"<pre><code>@pytest.mark.parametrize(\"user_id,expected_name\", [\n    (1, \"Alice\"),\n    (2, \"Bob\"),\n    (3, \"Charlie\")\n])\ndef test_multiple_users(user_id, expected_name):\n    app = RestApplication()\n\n    users = {\n        1: \"Alice\",\n        2: \"Bob\",\n        3: \"Charlie\"\n    }\n\n    @app.get(\"/users/{user_id}\")\n    def get_user(user_id: int):\n        return {\"id\": user_id, \"name\": users.get(user_id)}\n\n    request = Request(\n        method=HTTPMethod.GET,\n        path=f\"/users/{user_id}\",\n        headers={\"Accept\": \"application/json\"}\n    )\n    response = app.execute(request)\n\n    assert response.status_code == 200\n    user = json.loads(response.body)\n    assert user[\"name\"] == expected_name\n</code></pre>"},{"location":"guide/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Authentication &amp; Authorization patterns</li> <li>Explore Error Handling strategies</li> <li>Read about Deployment options</li> </ul>"},{"location":"guide/usage/","title":"Usage Guide","text":"<p>This guide covers how to use RestMachine's decorators to build REST APIs. We'll start with the most common patterns and progress to advanced usage.</p>"},{"location":"guide/usage/#route-decorators","title":"Route Decorators","text":"<p>Route decorators define HTTP endpoints for your API.</p>"},{"location":"guide/usage/#basic-routes","title":"Basic Routes","text":"<pre><code>from restmachine import RestApplication\n\napp = RestApplication()\n\n@app.get('/users')\ndef list_users():\n    return {\"users\": [\"Alice\", \"Bob\"]}\n\n@app.post('/users')\ndef create_user(json_body):\n    return {\"created\": json_body}, 201\n\n@app.get('/users/{user_id}')\ndef get_user(path_params):\n    return {\"id\": path_params['user_id']}\n\n@app.put('/users/{user_id}')\ndef update_user(path_params, json_body):\n    return {\"id\": path_params['user_id'], \"data\": json_body}\n\n@app.patch('/users/{user_id}')\ndef partial_update(path_params, json_body):\n    return {\"id\": path_params['user_id'], \"updates\": json_body}\n\n@app.delete('/users/{user_id}')\ndef delete_user(path_params):\n    return None  # Returns 204 No Content\n\n@app.head('/users/{user_id}')\ndef check_user(path_params):\n    return None  # HEAD doesn't return body\n\n@app.options('/users')\ndef user_options():\n    return None, 200, {\"Allow\": \"GET, POST, OPTIONS\"}\n</code></pre>"},{"location":"guide/usage/#path-parameters","title":"Path Parameters","text":"<p>Extract values from URL paths:</p> <pre><code>@app.get('/users/{user_id}')\ndef get_user(path_params):\n    user_id = path_params['user_id']\n    return {\"id\": user_id}\n\n@app.get('/posts/{post_id}/comments/{comment_id}')\ndef get_comment(path_params):\n    return {\n        \"post_id\": path_params['post_id'],\n        \"comment_id\": path_params['comment_id']\n    }\n</code></pre>"},{"location":"guide/usage/#query-parameters","title":"Query Parameters","text":"<p>Access query string parameters:</p> <pre><code>@app.get('/search')\ndef search(query_params):\n    query = query_params.get('q', '')\n    limit = int(query_params.get('limit', '20'))\n    return {\"query\": query, \"limit\": limit}\n</code></pre>"},{"location":"guide/usage/#request-body","title":"Request Body","text":"<p>Access request data through dependencies:</p> <pre><code># JSON body\n@app.post('/data')\ndef handle_json(json_body):\n    return {\"received\": json_body}\n\n# Headers\n@app.get('/headers')\ndef show_headers(request_headers):\n    user_agent = request_headers.get('user-agent')\n    return {\"user_agent\": user_agent}\n\n# Full request object\n@app.post('/raw')\ndef handle_raw(request):\n    method = request.method\n    path = request.path\n    body = request.body\n    return {\"method\": method, \"path\": path}\n</code></pre>"},{"location":"guide/usage/#resource-decorators","title":"Resource Decorators","text":"<p>Resource decorators define facts about your resources that the state machine uses to make decisions.</p>"},{"location":"guide/usage/#resource-existence","title":"Resource Existence","text":"<p>Automatically handle 404 responses:</p> <pre><code>@app.on_startup\ndef database():\n    return {\"users\": {\"1\": {\"id\": \"1\", \"name\": \"Alice\"}}}\n\n@app.resource_exists\ndef user(path_params, database):\n    \"\"\"Returns None if not found, triggering automatic 404.\"\"\"\n    user_id = path_params['user_id']\n    return database[\"users\"].get(user_id)\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    # If user is None, 404 already returned\n    # Otherwise user is cached and available here\n    return user\n\n@app.delete('/users/{user_id}')\ndef delete_user(user, database):\n    # Same resource_exists dependency\n    # Automatic 404 if user doesn't exist\n    database[\"users\"].pop(user['id'])\n    return None\n</code></pre>"},{"location":"guide/usage/#validation","title":"Validation","text":"<p>Validate requests with Pydantic models:</p> <pre><code>from pydantic import BaseModel, EmailStr, Field\n\nclass UserCreate(BaseModel):\n    name: str = Field(min_length=1, max_length=100)\n    email: EmailStr\n    age: int = Field(ge=0, le=150)\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    \"\"\"Returns 400/422 automatically on validation error.\"\"\"\n    return UserCreate.model_validate(json_body)\n\n@app.post('/users')\ndef create_user(user_create: UserCreate, database):\n    # Validation already handled by state machine\n    user = user_create.model_dump()\n    user['id'] = generate_id()\n    database[\"users\"][user['id']] = user\n    return user, 201\n</code></pre> <p>Multiple validation decorators for different endpoints:</p> <pre><code>class UserUpdate(BaseModel):\n    name: str | None = None\n    email: EmailStr | None = None\n\n@app.validates\ndef user_update(json_body) -&gt; UserUpdate:\n    return UserUpdate.model_validate(json_body)\n\n@app.put('/users/{user_id}')\ndef update_user(user, user_update: UserUpdate):\n    # Both validations applied automatically\n    if user_update.name:\n        user['name'] = user_update.name\n    if user_update.email:\n        user['email'] = user_update.email\n    return user\n</code></pre>"},{"location":"guide/usage/#state-machine-decorators","title":"State Machine Decorators","text":"<p>State machine decorators define decision points that determine HTTP responses.</p>"},{"location":"guide/usage/#authorization","title":"Authorization","text":"<p>Check if requests are authenticated:</p> <pre><code>@app.dependency()\ndef current_user(request_headers, database):\n    token = request_headers.get('authorization', '').replace('Bearer ', '')\n    return database.get_user_by_token(token)\n\n@app.authorized\ndef check_auth(current_user):\n    \"\"\"Returns 401 if False.\"\"\"\n    return current_user is not None\n\n@app.get('/protected')\ndef protected_resource(current_user):\n    return {\"user\": current_user, \"message\": \"Access granted\"}\n</code></pre> <p>Per-route authorization:</p> <pre><code>@app.get('/admin/users')\n@app.authorized\ndef check_admin_auth(current_user):\n    \"\"\"Route-specific authorization check.\"\"\"\n    return current_user and current_user.get('is_admin')\n\ndef admin_users(database):\n    return {\"users\": database.get_all_users()}\n</code></pre>"},{"location":"guide/usage/#permissions","title":"Permissions","text":"<p>Check if authenticated users have required permissions:</p> <pre><code>@app.forbidden\ndef check_permission(current_user, path_params):\n    \"\"\"Returns 403 if True (access is forbidden).\"\"\"\n    # Allow users to access their own resources\n    requested_user_id = path_params.get('user_id')\n    is_own_resource = current_user['id'] == requested_user_id\n    is_admin = current_user.get('is_admin', False)\n\n    # Forbidden if not own resource and not admin\n    return not is_own_resource and not is_admin\n\n@app.put('/users/{user_id}')\ndef update_user(user, json_body):\n    # 401 if not authenticated\n    # 403 if not authorized (not own resource and not admin)\n    # Otherwise update proceeds\n    user.update(json_body)\n    return user\n</code></pre>"},{"location":"guide/usage/#conditional-requests-etags","title":"Conditional Requests (ETags)","text":"<p>Enable efficient caching with ETags:</p> <pre><code>import hashlib\n\n@app.etag\ndef user_etag(user):\n    \"\"\"Calculate ETag for user resource.\"\"\"\n    if not user:\n        return None\n    import json\n    content = json.dumps(user, sort_keys=True)\n    return f'\"{hashlib.md5(content.encode()).hexdigest()}\"'\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    # If client sends If-None-Match with matching ETag \u2192 304 Not Modified\n    # Otherwise \u2192 200 OK with user data\n    return user\n\n@app.put('/users/{user_id}')\ndef update_user(user, json_body):\n    # If client sends If-Match and it doesn't match \u2192 412 Precondition Failed\n    # This prevents mid-air collisions\n    user.update(json_body)\n    return user\n</code></pre>"},{"location":"guide/usage/#last-modified","title":"Last-Modified","text":"<p>Enable time-based conditional requests:</p> <pre><code>from datetime import datetime\n\n@app.last_modified\ndef user_last_modified(user):\n    \"\"\"Return last modification time.\"\"\"\n    if not user:\n        return None\n    return datetime.fromisoformat(user['updated_at'])\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    # If client sends If-Modified-Since and resource not modified \u2192 304 Not Modified\n    return user\n</code></pre>"},{"location":"guide/usage/#service-availability","title":"Service Availability","text":"<p>Control when your API is available:</p> <pre><code>import os\n\n@app.service_available\ndef check_maintenance(request):\n    \"\"\"Returns 503 if False.\"\"\"\n    # Allow health checks during maintenance\n    if request.path == '/health':\n        return True\n\n    # Check maintenance mode\n    return not os.environ.get('MAINTENANCE_MODE')\n\n@app.get('/health')\ndef health_check():\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"guide/usage/#method-checking","title":"Method Checking","text":"<p>Control which HTTP methods are supported:</p> <pre><code>@app.known_method\ndef check_method(request):\n    \"\"\"Returns 501 if False.\"\"\"\n    allowed = {'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'}\n    return request.method.value in allowed\n</code></pre>"},{"location":"guide/usage/#content-rendering","title":"Content Rendering","text":"<p>Define how responses are rendered in different formats.</p>"},{"location":"guide/usage/#multiple-content-types","title":"Multiple Content Types","text":"<p>Support multiple response formats:</p> <pre><code>import json\n\n@app.content_renderer(\"application/json\")\ndef render_json(data):\n    return json.dumps(data)\n\n@app.content_renderer(\"application/xml\")\ndef render_xml(data):\n    return f\"&lt;data&gt;{data}&lt;/data&gt;\"\n\n@app.content_renderer(\"text/csv\")\ndef render_csv(data):\n    if isinstance(data, list):\n        return \"\\n\".join(str(item) for item in data)\n    return str(data)\n\n@app.get('/data')\ndef get_data():\n    return {\"message\": \"Hello\"}\n    # Client sends Accept: application/json \u2192 JSON response\n    # Client sends Accept: application/xml  \u2192 XML response\n    # Client sends Accept: text/csv         \u2192 CSV response\n</code></pre>"},{"location":"guide/usage/#template-rendering","title":"Template Rendering","text":"<p>Render HTML templates:</p> <pre><code>@app.content_renderer(\"text/html\")\ndef render_html(data):\n    # Use your preferred template engine\n    from jinja2 import Template\n    template = Template(\"&lt;h1&gt;{{ title }}&lt;/h1&gt;&lt;p&gt;{{ message }}&lt;/p&gt;\")\n    return template.render(**data)\n\n@app.get('/page')\ndef show_page():\n    return {\n        \"title\": \"Welcome\",\n        \"message\": \"Hello, World!\"\n    }\n    # Accept: text/html \u2192 Rendered HTML page\n</code></pre>"},{"location":"guide/usage/#dependency-decorators","title":"Dependency Decorators","text":"<p>Create reusable dependencies for your application.</p>"},{"location":"guide/usage/#basic-dependencies","title":"Basic Dependencies","text":"<pre><code>@app.dependency()\ndef database():\n    return create_db_connection()\n\n@app.dependency()\ndef pagination(query_params):\n    page = int(query_params.get('page', '1'))\n    limit = int(query_params.get('limit', '20'))\n    return {\"page\": page, \"limit\": limit, \"offset\": (page - 1) * limit}\n\n@app.get('/users')\ndef list_users(database, pagination):\n    users = database.get_users(\n        offset=pagination['offset'],\n        limit=pagination['limit']\n    )\n    return {\"users\": users, \"page\": pagination['page']}\n</code></pre>"},{"location":"guide/usage/#lifecycle-dependencies","title":"Lifecycle Dependencies","text":"<p>Create dependencies that persist across requests:</p> <pre><code>@app.on_startup\ndef database():\n    \"\"\"Created once at startup.\"\"\"\n    print(\"Opening database connection...\")\n    return create_connection_pool()\n\n@app.on_shutdown\ndef close_database(database):\n    \"\"\"Called when application shuts down.\"\"\"\n    print(\"Closing database connection...\")\n    database.close()\n\n@app.get('/users')\ndef list_users(database):\n    # Same database instance across all requests\n    return {\"users\": database.query_all()}\n</code></pre>"},{"location":"guide/usage/#nested-dependencies","title":"Nested Dependencies","text":"<p>Dependencies can depend on other dependencies:</p> <pre><code>@app.dependency()\ndef config():\n    return {\"db_host\": \"localhost\", \"db_port\": 5432}\n\n@app.dependency()\ndef database_url(config):\n    return f\"postgresql://{config['db_host']}:{config['db_port']}/mydb\"\n\n@app.dependency()\ndef database(database_url):\n    return create_connection(database_url)\n</code></pre>"},{"location":"guide/usage/#error-handling","title":"Error Handling","text":"<p>Handle errors gracefully with custom error handlers.</p>"},{"location":"guide/usage/#custom-error-handlers","title":"Custom Error Handlers","text":"<p>Define handlers for specific status codes:</p> <pre><code>@app.error_handler(404)\ndef not_found_handler(request, message, **kwargs):\n    return {\n        \"error\": \"Not Found\",\n        \"message\": message,\n        \"path\": request.path\n    }\n\n@app.error_handler(500)\ndef server_error_handler(request, message, **kwargs):\n    # Log the error\n    import logging\n    logging.error(f\"Server error: {message}\")\n\n    return {\n        \"error\": \"Internal Server Error\",\n        \"message\": \"Something went wrong\"\n    }\n</code></pre>"},{"location":"guide/usage/#validation-error-handling","title":"Validation Error Handling","text":"<p>Handle Pydantic validation errors:</p> <pre><code>from pydantic import ValidationError as PydanticValidationError\n\n@app.error_handler(400)\ndef validation_error_handler(request, message, **kwargs):\n    \"\"\"Handle Pydantic validation errors.\"\"\"\n    validation_error = kwargs.get('validation_error')\n\n    if validation_error and isinstance(validation_error, PydanticValidationError):\n        errors = []\n        for error in validation_error.errors():\n            errors.append({\n                \"field\": '.'.join(str(loc) for loc in error['loc']),\n                \"message\": error['msg'],\n                \"type\": error['type']\n            })\n\n        return {\n            \"error\": \"Validation Error\",\n            \"message\": \"Request validation failed\",\n            \"details\": errors\n        }\n\n    return {\"error\": \"Bad Request\", \"message\": message}\n</code></pre>"},{"location":"guide/usage/#exception-based-error-handling","title":"Exception-Based Error Handling","text":"<p>Use custom exceptions:</p> <pre><code>class AuthenticationError(Exception):\n    pass\n\n@app.dependency()\ndef current_user(request_headers):\n    auth_header = request_headers.get('authorization')\n    if not auth_header:\n        raise AuthenticationError(\"Missing authentication header\")\n    return validate_token(auth_header)\n\n@app.error_handler(401)\ndef auth_error_handler(request, message, **kwargs):\n    exc_info = kwargs.get('exc_info')\n    if exc_info and isinstance(exc_info[1], AuthenticationError):\n        return {\n            \"error\": \"Authentication Failed\",\n            \"message\": str(exc_info[1]),\n            \"hint\": \"Include 'Authorization: Bearer &lt;token&gt;' header\"\n        }\n    return {\"error\": \"Unauthorized\", \"message\": message}\n</code></pre>"},{"location":"guide/usage/#error-context","title":"Error Context","text":"<p>Add context to error responses:</p> <pre><code>import uuid\nfrom datetime import datetime\n\n@app.error_handler(500)\ndef server_error_with_context(request, message, **kwargs):\n    \"\"\"Server error with tracking information.\"\"\"\n    import logging\n\n    request_id = request.headers.get('x-request-id', str(uuid.uuid4()))\n    timestamp = datetime.now().isoformat()\n\n    # Log detailed error\n    exc_info = kwargs.get('exc_info')\n    if exc_info:\n        logging.error(\n            f\"Server error [{request_id}]: {message}\",\n            exc_info=exc_info,\n            extra={\n                'request_id': request_id,\n                'path': request.path,\n                'method': request.method\n            }\n        )\n\n    # Return safe error response\n    return {\n        \"error\": \"Internal Server Error\",\n        \"message\": \"An unexpected error occurred\",\n        \"request_id\": request_id,\n        \"timestamp\": timestamp\n    }\n</code></pre>"},{"location":"guide/usage/#consistent-error-format","title":"Consistent Error Format","text":"<p>Use a consistent format across all errors:</p> <pre><code>def error_response(error_type: str, message: str, **extras):\n    \"\"\"Create consistent error response.\"\"\"\n    from datetime import datetime\n    response = {\n        \"error\": error_type,\n        \"message\": message,\n        \"timestamp\": datetime.now().isoformat()\n    }\n    response.update(extras)\n    return response\n\n@app.error_handler(400)\ndef bad_request(request, message, **kwargs):\n    return error_response(\"Bad Request\", message, path=request.path)\n\n@app.error_handler(401)\ndef unauthorized(request, message, **kwargs):\n    return error_response(\"Unauthorized\", message)\n\n@app.error_handler(404)\ndef not_found(request, message, **kwargs):\n    return error_response(\"Not Found\", message, path=request.path)\n</code></pre>"},{"location":"guide/usage/#complete-example","title":"Complete Example","text":"<p>Here's a complete example using multiple decorators:</p> <pre><code>from restmachine import RestApplication\nfrom pydantic import BaseModel, EmailStr\nfrom datetime import datetime\nimport hashlib\n\napp = RestApplication()\n\n# Models\nclass UserCreate(BaseModel):\n    name: str\n    email: EmailStr\n\n# Session dependencies\n@app.on_startup\ndef database():\n    return {\"users\": {}}\n\n# Request dependencies\n@app.dependency()\ndef current_user(request_headers, database):\n    token = request_headers.get('authorization', '').replace('Bearer ', '')\n    return database.get('users', {}).get(token)\n\n# Resource decorators\n@app.resource_exists\ndef user(path_params, database):\n    return database[\"users\"].get(path_params['user_id'])\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n# State machine decorators\n@app.authorized\ndef is_authenticated(current_user):\n    return current_user is not None\n\n@app.forbidden\ndef can_modify(current_user, user):\n    return current_user['id'] != user['id'] and not current_user.get('is_admin')\n\n@app.etag\ndef user_etag(user):\n    if not user:\n        return None\n    content = f\"{user['id']}{user.get('updated_at', '')}\"\n    return f'\"{hashlib.md5(content.encode()).hexdigest()}\"'\n\n# Routes\n@app.get('/users')\ndef list_users(database):\n    return {\"users\": list(database[\"users\"].values())}\n\n@app.post('/users')\ndef create_user(user_create: UserCreate, database):\n    user = user_create.model_dump()\n    user['id'] = str(len(database[\"users\"]) + 1)\n    user['updated_at'] = datetime.now().isoformat()\n    database[\"users\"][user['id']] = user\n    return user, 201\n\n@app.get('/users/{user_id}')\ndef get_user(user):\n    return user\n\n@app.put('/users/{user_id}')\ndef update_user(user, user_create: UserCreate):\n    user['name'] = user_create.name\n    user['email'] = user_create.email\n    user['updated_at'] = datetime.now().isoformat()\n    return user\n\n@app.delete('/users/{user_id}')\ndef delete_user(user, database):\n    database[\"users\"].pop(user['id'])\n    return None\n\n# Error handlers\n@app.error_handler(404)\ndef not_found(request, message, **kwargs):\n    return {\"error\": \"Not Found\", \"message\": message, \"path\": request.path}\n\n@app.error_handler(401)\ndef unauthorized(request, message, **kwargs):\n    return {\"error\": \"Unauthorized\", \"message\": \"Authentication required\"}\n</code></pre>"},{"location":"guide/usage/#best-practices","title":"Best Practices","text":""},{"location":"guide/usage/#1-order-decorators-correctly","title":"1. Order Decorators Correctly","text":"<p>When stacking decorators, order matters:</p> <pre><code>@app.get('/admin/users')\n@app.authorized\ndef check_admin_auth(current_user):\n    return current_user and current_user.get('is_admin')\n\ndef admin_users(database):\n    return {\"users\": database.get_all_users()}\n</code></pre>"},{"location":"guide/usage/#2-use-specific-dependencies","title":"2. Use Specific Dependencies","text":"<p>Use specific dependencies instead of generic <code>request</code>:</p> <pre><code># Good\n@app.get('/search')\ndef search(query_params):\n    query = query_params.get('q')\n    return {\"results\": search_db(query)}\n\n# Less ideal\n@app.get('/search')\ndef search(request):\n    query = request.query_params.get('q')\n    return {\"results\": search_db(query)}\n</code></pre>"},{"location":"guide/usage/#3-keep-dependencies-focused","title":"3. Keep Dependencies Focused","text":"<p>Each dependency should have a single responsibility:</p> <pre><code># Good - focused dependencies\n@app.dependency()\ndef current_user(request_headers):\n    return extract_user_from_token(request_headers)\n\n@app.dependency()\ndef is_admin(current_user):\n    return current_user and current_user.get('is_admin')\n\n# Less ideal - doing too much\n@app.dependency()\ndef auth_and_check_admin(request_headers):\n    user = extract_user_from_token(request_headers)\n    return user and user.get('is_admin')\n</code></pre>"},{"location":"guide/usage/#4-return-correct-status-codes","title":"4. Return Correct Status Codes","text":"<p>Use appropriate status codes in responses:</p> <pre><code>@app.post('/users')\ndef create_user(user_create: UserCreate):\n    user = create_user_in_db(user_create)\n    return user, 201  # Created\n\n@app.delete('/users/{user_id}')\ndef delete_user(user):\n    delete_from_db(user)\n    return None  # 204 No Content\n\n@app.put('/users/{user_id}')\ndef update_user(user, user_update):\n    updated = update_in_db(user, user_update)\n    return updated  # 200 OK\n</code></pre>"},{"location":"guide/usage/#next-steps","title":"Next Steps","text":"<ul> <li>Concepts \u2192 - Understand the core concepts</li> <li>Authentication \u2192 - Implement authentication</li> <li>Content Negotiation \u2192 - Multiple response formats</li> <li>ETags \u2192 - Efficient caching</li> <li>OpenAPI \u2192 - API documentation</li> </ul>"},{"location":"guide/validation/","title":"Validation","text":"<p>RestMachine provides flexible request validation through Pydantic integration. Use validation to ensure type safety, enforce business rules, and provide clear error messages.</p>"},{"location":"guide/validation/#basic-validation","title":"Basic Validation","text":""},{"location":"guide/validation/#installing-validation-support","title":"Installing Validation Support","text":"<p>Install RestMachine with Pydantic validation:</p> <pre><code>pip install restmachine[validation]\n</code></pre> <p>Or install Pydantic separately:</p> <pre><code>pip install pydantic\n</code></pre>"},{"location":"guide/validation/#simple-model-validation","title":"Simple Model Validation","text":"<p>Use <code>@app.validates</code> to create a validation dependency:</p> <pre><code>from restmachine import RestApplication, Request\nfrom pydantic import BaseModel\nimport json\n\napp = RestApplication()\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n    age: int\n\n@app.validates\ndef validate_user(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n@app.post('/users')\ndef create_user(validate_user: UserCreate):\n    return {\n        \"created\": validate_user.model_dump()\n    }, 201\n</code></pre>"},{"location":"guide/validation/#pydantic-models","title":"Pydantic Models","text":""},{"location":"guide/validation/#field-validation","title":"Field Validation","text":"<p>Use Pydantic's field validators for rich validation:</p> <pre><code>from pydantic import BaseModel, EmailStr, Field, field_validator\nfrom typing import Optional\n\nclass UserCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    email: EmailStr\n    age: int = Field(..., ge=0, le=150)\n    password: str = Field(..., min_length=8)\n    bio: Optional[str] = Field(None, max_length=500)\n\n    @field_validator('name')\n    @classmethod\n    def name_must_not_contain_numbers(cls, v: str) -&gt; str:\n        if any(char.isdigit() for char in v):\n            raise ValueError('name must not contain numbers')\n        return v.strip()\n\n    @field_validator('password')\n    @classmethod\n    def password_strength(cls, v: str) -&gt; str:\n        if not any(char.isupper() for char in v):\n            raise ValueError('password must contain uppercase letter')\n        if not any(char.isdigit() for char in v):\n            raise ValueError('password must contain digit')\n        return v\n\n@app.validates\ndef user_create(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n@app.post('/users')\ndef create_user(user_create: UserCreate):\n    user_data = user_create.model_dump()\n    # Hash password before storing\n    user_data['password'] = hash_password(user_data['password'])\n    return {\"created\": user_data}, 201\n</code></pre>"},{"location":"guide/validation/#model-validation","title":"Model Validation","text":"<p>Use <code>model_validator</code> for validations that span multiple fields:</p> <pre><code>from pydantic import model_validator\nfrom datetime import date\n\nclass EventCreate(BaseModel):\n    title: str\n    start_date: date\n    end_date: date\n    max_attendees: int = Field(..., gt=0)\n\n    @model_validator(mode='after')\n    def check_dates(self):\n        if self.end_date &lt; self.start_date:\n            raise ValueError('end_date must be after start_date')\n        return self\n\n    @model_validator(mode='after')\n    def check_duration(self):\n        duration = (self.end_date - self.start_date).days\n        if duration &gt; 365:\n            raise ValueError('event duration cannot exceed 1 year')\n        return self\n\n@app.validates\ndef event_create(json_body) -&gt; EventCreate:\n    return EventCreate.model_validate(json_body)\n\n@app.post('/events')\ndef create_event(event_create: EventCreate):\n    return {\"created\": event_create.model_dump()}, 201\n</code></pre>"},{"location":"guide/validation/#query-parameter-validation","title":"Query Parameter Validation","text":"<p>Validate query parameters using Pydantic:</p> <pre><code>from typing import Optional\nfrom enum import Enum\n\nclass SortOrder(str, Enum):\n    asc = \"asc\"\n    desc = \"desc\"\n\nclass ListParams(BaseModel):\n    page: int = Field(default=1, ge=1)\n    limit: int = Field(default=20, ge=1, le=100)\n    sort_by: Optional[str] = None\n    order: SortOrder = SortOrder.asc\n\n@app.validates\ndef list_params(query_params) -&gt; ListParams:\n    return ListParams.model_validate(query_params)\n\n@app.get('/users')\ndef list_users(list_params: ListParams, database):\n    users = database[\"users\"]\n\n    # Apply sorting if specified\n    if list_params.sort_by:\n        users = sorted(\n            users,\n            key=lambda u: u.get(list_params.sort_by, ''),\n            reverse=(list_params.order == SortOrder.desc)\n        )\n\n    # Apply pagination\n    offset = (list_params.page - 1) * list_params.limit\n    return {\n        \"users\": users[offset:offset+list_params.limit],\n        \"page\": list_params.page,\n        \"limit\": list_params.limit,\n        \"total\": len(users)\n    }\n</code></pre>"},{"location":"guide/validation/#path-parameter-validation","title":"Path Parameter Validation","text":"<p>Validate path parameters using dependencies and Pydantic:</p> <pre><code>from uuid import UUID\nfrom pydantic import field_validator\n\nclass UserId(BaseModel):\n    value: UUID\n\n    @field_validator('value')\n    @classmethod\n    def validate_uuid(cls, v):\n        # Additional validation if needed\n        return v\n\n@app.dependency()\ndef user_id(path_params) -&gt; UUID:\n    raw_id = path_params.get('user_id')\n    try:\n        return UUID(raw_id)\n    except ValueError:\n        raise ValueError(f\"Invalid user ID format: {raw_id}\")\n\n@app.get('/users/{user_id}')\ndef get_user(user_id: UUID, database):\n    user = next(\n        (u for u in database[\"users\"] if u[\"id\"] == str(user_id)),\n        None\n    )\n    if not user:\n        from restmachine import Response\n        return Response(404, '{\"error\": \"User not found\"}')\n    return user\n</code></pre>"},{"location":"guide/validation/#custom-validators","title":"Custom Validators","text":""},{"location":"guide/validation/#reusable-validators","title":"Reusable Validators","text":"<p>Create reusable validation functions:</p> <pre><code>from typing import Annotated\n\ndef validate_phone_number(v: str) -&gt; str:\n    \"\"\"Validate and normalize phone number.\"\"\"\n    # Remove all non-digit characters\n    digits = ''.join(filter(str.isdigit, v))\n\n    if len(digits) &lt; 10:\n        raise ValueError('phone number must have at least 10 digits')\n\n    # Format as (XXX) XXX-XXXX\n    if len(digits) == 10:\n        return f\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\"\n\n    return digits\n\nPhoneNumber = Annotated[str, field_validator('phone')(validate_phone_number)]\n\nclass ContactInfo(BaseModel):\n    phone: str\n\n    @field_validator('phone')\n    @classmethod\n    def validate_phone(cls, v: str) -&gt; str:\n        return validate_phone_number(v)\n\n@app.validates\ndef contact_info(json_body) -&gt; ContactInfo:\n    return ContactInfo.model_validate(json_body)\n\n@app.post('/contacts')\ndef create_contact(contact_info: ContactInfo):\n    return {\"contact\": contact_info.model_dump()}, 201\n</code></pre>"},{"location":"guide/validation/#business-rule-validators","title":"Business Rule Validators","text":"<p>Implement complex business rules in validators:</p> <pre><code>@app.on_startup\ndef database():\n    return {\n        \"users\": [\n            {\"id\": \"1\", \"email\": \"alice@example.com\", \"credits\": 100},\n            {\"id\": \"2\", \"email\": \"bob@example.com\", \"credits\": 50}\n        ]\n    }\n\nclass PurchaseRequest(BaseModel):\n    user_id: str\n    item_id: str\n    quantity: int = Field(..., ge=1)\n    price_per_item: float = Field(..., gt=0)\n\n    @field_validator('quantity')\n    @classmethod\n    def quantity_limit(cls, v):\n        if v &gt; 100:\n            raise ValueError('cannot purchase more than 100 items at once')\n        return v\n\n@app.dependency()\ndef purchase_request(json_body, database) -&gt; PurchaseRequest:\n    purchase = PurchaseRequest.model_validate(json_body)\n\n    # Check user exists and has sufficient credits\n    user = next((u for u in database[\"users\"] if u[\"id\"] == purchase.user_id), None)\n    if not user:\n        raise ValueError(f\"User {purchase.user_id} not found\")\n\n    total_cost = purchase.quantity * purchase.price_per_item\n    if user[\"credits\"] &lt; total_cost:\n        raise ValueError(\n            f\"Insufficient credits. Required: {total_cost}, Available: {user['credits']}\"\n        )\n\n    return purchase\n\n@app.post('/purchases')\ndef create_purchase(purchase_request: PurchaseRequest):\n    return {\"purchase\": purchase_request.model_dump()}, 201\n</code></pre>"},{"location":"guide/validation/#error-handling","title":"Error Handling","text":""},{"location":"guide/validation/#default-error-responses","title":"Default Error Responses","text":"<p>RestMachine automatically returns 400 Bad Request for validation errors:</p> <pre><code># Request: POST /users\n# Body: {\"name\": \"\", \"email\": \"invalid\", \"age\": -5}\n\n# Response: 400 Bad Request\n# {\n#   \"error\": \"Validation Error\",\n#   \"details\": [\n#     {\"field\": \"name\", \"message\": \"String should have at least 1 character\"},\n#     {\"field\": \"email\", \"message\": \"value is not a valid email address\"},\n#     {\"field\": \"age\", \"message\": \"Input should be greater than or equal to 0\"}\n#   ]\n# }\n</code></pre>"},{"location":"guide/validation/#custom-error-handlers","title":"Custom Error Handlers","text":"<p>Customize validation error responses:</p> <pre><code>@app.error_handler(400)\ndef validation_error_handler(request, message, **kwargs):\n    \"\"\"Custom validation error response.\"\"\"\n    from pydantic import ValidationError\n\n    # Check if this is a Pydantic validation error\n    if 'validation_error' in kwargs:\n        validation_error = kwargs['validation_error']\n        if isinstance(validation_error, ValidationError):\n            errors = []\n            for error in validation_error.errors():\n                errors.append({\n                    \"field\": \".\".join(str(loc) for loc in error['loc']),\n                    \"message\": error['msg'],\n                    \"type\": error['type']\n                })\n\n            return {\n                \"status\": \"error\",\n                \"message\": \"Validation failed\",\n                \"errors\": errors,\n                \"path\": request.path\n            }\n\n    # Generic 400 error\n    return {\n        \"status\": \"error\",\n        \"message\": message,\n        \"path\": request.path\n    }\n</code></pre>"},{"location":"guide/validation/#field-level-error-messages","title":"Field-Level Error Messages","text":"<p>Provide user-friendly error messages:</p> <pre><code>from pydantic import Field\n\nclass UserRegistration(BaseModel):\n    username: str = Field(\n        ...,\n        min_length=3,\n        max_length=20,\n        description=\"Username must be 3-20 characters\"\n    )\n    email: EmailStr = Field(\n        ...,\n        description=\"Must be a valid email address\"\n    )\n    password: str = Field(\n        ...,\n        min_length=8,\n        description=\"Password must be at least 8 characters\"\n    )\n    age: int = Field(\n        ...,\n        ge=18,\n        le=120,\n        description=\"Must be 18 or older\"\n    )\n\n    @field_validator('username')\n    @classmethod\n    def username_alphanumeric(cls, v):\n        if not v.isalnum():\n            raise ValueError('username must be alphanumeric')\n        return v\n\n    @field_validator('password')\n    @classmethod\n    def password_requirements(cls, v):\n        if not any(c.isupper() for c in v):\n            raise ValueError('password must contain at least one uppercase letter')\n        if not any(c.isdigit() for c in v):\n            raise ValueError('password must contain at least one number')\n        if not any(c in '!@#$%^&amp;*' for c in v):\n            raise ValueError('password must contain at least one special character (!@#$%^&amp;*)')\n        return v\n</code></pre>"},{"location":"guide/validation/#nested-models","title":"Nested Models","text":""},{"location":"guide/validation/#validating-nested-data","title":"Validating Nested Data","text":"<p>Handle complex nested structures:</p> <pre><code>from typing import List\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    state: str = Field(..., min_length=2, max_length=2)\n    zip_code: str = Field(..., pattern=r'^\\d{5}(-\\d{4})?$')\n\nclass PhoneNumber(BaseModel):\n    type: str  # \"mobile\", \"home\", \"work\"\n    number: str\n\n    @field_validator('type')\n    @classmethod\n    def validate_type(cls, v):\n        if v not in ['mobile', 'home', 'work']:\n            raise ValueError('type must be mobile, home, or work')\n        return v\n\nclass UserProfile(BaseModel):\n    name: str\n    email: EmailStr\n    address: Address\n    phone_numbers: List[PhoneNumber] = Field(default_factory=list)\n\n    @field_validator('phone_numbers')\n    @classmethod\n    def at_least_one_phone(cls, v):\n        if not v:\n            raise ValueError('at least one phone number is required')\n        return v\n\n@app.validates\ndef user_profile(json_body) -&gt; UserProfile:\n    return UserProfile.model_validate(json_body)\n\n@app.post('/profiles')\ndef create_profile(user_profile: UserProfile):\n    return {\"profile\": user_profile.model_dump()}, 201\n\n# Example request:\n# {\n#   \"name\": \"Alice\",\n#   \"email\": \"alice@example.com\",\n#   \"address\": {\n#     \"street\": \"123 Main St\",\n#     \"city\": \"Springfield\",\n#     \"state\": \"IL\",\n#     \"zip_code\": \"62701\"\n#   },\n#   \"phone_numbers\": [\n#     {\"type\": \"mobile\", \"number\": \"(555) 123-4567\"}\n#   ]\n# }\n</code></pre>"},{"location":"guide/validation/#partial-updates","title":"Partial Updates","text":""},{"location":"guide/validation/#validating-patch-requests","title":"Validating PATCH Requests","text":"<p>Handle partial updates with optional fields:</p> <pre><code>from typing import Optional\n\nclass UserUpdate(BaseModel):\n    name: Optional[str] = Field(None, min_length=1, max_length=100)\n    email: Optional[EmailStr] = None\n    age: Optional[int] = Field(None, ge=0, le=150)\n    bio: Optional[str] = Field(None, max_length=500)\n\n    @model_validator(mode='after')\n    def at_least_one_field(self):\n        if not any([self.name, self.email, self.age, self.bio]):\n            raise ValueError('at least one field must be provided')\n        return self\n\n@app.validates\ndef user_update(json_body) -&gt; UserUpdate:\n    return UserUpdate.model_validate(json_body)\n\n@app.resource_exists\ndef user(path_params, database):\n    user_id = path_params.get('user_id')\n    return next((u for u in database[\"users\"] if u[\"id\"] == user_id), None)\n\n@app.patch('/users/{user_id}')\ndef update_user(user, user_update: UserUpdate):\n    # resource_exists decorator handles 404 automatically\n    # Update only provided fields\n    update_data = user_update.model_dump(exclude_unset=True)\n    user.update(update_data)\n\n    return user\n</code></pre>"},{"location":"guide/validation/#content-type-validation","title":"Content Type Validation","text":""},{"location":"guide/validation/#multiple-content-types","title":"Multiple Content Types","text":"<p>Validate different content types:</p> <pre><code>@app.validates\ndef validate_user(request: Request) -&gt; UserCreate:\n    content_type = request.headers.get('content-type', '')\n\n    if 'application/json' in content_type:\n        import json\n        data = json.loads(request.body)\n        return UserCreate.model_validate(data)\n\n    elif 'application/x-www-form-urlencoded' in content_type:\n        from urllib.parse import parse_qs\n        data = parse_qs(request.body.decode())\n        # Convert query string format to dict\n        cleaned_data = {k: v[0] if len(v) == 1 else v for k, v in data.items()}\n        return UserCreate.model_validate(cleaned_data)\n\n    else:\n        from restmachine import Response\n        raise ValueError('Unsupported content type')\n\n@app.post('/users')\ndef create_user(validate_user: UserCreate):\n    return {\"created\": validate_user.model_dump()}, 201\n</code></pre>"},{"location":"guide/validation/#complete-example","title":"Complete Example","text":"<p>Here's a complete example with validation:</p> <pre><code>from restmachine import RestApplication, Request, Response\nfrom pydantic import BaseModel, EmailStr, Field, field_validator\nfrom typing import Optional, List\nfrom datetime import datetime\nimport json\n\napp = RestApplication()\n\n# Models\nclass TagCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=20)\n\n    @field_validator('name')\n    @classmethod\n    def lowercase_tag(cls, v):\n        return v.lower().strip()\n\nclass PostCreate(BaseModel):\n    title: str = Field(..., min_length=1, max_length=200)\n    content: str = Field(..., min_length=1)\n    author_id: str\n    tags: List[TagCreate] = Field(default_factory=list)\n    published: bool = False\n\n    @field_validator('tags')\n    @classmethod\n    def unique_tags(cls, v):\n        tag_names = [tag.name for tag in v]\n        if len(tag_names) != len(set(tag_names)):\n            raise ValueError('tags must be unique')\n        return v\n\nclass PostUpdate(BaseModel):\n    title: Optional[str] = Field(None, min_length=1, max_length=200)\n    content: Optional[str] = Field(None, min_length=1)\n    tags: Optional[List[TagCreate]] = None\n    published: Optional[bool] = None\n\n    @model_validator(mode='after')\n    def at_least_one_field(self):\n        if not any([self.title, self.content, self.tags, self.published]):\n            raise ValueError('at least one field must be provided')\n        return self\n\n# Database\n@app.on_startup\ndef database():\n    return {\n        \"posts\": [\n            {\n                \"id\": \"1\",\n                \"title\": \"First Post\",\n                \"content\": \"Hello World\",\n                \"author_id\": \"user1\",\n                \"tags\": [\"python\", \"rest\"],\n                \"published\": True,\n                \"created_at\": \"2024-01-01T00:00:00\"\n            }\n        ]\n    }\n\n# Validators\n@app.validates\ndef post_create(json_body) -&gt; PostCreate:\n    return PostCreate.model_validate(json_body)\n\n@app.validates\ndef post_update(json_body) -&gt; PostUpdate:\n    return PostUpdate.model_validate(json_body)\n\n# Dependencies\n@app.dependency()\ndef verified_post(post_create: PostCreate, database):\n    \"\"\"Verify author exists.\"\"\"\n    # In real app, check user database\n    if not post_create.author_id:\n        raise ValueError(\"author_id is required\")\n    return post_create\n\n# Routes\n@app.post('/posts')\ndef create_post(verified_post: PostCreate, database):\n    post = verified_post.model_dump()\n    post[\"id\"] = str(len(database[\"posts\"]) + 1)\n    post[\"created_at\"] = datetime.now().isoformat()\n\n    database[\"posts\"].append(post)\n    return post, 201\n\n@app.resource_exists\ndef post(path_params, database):\n    post_id = path_params.get('post_id')\n    return next((p for p in database[\"posts\"] if p[\"id\"] == post_id), None)\n\n@app.get('/posts/{post_id}')\ndef get_post(post):\n    # resource_exists decorator handles 404 automatically\n    return post\n\n@app.patch('/posts/{post_id}')\ndef update_post(post, post_update: PostUpdate):\n    # resource_exists decorator handles 404 automatically\n    # Update only provided fields\n    update_data = post_update.model_dump(exclude_unset=True)\n    post.update(update_data)\n\n    return post\n\n# Error handler\n@app.error_handler(400)\ndef validation_error(request, message, **kwargs):\n    return {\n        \"error\": \"Validation failed\",\n        \"message\": message,\n        \"path\": request.path\n    }\n\n# ASGI\nfrom restmachine import ASGIAdapter\nasgi_app = ASGIAdapter(app)\n</code></pre>"},{"location":"guide/validation/#best-practices","title":"Best Practices","text":""},{"location":"guide/validation/#1-fail-fast","title":"1. Fail Fast","text":"<p>Validate as early as possible in the request lifecycle:</p> <pre><code># Good: Validate in dependency\n@app.validates\ndef validate_user(json_body) -&gt; UserCreate:\n    return UserCreate.model_validate(json_body)\n\n# Avoid: Validate in handler\n@app.post('/users')\ndef create_user(json_body):\n    # Don't manually validate - use @app.validates instead\n    user = UserCreate.model_validate(json_body)  # Validation should be in decorator\n    ...\n</code></pre>"},{"location":"guide/validation/#2-provide-clear-error-messages","title":"2. Provide Clear Error Messages","text":"<p>Use descriptive error messages:</p> <pre><code>class UserCreate(BaseModel):\n    age: int = Field(..., ge=18, description=\"Must be 18 or older\")\n\n    @field_validator('age')\n    @classmethod\n    def validate_age(cls, v):\n        if v &lt; 18:\n            raise ValueError('You must be 18 or older to register')\n        if v &gt; 120:\n            raise ValueError('Please enter a valid age')\n        return v\n</code></pre>"},{"location":"guide/validation/#3-validate-business-rules","title":"3. Validate Business Rules","text":"<p>Combine Pydantic validation with business logic:</p> <pre><code>@app.dependency()\ndef unique_user(user_create: UserCreate, database):\n    existing = next(\n        (u for u in database[\"users\"] if u[\"email\"] == user_create.email),\n        None\n    )\n    if existing:\n        raise ValueError(f\"Email {user_create.email} is already registered\")\n    return user_create\n</code></pre>"},{"location":"guide/validation/#4-use-type-hints","title":"4. Use Type Hints","text":"<p>Leverage type hints for better IDE support:</p> <pre><code>from typing import Annotated\n\nUserId = Annotated[str, Field(pattern=r'^user_[a-z0-9]+$')]\nEmail = Annotated[str, EmailStr]\n\nclass User(BaseModel):\n    id: UserId\n    email: Email\n    age: Annotated[int, Field(ge=18, le=120)]\n</code></pre>"},{"location":"guide/validation/#5-document-your-models","title":"5. Document Your Models","text":"<p>Add descriptions to help API consumers:</p> <pre><code>class UserCreate(BaseModel):\n    \"\"\"User registration model.\"\"\"\n\n    name: str = Field(\n        ...,\n        min_length=1,\n        max_length=100,\n        description=\"Full name of the user\"\n    )\n    email: EmailStr = Field(\n        ...,\n        description=\"Valid email address for account verification\"\n    )\n    age: int = Field(\n        ...,\n        ge=18,\n        le=120,\n        description=\"Age in years (must be 18 or older)\"\n    )\n</code></pre>"},{"location":"guide/validation/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication \u2192 - Secure your API with authentication</li> <li>Error Handling \u2192 - Advanced error handling patterns</li> <li>Testing \u2192 - Test validation logic</li> <li>API Reference \u2192 - Complete API documentation</li> </ul>"},{"location":"guide/deployment/hypercorn/","title":"Deploying with Hypercorn","text":"<p>Hypercorn is a modern ASGI server with full support for HTTP/1.1, HTTP/2, and HTTP/3. It's ideal for applications that need the latest HTTP protocol features and excellent WebSocket support.</p>"},{"location":"guide/deployment/hypercorn/#installation","title":"Installation","text":"<p>Install RestMachine with Hypercorn support:</p> <pre><code>pip install 'restmachine[hypercorn]'\n</code></pre> <p>Or install Hypercorn separately:</p> <pre><code>pip install restmachine hypercorn\n</code></pre> <p>For HTTP/3 support, install additional dependencies:</p> <pre><code>pip install 'hypercorn[h3]'\n</code></pre>"},{"location":"guide/deployment/hypercorn/#quick-start","title":"Quick Start","text":""},{"location":"guide/deployment/hypercorn/#using-the-serve-function","title":"Using the serve() Function","text":"<p>The simplest way to run your application with Hypercorn:</p> <pre><code># app.py\nfrom restmachine import RestApplication, serve\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello World\"}\n\nif __name__ == \"__main__\":\n    serve(app, server=\"hypercorn\", host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Run the application:</p> <pre><code>python app.py\n</code></pre>"},{"location":"guide/deployment/hypercorn/#using-the-hypercorndriver","title":"Using the HypercornDriver","text":"<p>For more control, use the <code>HypercornDriver</code> class directly:</p> <pre><code># app.py\nfrom restmachine import RestApplication\nfrom restmachine.servers import HypercornDriver\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello World\"}\n\nif __name__ == \"__main__\":\n    driver = HypercornDriver(app, host=\"0.0.0.0\", port=8000)\n    driver.run()\n</code></pre>"},{"location":"guide/deployment/hypercorn/#using-asgi-adapter","title":"Using ASGI Adapter","text":"<p>Create an ASGI app and run with Hypercorn from the command line:</p> <pre><code># app.py\nfrom restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello World\"}\n\n# Create ASGI application\nasgi_app = ASGIAdapter(app)\n</code></pre> <p>Run with Hypercorn:</p> <pre><code>hypercorn app:asgi_app --bind 0.0.0.0:8000\n</code></pre>"},{"location":"guide/deployment/hypercorn/#http-protocol-support","title":"HTTP Protocol Support","text":""},{"location":"guide/deployment/hypercorn/#http11-default","title":"HTTP/1.1 (Default)","text":"<p>Standard HTTP/1.1 support:</p> <pre><code>serve(\n    app,\n    server=\"hypercorn\",\n    host=\"0.0.0.0\",\n    port=8000,\n    http_version=\"http1\"  # Default\n)\n</code></pre> <p>Command line:</p> <pre><code>hypercorn app:asgi_app --bind 0.0.0.0:8000\n</code></pre>"},{"location":"guide/deployment/hypercorn/#http2","title":"HTTP/2","text":"<p>Enable HTTP/2 for better performance (requires SSL in browsers):</p> <pre><code>from restmachine.servers import HypercornDriver\n\ndriver = HypercornDriver(\n    app,\n    host=\"0.0.0.0\",\n    port=8443,\n    http_version=\"http2\"\n)\n\ndriver.run(\n    ssl_keyfile=\"./certs/key.pem\",\n    ssl_certfile=\"./certs/cert.pem\",\n)\n</code></pre> <p>Command line:</p> <pre><code>hypercorn app:asgi_app \\\n  --bind 0.0.0.0:8443 \\\n  --keyfile ./certs/key.pem \\\n  --certfile ./certs/cert.pem\n</code></pre>"},{"location":"guide/deployment/hypercorn/#http3-quic","title":"HTTP/3 (QUIC)","text":"<p>Enable HTTP/3 for the latest protocol (requires SSL):</p> <pre><code>from restmachine.servers import HypercornDriver\n\ndriver = HypercornDriver(\n    app,\n    host=\"0.0.0.0\",\n    port=8443,\n    http_version=\"http3\"  # HTTP/3 requires SSL\n)\n\ndriver.run(\n    ssl_keyfile=\"./certs/key.pem\",\n    ssl_certfile=\"./certs/cert.pem\",\n)\n</code></pre> <p>Command line with HTTP/3:</p> <pre><code># Requires hypercorn[h3]\nhypercorn app:asgi_app \\\n  --bind 0.0.0.0:8443 \\\n  --quic-bind 0.0.0.0:8443 \\\n  --keyfile ./certs/key.pem \\\n  --certfile ./certs/cert.pem\n</code></pre>"},{"location":"guide/deployment/hypercorn/#configuration-options","title":"Configuration Options","text":""},{"location":"guide/deployment/hypercorn/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from restmachine import RestApplication, serve\n\napp = RestApplication()\n\nserve(\n    app,\n    server=\"hypercorn\",\n    host=\"0.0.0.0\",\n    port=8000,\n    log_level=\"info\",\n)\n</code></pre>"},{"location":"guide/deployment/hypercorn/#production-configuration","title":"Production Configuration","text":"<pre><code>serve(\n    app,\n    server=\"hypercorn\",\n    host=\"0.0.0.0\",\n    port=8000,\n    workers=4,              # Number of worker processes\n    log_level=\"warning\",    # Less verbose logging\n    access_log=True,        # Enable access logging\n)\n</code></pre> <p>Command line:</p> <pre><code>hypercorn app:asgi_app \\\n  --bind 0.0.0.0:8000 \\\n  --workers 4 \\\n  --log-level warning \\\n  --access-log -\n</code></pre>"},{"location":"guide/deployment/hypercorn/#worker-configuration","title":"Worker Configuration","text":"<p>Set workers based on CPU cores:</p> <pre><code>import multiprocessing\n\nworkers = multiprocessing.cpu_count() * 2 + 1\n\nserve(\n    app,\n    server=\"hypercorn\",\n    workers=workers\n)\n</code></pre>"},{"location":"guide/deployment/hypercorn/#sslhttps-configuration","title":"SSL/HTTPS Configuration","text":""},{"location":"guide/deployment/hypercorn/#development-ssl","title":"Development SSL","text":"<p>Self-signed certificates for development:</p> <pre><code>serve(\n    app,\n    server=\"hypercorn\",\n    host=\"0.0.0.0\",\n    port=8443,\n    http_version=\"http2\",\n    ssl_keyfile=\"./certs/key.pem\",\n    ssl_certfile=\"./certs/cert.pem\",\n)\n</code></pre> <p>Generate self-signed certificates:</p> <pre><code># Generate private key\nopenssl genrsa -out key.pem 2048\n\n# Generate self-signed certificate\nopenssl req -new -x509 -key key.pem -out cert.pem -days 365\n</code></pre>"},{"location":"guide/deployment/hypercorn/#production-ssl","title":"Production SSL","text":"<p>Use Let's Encrypt or other CA certificates:</p> <pre><code>serve(\n    app,\n    server=\"hypercorn\",\n    host=\"0.0.0.0\",\n    port=443,\n    http_version=\"http2\",\n    workers=4,\n    ssl_keyfile=\"/etc/letsencrypt/live/example.com/privkey.pem\",\n    ssl_certfile=\"/etc/letsencrypt/live/example.com/fullchain.pem\",\n)\n</code></pre> <p>Command line:</p> <pre><code>hypercorn app:asgi_app \\\n  --bind 0.0.0.0:443 \\\n  --workers 4 \\\n  --keyfile /etc/letsencrypt/live/example.com/privkey.pem \\\n  --certfile /etc/letsencrypt/live/example.com/fullchain.pem\n</code></pre>"},{"location":"guide/deployment/hypercorn/#advanced-features","title":"Advanced Features","text":""},{"location":"guide/deployment/hypercorn/#access-logging","title":"Access Logging","text":"<p>Configure access log format:</p> <pre><code>serve(\n    app,\n    server=\"hypercorn\",\n    access_log=True,  # Enable access logging\n)\n</code></pre> <p>Command line with custom access log:</p> <pre><code>hypercorn app:asgi_app --access-log access.log --access-logformat \"%(h)s %(r)s %(s)s %(b)s\"\n</code></pre>"},{"location":"guide/deployment/hypercorn/#keep-alive-settings","title":"Keep-Alive Settings","text":"<p>Configure keep-alive timeouts:</p> <pre><code>hypercorn app:asgi_app --keep-alive-timeout 5\n</code></pre>"},{"location":"guide/deployment/hypercorn/#graceful-shutdown","title":"Graceful Shutdown","text":"<p>Configure graceful shutdown timeout:</p> <pre><code>hypercorn app:asgi_app --graceful-timeout 30\n</code></pre>"},{"location":"guide/deployment/hypercorn/#production-deployment","title":"Production Deployment","text":""},{"location":"guide/deployment/hypercorn/#systemd-service","title":"Systemd Service","text":"<p>Create a systemd service for Hypercorn:</p> <p><code>/etc/systemd/system/myapp.service</code>:</p> <pre><code>[Unit]\nDescription=My RestMachine Application (Hypercorn)\nAfter=network.target\n\n[Service]\nType=notify\nUser=www-data\nGroup=www-data\nWorkingDirectory=/var/www/myapp\nEnvironment=\"PATH=/var/www/myapp/venv/bin\"\nExecStart=/var/www/myapp/venv/bin/hypercorn app:asgi_app --bind 0.0.0.0:8000 --workers 4\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>With HTTP/2:</p> <pre><code>ExecStart=/var/www/myapp/venv/bin/hypercorn app:asgi_app \\\n    --bind 0.0.0.0:8443 \\\n    --workers 4 \\\n    --keyfile /etc/ssl/private/key.pem \\\n    --certfile /etc/ssl/certs/cert.pem\n</code></pre> <p>Enable and start:</p> <pre><code>sudo systemctl enable myapp\nsudo systemctl start myapp\nsudo systemctl status myapp\n</code></pre>"},{"location":"guide/deployment/hypercorn/#behind-nginx","title":"Behind Nginx","text":"<p>Use Nginx as a reverse proxy with HTTP/2:</p> <p><code>/etc/nginx/sites-available/myapp</code>:</p> <pre><code>upstream hypercorn {\n    server 127.0.0.1:8000;\n}\n\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n    return 301 https://$host$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name example.com www.example.com;\n\n    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n\n    # Modern SSL configuration\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n\n    location / {\n        proxy_pass http://hypercorn;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # WebSocket support\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n    }\n}\n</code></pre>"},{"location":"guide/deployment/hypercorn/#docker-deployment","title":"Docker Deployment","text":"<p>Dockerfile:</p> <pre><code>FROM python:3.11-slim\n\nWORKDIR /app\n\n# Install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application\nCOPY . .\n\n# Expose ports (HTTP/2 and HTTP/3)\nEXPOSE 8443 8443/udp\n\n# Run with Hypercorn\nCMD [\"hypercorn\", \"app:asgi_app\", \"--bind\", \"0.0.0.0:8443\", \"--workers\", \"4\"]\n</code></pre> <p>requirements.txt:</p> <pre><code>restmachine[hypercorn]\n</code></pre> <p>For HTTP/3:</p> <pre><code>restmachine\nhypercorn[h3]\n</code></pre> <p>Build and run:</p> <pre><code>docker build -t myapp .\ndocker run -p 8443:8443 myapp\n</code></pre>"},{"location":"guide/deployment/hypercorn/#docker-compose-with-http2","title":"Docker Compose with HTTP/2","text":"<p><code>docker-compose.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"8443:8443\"\n    volumes:\n      - ./certs:/certs:ro\n    environment:\n      - HYPERCORN_KEYFILE=/certs/key.pem\n      - HYPERCORN_CERTFILE=/certs/cert.pem\n    command: &gt;\n      hypercorn app:asgi_app\n      --bind 0.0.0.0:8443\n      --workers 4\n      --keyfile /certs/key.pem\n      --certfile /certs/cert.pem\n    restart: unless-stopped\n</code></pre>"},{"location":"guide/deployment/hypercorn/#complete-example","title":"Complete Example","text":"<p>Production-ready application with HTTP/2:</p> <pre><code># app.py\nimport os\nimport logging\nfrom restmachine import RestApplication, ASGIAdapter\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\nlogger = logging.getLogger(__name__)\n\n# Create application\napp = RestApplication()\n\n@app.on_startup\nasync def database():\n    \"\"\"Initialize async database connection.\"\"\"\n    logger.info(\"Connecting to database...\")\n    import asyncpg\n    pool = await asyncpg.create_pool(\n        host=\"localhost\",\n        database=\"myapp\",\n        user=\"appuser\",\n        password=os.getenv(\"DB_PASSWORD\"),\n        min_size=10,\n        max_size=20\n    )\n    return pool\n\n@app.on_shutdown\nasync def close_database(database):\n    \"\"\"Close database connections.\"\"\"\n    logger.info(\"Closing database pool...\")\n    await database.close()\n\n@app.get(\"/\")\ndef home():\n    \"\"\"Health check.\"\"\"\n    return {\"status\": \"healthy\", \"protocol\": \"HTTP/2\"}\n\n@app.get(\"/api/users/{user_id}\")\nasync def get_user(path_params, database):\n    \"\"\"Get user with async database query.\"\"\"\n    user_id = int(path_params['user_id'])\n    async with database.acquire() as conn:\n        user = await conn.fetchrow(\n            \"SELECT * FROM users WHERE id = $1\",\n            user_id\n        )\n        if not user:\n            return {\"error\": \"User not found\"}, 404\n        return dict(user)\n\n# Create ASGI app\nasgi_app = ASGIAdapter(app)\n\n# For running directly\nif __name__ == \"__main__\":\n    import asyncio\n    from hypercorn.config import Config\n    from hypercorn.asyncio import serve\n\n    # Get configuration from environment\n    host = os.getenv(\"HOST\", \"0.0.0.0\")\n    port = int(os.getenv(\"PORT\", \"8443\"))\n    workers = int(os.getenv(\"WORKERS\", \"4\"))\n\n    config = Config()\n    config.bind = [f\"{host}:{port}\"]\n    config.workers = workers\n    if os.getenv(\"SSL_KEYFILE\"):\n        config.keyfile = os.getenv(\"SSL_KEYFILE\")\n        config.certfile = os.getenv(\"SSL_CERTFILE\")\n\n    asyncio.run(serve(asgi_app, config))\n</code></pre> <p>Run in production:</p> <pre><code>export WORKERS=8\nexport SSL_KEYFILE=/etc/ssl/private/key.pem\nexport SSL_CERTFILE=/etc/ssl/certs/cert.pem\nhypercorn app:asgi_app --bind 0.0.0.0:8443 --workers 8\n</code></pre>"},{"location":"guide/deployment/hypercorn/#performance-tuning","title":"Performance Tuning","text":""},{"location":"guide/deployment/hypercorn/#worker-configuration_1","title":"Worker Configuration","text":"<p>Optimize workers for your workload:</p> <pre><code>import os\nimport multiprocessing\n\n# CPU-bound workload\nworkers = multiprocessing.cpu_count()\n\n# I/O-bound workload (more workers)\nworkers = multiprocessing.cpu_count() * 2 + 1\n\n# From environment\nworkers = int(os.getenv(\"WORKERS\", str(multiprocessing.cpu_count())))\n</code></pre>"},{"location":"guide/deployment/hypercorn/#connection-limits","title":"Connection Limits","text":"<p>Set backlog for high-traffic applications:</p> <pre><code>hypercorn app:asgi_app --backlog 2048\n</code></pre>"},{"location":"guide/deployment/hypercorn/#keep-alive-timeout","title":"Keep-Alive Timeout","text":"<p>Adjust keep-alive timeout for your use case:</p> <pre><code># Short timeout for many short requests\nhypercorn app:asgi_app --keep-alive-timeout 2\n\n# Longer timeout for persistent connections\nhypercorn app:asgi_app --keep-alive-timeout 30\n</code></pre>"},{"location":"guide/deployment/hypercorn/#websocket-support","title":"WebSocket Support","text":"<p>Hypercorn has excellent WebSocket support:</p> <pre><code>@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket):\n    \"\"\"WebSocket endpoint.\"\"\"\n    await websocket.accept()\n\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await websocket.send_text(f\"Echo: {data}\")\n    except Exception:\n        await websocket.close()\n</code></pre> <p>Configure WebSocket timeouts:</p> <pre><code>hypercorn app:asgi_app --websocket-ping-interval 20\n</code></pre>"},{"location":"guide/deployment/hypercorn/#monitoring","title":"Monitoring","text":""},{"location":"guide/deployment/hypercorn/#health-check-endpoints","title":"Health Check Endpoints","text":"<pre><code>@app.get(\"/health\")\ndef health():\n    \"\"\"Liveness probe.\"\"\"\n    return {\"status\": \"healthy\"}\n\n@app.get(\"/ready\")\nasync def readiness(database):\n    \"\"\"Readiness probe.\"\"\"\n    try:\n        async with database.acquire() as conn:\n            await conn.fetchval(\"SELECT 1\")\n        return {\"status\": \"ready\"}\n    except Exception as e:\n        logger.error(f\"Readiness check failed: {e}\")\n        return {\"status\": \"not ready\"}, 503\n</code></pre>"},{"location":"guide/deployment/hypercorn/#kubernetes-configuration","title":"Kubernetes Configuration","text":"<p>Deployment with HTTP/2:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: myapp\n  template:\n    metadata:\n      labels:\n        app: myapp\n    spec:\n      containers:\n      - name: myapp\n        image: myapp:latest\n        ports:\n        - containerPort: 8443\n          name: https\n          protocol: TCP\n        env:\n        - name: WORKERS\n          value: \"4\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8443\n            scheme: HTTPS\n          initialDelaySeconds: 10\n          periodSeconds: 30\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8443\n            scheme: HTTPS\n          initialDelaySeconds: 5\n          periodSeconds: 10\n</code></pre>"},{"location":"guide/deployment/hypercorn/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/deployment/hypercorn/#http2-not-working","title":"HTTP/2 Not Working","text":"<p>Verify HTTP/2 is enabled:</p> <pre><code># Check with curl\ncurl -I --http2 https://localhost:8443\n\n# Check protocol in logs\nhypercorn app:asgi_app --log-level debug\n</code></pre>"},{"location":"guide/deployment/hypercorn/#ssl-certificate-issues","title":"SSL Certificate Issues","text":"<p>Test SSL configuration:</p> <pre><code># Verify certificate\nopenssl s_client -connect localhost:8443 -showcerts\n\n# Check certificate validity\nopenssl x509 -in cert.pem -text -noout\n</code></pre>"},{"location":"guide/deployment/hypercorn/#high-memory-usage","title":"High Memory Usage","text":"<p>Reduce workers or enable worker recycling:</p> <pre><code># Reduce workers\nhypercorn app:asgi_app --workers 2\n\n# Monitor memory\nps aux | grep hypercorn\n</code></pre>"},{"location":"guide/deployment/hypercorn/#connection-refused","title":"Connection Refused","text":"<p>Check if port is available:</p> <pre><code># Check port\nlsof -i :8443\n\n# Test binding\nhypercorn app:asgi_app --bind 127.0.0.1:8443\n</code></pre>"},{"location":"guide/deployment/hypercorn/#best-practices","title":"Best Practices","text":""},{"location":"guide/deployment/hypercorn/#1-use-http2-for-better-performance","title":"1. Use HTTP/2 for Better Performance","text":"<p>HTTP/2 provides: - Multiplexing (multiple requests over single connection) - Header compression - Server push capabilities</p> <pre><code>serve(app, server=\"hypercorn\", http_version=\"http2\")\n</code></pre>"},{"location":"guide/deployment/hypercorn/#2-enable-access-logs-in-production","title":"2. Enable Access Logs in Production","text":"<p>Monitor traffic with access logs:</p> <pre><code>hypercorn app:asgi_app --access-log /var/log/myapp/access.log\n</code></pre>"},{"location":"guide/deployment/hypercorn/#3-configure-proper-timeouts","title":"3. Configure Proper Timeouts","text":"<p>Set appropriate timeouts:</p> <pre><code>hypercorn app:asgi_app \\\n  --keep-alive-timeout 5 \\\n  --graceful-timeout 30\n</code></pre>"},{"location":"guide/deployment/hypercorn/#4-use-async-handlers","title":"4. Use Async Handlers","text":"<p>Leverage async support for I/O operations:</p> <pre><code>@app.get(\"/data\")\nasync def get_data(database):\n    \"\"\"Async handler for better concurrency.\"\"\"\n    result = await database.query(\"SELECT * FROM data\")\n    return result\n</code></pre>"},{"location":"guide/deployment/hypercorn/#5-implement-health-checks","title":"5. Implement Health Checks","text":"<p>Always provide health and readiness endpoints:</p> <pre><code>@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\"}\n\n@app.get(\"/ready\")\nasync def ready(database):\n    # Check dependencies\n    return {\"status\": \"ready\"}\n</code></pre>"},{"location":"guide/deployment/hypercorn/#comparison-with-other-servers","title":"Comparison with Other Servers","text":"Feature Hypercorn Uvicorn Gunicorn HTTP/1.1 \u2713 \u2713 \u2713 HTTP/2 \u2713 Limited \u2717 HTTP/3 \u2713 \u2717 \u2717 WebSockets \u2713 \u2713 \u2717 Async/Await \u2713 \u2713 Limited Auto-reload \u2717 \u2713 \u2717 Worker Management \u2713 \u2713 \u2713 Production Ready \u2713 \u2713 \u2713"},{"location":"guide/deployment/hypercorn/#when-to-use-hypercorn","title":"When to Use Hypercorn","text":"<p>Choose Hypercorn when you need:</p> <ul> <li>\u2705 HTTP/2 or HTTP/3 support</li> <li>\u2705 Excellent WebSocket support</li> <li>\u2705 Full async/await capabilities</li> <li>\u2705 Modern protocol features</li> <li>\u2705 Built-in HTTP/3 (QUIC) support</li> </ul> <p>Choose Uvicorn when you need:</p> <ul> <li>\u2705 Maximum HTTP/1.1 performance</li> <li>\u2705 Auto-reload for development</li> <li>\u2705 Simpler deployment</li> <li>\u2705 Better uvloop integration</li> </ul>"},{"location":"guide/deployment/hypercorn/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Uvicorn deployment for HTTP/1.1 performance</li> <li>Explore AWS Lambda deployment for serverless</li> <li>Check Performance Optimization tips</li> </ul>"},{"location":"guide/deployment/uvicorn/","title":"Deploying with Uvicorn","text":"<p>Uvicorn is a lightning-fast ASGI server built on uvloop and httptools, providing excellent performance for Python web applications. RestMachine provides seamless integration with Uvicorn for both development and production deployments.</p>"},{"location":"guide/deployment/uvicorn/#installation","title":"Installation","text":"<p>Install RestMachine with Uvicorn support:</p> <pre><code>pip install 'restmachine[uvicorn]'\n</code></pre> <p>Or install Uvicorn separately:</p> <pre><code>pip install restmachine uvicorn\n</code></pre> <p>For production, use uvicorn with standard extras:</p> <pre><code>pip install 'uvicorn[standard]'\n</code></pre>"},{"location":"guide/deployment/uvicorn/#quick-start","title":"Quick Start","text":""},{"location":"guide/deployment/uvicorn/#using-the-serve-function","title":"Using the serve() Function","text":"<p>The simplest way to run your application with Uvicorn:</p> <pre><code># app.py\nfrom restmachine import RestApplication, serve\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello World\"}\n\nif __name__ == \"__main__\":\n    serve(app, server=\"uvicorn\", host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Run the application:</p> <pre><code>python app.py\n</code></pre>"},{"location":"guide/deployment/uvicorn/#using-the-uvicorndriver","title":"Using the UvicornDriver","text":"<p>For more control, use the <code>UvicornDriver</code> class directly:</p> <pre><code># app.py\nfrom restmachine import RestApplication\nfrom restmachine.servers import UvicornDriver\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello World\"}\n\nif __name__ == \"__main__\":\n    driver = UvicornDriver(app, host=\"0.0.0.0\", port=8000)\n    driver.run()\n</code></pre>"},{"location":"guide/deployment/uvicorn/#using-asgi-adapter","title":"Using ASGI Adapter","text":"<p>For maximum flexibility, create an ASGI app and run with Uvicorn directly:</p> <pre><code># app.py\nfrom restmachine import RestApplication, ASGIAdapter\n\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello World\"}\n\n# Create ASGI application\nasgi_app = ASGIAdapter(app)\n</code></pre> <p>Run with Uvicorn from the command line:</p> <pre><code>uvicorn app:asgi_app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"guide/deployment/uvicorn/#configuration-options","title":"Configuration Options","text":""},{"location":"guide/deployment/uvicorn/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from restmachine import RestApplication, serve\n\napp = RestApplication()\n\nserve(\n    app,\n    server=\"uvicorn\",\n    host=\"0.0.0.0\",           # Bind to all interfaces\n    port=8000,                # Port to listen on\n    log_level=\"info\",         # Logging level\n)\n</code></pre>"},{"location":"guide/deployment/uvicorn/#development-configuration","title":"Development Configuration","text":"<p>Enable auto-reload for development:</p> <pre><code>serve(\n    app,\n    server=\"uvicorn\",\n    reload=True,              # Auto-reload on code changes\n    log_level=\"debug\",        # Verbose logging\n    host=\"127.0.0.1\",         # Local only\n    port=8000\n)\n</code></pre> <p>Or from command line:</p> <pre><code>uvicorn app:asgi_app --reload --log-level debug\n</code></pre>"},{"location":"guide/deployment/uvicorn/#production-configuration","title":"Production Configuration","text":"<p>Use multiple workers for production:</p> <pre><code>serve(\n    app,\n    server=\"uvicorn\",\n    host=\"0.0.0.0\",\n    port=8000,\n    workers=4,                # Number of worker processes\n    log_level=\"warning\",      # Less verbose logging\n)\n</code></pre> <p>Or from command line:</p> <pre><code>uvicorn app:asgi_app --host 0.0.0.0 --port 8000 --workers 4\n</code></pre>"},{"location":"guide/deployment/uvicorn/#sslhttps-support","title":"SSL/HTTPS Support","text":""},{"location":"guide/deployment/uvicorn/#development-ssl","title":"Development SSL","text":"<p>For development with self-signed certificates:</p> <pre><code>serve(\n    app,\n    server=\"uvicorn\",\n    host=\"0.0.0.0\",\n    port=8443,\n    ssl_keyfile=\"./certs/key.pem\",\n    ssl_certfile=\"./certs/cert.pem\",\n)\n</code></pre> <p>Command line:</p> <pre><code>uvicorn app:asgi_app --ssl-keyfile ./certs/key.pem --ssl-certfile ./certs/cert.pem\n</code></pre>"},{"location":"guide/deployment/uvicorn/#production-ssl","title":"Production SSL","text":"<p>For production, use proper SSL certificates (Let's Encrypt, etc.):</p> <pre><code>serve(\n    app,\n    server=\"uvicorn\",\n    host=\"0.0.0.0\",\n    port=443,\n    workers=4,\n    ssl_keyfile=\"/etc/letsencrypt/live/example.com/privkey.pem\",\n    ssl_certfile=\"/etc/letsencrypt/live/example.com/fullchain.pem\",\n)\n</code></pre>"},{"location":"guide/deployment/uvicorn/#advanced-features","title":"Advanced Features","text":""},{"location":"guide/deployment/uvicorn/#http2-support","title":"HTTP/2 Support","text":"<p>Enable HTTP/2 (requires SSL):</p> <pre><code>from restmachine.servers import UvicornDriver\n\ndriver = UvicornDriver(\n    app,\n    host=\"0.0.0.0\",\n    port=8443,\n    http_version=\"http2\"\n)\n\ndriver.run(\n    ssl_keyfile=\"./certs/key.pem\",\n    ssl_certfile=\"./certs/cert.pem\",\n)\n</code></pre>"},{"location":"guide/deployment/uvicorn/#custom-logging","title":"Custom Logging","text":"<p>Configure custom logging:</p> <pre><code>import logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\nserve(\n    app,\n    server=\"uvicorn\",\n    log_config=None,  # Use Python's logging config\n    log_level=\"info\"\n)\n</code></pre>"},{"location":"guide/deployment/uvicorn/#access-logs","title":"Access Logs","text":"<p>Enable or disable access logs:</p> <pre><code>serve(\n    app,\n    server=\"uvicorn\",\n    access_log=True,  # Enable access logs (default)\n)\n</code></pre> <p>Command line:</p> <pre><code># Disable access logs for better performance\nuvicorn app:asgi_app --no-access-log\n</code></pre>"},{"location":"guide/deployment/uvicorn/#production-deployment","title":"Production Deployment","text":""},{"location":"guide/deployment/uvicorn/#systemd-service","title":"Systemd Service","text":"<p>Create a systemd service file for production deployment:</p> <p><code>/etc/systemd/system/myapp.service</code>:</p> <pre><code>[Unit]\nDescription=My RestMachine Application\nAfter=network.target\n\n[Service]\nType=notify\nUser=www-data\nGroup=www-data\nWorkingDirectory=/var/www/myapp\nEnvironment=\"PATH=/var/www/myapp/venv/bin\"\nExecStart=/var/www/myapp/venv/bin/uvicorn app:asgi_app --host 0.0.0.0 --port 8000 --workers 4\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Enable and start the service:</p> <pre><code>sudo systemctl enable myapp\nsudo systemctl start myapp\nsudo systemctl status myapp\n</code></pre>"},{"location":"guide/deployment/uvicorn/#behind-nginx","title":"Behind Nginx","text":"<p>Use Nginx as a reverse proxy:</p> <p><code>/etc/nginx/sites-available/myapp</code>:</p> <pre><code>upstream restmachine {\n    server 127.0.0.1:8000;\n}\n\nserver {\n    listen 80;\n    server_name example.com www.example.com;\n\n    # Redirect HTTP to HTTPS\n    return 301 https://$host$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name example.com www.example.com;\n\n    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n\n    # SSL configuration\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers HIGH:!aNULL:!MD5;\n\n    location / {\n        proxy_pass http://restmachine;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre> <p>Enable the site:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/myapp /etc/nginx/sites-enabled/\nsudo nginx -t\nsudo systemctl reload nginx\n</code></pre>"},{"location":"guide/deployment/uvicorn/#docker-deployment","title":"Docker Deployment","text":"<p>Create a Dockerfile:</p> <pre><code>FROM python:3.11-slim\n\nWORKDIR /app\n\n# Install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application\nCOPY . .\n\n# Expose port\nEXPOSE 8000\n\n# Run with Uvicorn\nCMD [\"uvicorn\", \"app:asgi_app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\", \"--workers\", \"4\"]\n</code></pre> <p>requirements.txt:</p> <pre><code>restmachine[uvicorn]\n</code></pre> <p>Build and run:</p> <pre><code>docker build -t myapp .\ndocker run -p 8000:8000 myapp\n</code></pre>"},{"location":"guide/deployment/uvicorn/#docker-compose","title":"Docker Compose","text":"<p><code>docker-compose.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - LOG_LEVEL=info\n      - WORKERS=4\n    restart: unless-stopped\n</code></pre> <p>Run with:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"guide/deployment/uvicorn/#complete-example","title":"Complete Example","text":"<p>Here's a complete production-ready example:</p> <pre><code># app.py\nimport os\nfrom restmachine import RestApplication, ASGIAdapter\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\nlogger = logging.getLogger(__name__)\n\n# Create application\napp = RestApplication()\n\n@app.on_startup\ndef database():\n    \"\"\"Initialize database connection pool.\"\"\"\n    logger.info(\"Connecting to database...\")\n    # Return database connection pool\n    # Note: create_db_pool() is a placeholder - implement based on your database\n    return create_db_pool()\n\n@app.on_shutdown\ndef close_database(database):\n    \"\"\"Close database connections.\"\"\"\n    logger.info(\"Closing database connections...\")\n    database.close()\n\n@app.get(\"/\")\ndef home():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"healthy\"}\n\n@app.get(\"/api/users/{user_id}\")\ndef get_user(path_params, database):\n    \"\"\"Get a user by ID.\"\"\"\n    user_id = path_params['user_id']\n    user = database.get_user(user_id)\n    if not user:\n        return {\"error\": \"User not found\"}, 404\n    return user\n\n# Create ASGI app\nasgi_app = ASGIAdapter(app)\n\n# For running directly\nif __name__ == \"__main__\":\n    import uvicorn\n\n    # Get configuration from environment\n    host = os.getenv(\"HOST\", \"0.0.0.0\")\n    port = int(os.getenv(\"PORT\", \"8000\"))\n    workers = int(os.getenv(\"WORKERS\", \"4\"))\n    log_level = os.getenv(\"LOG_LEVEL\", \"info\")\n\n    uvicorn.run(\n        asgi_app,\n        host=host,\n        port=port,\n        workers=workers,\n        log_level=log_level,\n    )\n</code></pre> <p>Run in development:</p> <pre><code>python app.py\n</code></pre> <p>Run in production:</p> <pre><code>export WORKERS=8\nexport LOG_LEVEL=warning\nuvicorn app:asgi_app --host 0.0.0.0 --port 8000 --workers 8\n</code></pre>"},{"location":"guide/deployment/uvicorn/#performance-tuning","title":"Performance Tuning","text":""},{"location":"guide/deployment/uvicorn/#worker-count","title":"Worker Count","text":"<p>Set workers based on CPU cores:</p> <pre><code>import multiprocessing\n\nworkers = multiprocessing.cpu_count() * 2 + 1  # Common formula\n\nserve(app, server=\"uvicorn\", workers=workers)\n</code></pre> <p>Or from environment:</p> <pre><code>export WORKERS=$(nproc --all)\nuvicorn app:asgi_app --workers $WORKERS\n</code></pre>"},{"location":"guide/deployment/uvicorn/#connection-limits","title":"Connection Limits","text":"<p>Configure connection limits:</p> <pre><code>uvicorn app:asgi_app \\\n  --limit-concurrency 1000 \\\n  --limit-max-requests 10000 \\\n  --timeout-keep-alive 5\n</code></pre>"},{"location":"guide/deployment/uvicorn/#event-loop","title":"Event Loop","text":"<p>Use uvloop for better performance (installed with <code>uvicorn[standard]</code>):</p> <pre><code>uvicorn app:asgi_app --loop uvloop\n</code></pre>"},{"location":"guide/deployment/uvicorn/#monitoring-and-health-checks","title":"Monitoring and Health Checks","text":""},{"location":"guide/deployment/uvicorn/#health-check-endpoint","title":"Health Check Endpoint","text":"<p>Add a health check endpoint:</p> <pre><code>@app.get(\"/health\")\ndef health_check():\n    \"\"\"Kubernetes/Docker health check.\"\"\"\n    return {\"status\": \"healthy\", \"version\": \"1.0.0\"}\n\n@app.get(\"/ready\")\ndef readiness_check(database):\n    \"\"\"Readiness check - verify dependencies.\"\"\"\n    if not database.is_connected():\n        return {\"status\": \"not ready\"}, 503\n    return {\"status\": \"ready\"}\n</code></pre>"},{"location":"guide/deployment/uvicorn/#kubernetes-probes","title":"Kubernetes Probes","text":"<p>Liveness probe:</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /health\n    port: 8000\n  initialDelaySeconds: 10\n  periodSeconds: 30\n</code></pre> <p>Readiness probe:</p> <pre><code>readinessProbe:\n  httpGet:\n    path: /ready\n    port: 8000\n  initialDelaySeconds: 5\n  periodSeconds: 10\n</code></pre>"},{"location":"guide/deployment/uvicorn/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/deployment/uvicorn/#port-already-in-use","title":"Port Already in Use","text":"<pre><code># Find process using port 8000\nlsof -i :8000\n\n# Kill the process\nkill -9 &lt;PID&gt;\n</code></pre>"},{"location":"guide/deployment/uvicorn/#worker-timeout","title":"Worker Timeout","text":"<p>Increase timeout for long-running requests:</p> <pre><code>uvicorn app:asgi_app --timeout-keep-alive 30\n</code></pre>"},{"location":"guide/deployment/uvicorn/#memory-issues","title":"Memory Issues","text":"<p>Monitor memory usage and adjust workers:</p> <pre><code># Check memory usage\nps aux | grep uvicorn\n\n# Reduce workers if memory is high\nuvicorn app:asgi_app --workers 2\n</code></pre>"},{"location":"guide/deployment/uvicorn/#debugging","title":"Debugging","text":"<p>Enable debug logging:</p> <pre><code>uvicorn app:asgi_app --log-level debug --reload\n</code></pre>"},{"location":"guide/deployment/uvicorn/#best-practices","title":"Best Practices","text":""},{"location":"guide/deployment/uvicorn/#1-use-environment-variables-for-configuration","title":"1. Use Environment Variables for Configuration","text":"<pre><code>import os\n\nhost = os.getenv(\"HOST\", \"0.0.0.0\")\nport = int(os.getenv(\"PORT\", \"8000\"))\nworkers = int(os.getenv(\"WORKERS\", \"4\"))\n</code></pre>"},{"location":"guide/deployment/uvicorn/#2-implement-graceful-shutdown","title":"2. Implement Graceful Shutdown","text":"<pre><code>@app.on_shutdown\nasync def shutdown():\n    \"\"\"Clean up resources on shutdown.\"\"\"\n    await cleanup_tasks()\n    logger.info(\"Application shut down gracefully\")\n</code></pre>"},{"location":"guide/deployment/uvicorn/#3-use-process-managers","title":"3. Use Process Managers","text":"<p>Don't run Uvicorn directly in production. Use: - Systemd - Supervisor - Docker - Kubernetes</p>"},{"location":"guide/deployment/uvicorn/#4-monitor-application-health","title":"4. Monitor Application Health","text":"<p>Implement health checks and monitor: - Request latency - Error rates - Memory usage - CPU usage</p>"},{"location":"guide/deployment/uvicorn/#5-secure-your-deployment","title":"5. Secure Your Deployment","text":"<ul> <li>Use HTTPS in production</li> <li>Keep dependencies updated</li> <li>Limit worker count to available resources</li> <li>Use a reverse proxy (Nginx, Traefik)</li> </ul>"},{"location":"guide/deployment/uvicorn/#comparison-with-other-servers","title":"Comparison with Other Servers","text":"Feature Uvicorn Hypercorn Gunicorn ASGI Support \u2713 \u2713 \u2717 (WSGI only) HTTP/2 Limited \u2713 \u2717 HTTP/3 \u2717 \u2713 \u2717 WebSockets \u2713 \u2713 \u2717 Performance Excellent Very Good Good Production Ready \u2713 \u2713 \u2713 Auto-reload \u2713 \u2717 \u2717"},{"location":"guide/deployment/uvicorn/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Hypercorn deployment for HTTP/2 and HTTP/3 support</li> <li>Explore AWS Lambda deployment for serverless applications</li> <li>Read about Performance Optimization for tuning tips</li> </ul>"},{"location":"restmachine-aws/","title":"RestMachine AWS","text":"<p>AWS Lambda integration for RestMachine, providing seamless deployment to AWS Lambda with support for API Gateway v1/v2, ALB, and Lambda Function URLs.</p>"},{"location":"restmachine-aws/#features","title":"Features","text":"<ul> <li>Multiple Lambda Event Sources: Support for API Gateway v1/v2, Application Load Balancer (ALB), and Lambda Function URLs</li> <li>Lambda Extensions: Custom TLS/mTLS validation, custom authorizers, and more</li> <li>Startup/Shutdown Handlers: Lifecycle management for Lambda functions</li> <li>Performance Optimized: Efficient request/response handling for serverless environments</li> </ul>"},{"location":"restmachine-aws/#quick-links","title":"Quick Links","text":"<ul> <li>AWS Lambda Deployment Guide</li> <li>API Reference</li> </ul>"},{"location":"restmachine-aws/api/adapter/","title":"AWS Lambda Adapter","text":""},{"location":"restmachine-aws/api/adapter/#restmachine_aws.AwsApiGatewayAdapter","title":"AwsApiGatewayAdapter","text":"<pre><code>AwsApiGatewayAdapter(\n    app: RestApplication,\n    metrics_publisher: Union[\n        MetricsPublisher, None, _DefaultPublisher\n    ] = _DEFAULT_PUBLISHER,\n    enable_metrics: Optional[bool] = None,\n    namespace: Optional[str] = None,\n    service_name: Optional[str] = None,\n    metrics_resolution: int = 60,\n)\n</code></pre> <p>               Bases: <code>Adapter</code></p> <p>Adapter for AWS API Gateway Lambda proxy integration events.</p> <p>This adapter handles events from: - API Gateway REST APIs (v1) - payload format 1.0 - API Gateway HTTP APIs (v2) - payload format 2.0 - Application Load Balancer (ALB) - Lambda Function URLs (v2 format)</p> <p>Version detection is automatic based on event structure: - v1 events use <code>httpMethod</code> at top level - v2 events have <code>version: \"2.0\"</code> field - ALB events have <code>requestContext.elb</code> field</p> <p>Follows ASGI patterns for header and parameter handling: - Headers are normalized to lowercase for case-insensitive matching - Query parameters are parsed consistently - Body encoding is handled transparently</p> <p>Initialize the adapter with a RestApplication instance.</p> <p>Automatically executes startup handlers during cold start and configures CloudWatch EMF metrics unless disabled.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>RestApplication</code> <p>The RestApplication instance to execute requests against</p> required <code>metrics_publisher</code> <code>Union[MetricsPublisher, None, _DefaultPublisher]</code> <p>Metrics publisher. Defaults to CloudWatchEMFPublisher.               Pass None to explicitly disable metrics.</p> <code>_DEFAULT_PUBLISHER</code> <code>enable_metrics</code> <code>Optional[bool]</code> <p>Explicitly enable/disable metrics.</p> <code>None</code> <code>namespace</code> <code>Optional[str]</code> <p>CloudWatch namespace (overrides env var)</p> <code>None</code> <code>service_name</code> <code>Optional[str]</code> <p>Service name for dimension (overrides env var)</p> <code>None</code> <code>metrics_resolution</code> <code>int</code> <p>Default resolution, 1 or 60 seconds (default: 60)</p> <code>60</code> <p>Examples:</p>"},{"location":"restmachine-aws/api/adapter/#restmachine_aws.AwsApiGatewayAdapter--auto-emf-with-custom-namespace","title":"Auto EMF with custom namespace","text":"<p>adapter = AwsApiGatewayAdapter(     app,     namespace=\"MyApp/API\",     service_name=\"user-service\" )</p>"},{"location":"restmachine-aws/api/adapter/#restmachine_aws.AwsApiGatewayAdapter--high-resolution-metrics","title":"High-resolution metrics","text":"<p>adapter = AwsApiGatewayAdapter(     app,     namespace=\"MyApp/API\",     metrics_resolution=1 )</p>"},{"location":"restmachine-aws/api/adapter/#restmachine_aws.AwsApiGatewayAdapter--disable-metrics","title":"Disable metrics","text":"<p>adapter = AwsApiGatewayAdapter(app, enable_metrics=False)</p> Source code in <code>packages/restmachine-aws/src/restmachine_aws/adapter.py</code> <pre><code>def __init__(self,\n             app: RestApplication,\n             metrics_publisher: Union[MetricsPublisher, None, _DefaultPublisher] = _DEFAULT_PUBLISHER,\n             enable_metrics: Optional[bool] = None,\n             namespace: Optional[str] = None,\n             service_name: Optional[str] = None,\n             metrics_resolution: int = 60):\n    \"\"\"\n    Initialize the adapter with a RestApplication instance.\n\n    Automatically executes startup handlers during cold start and\n    configures CloudWatch EMF metrics unless disabled.\n\n    Args:\n        app: The RestApplication instance to execute requests against\n        metrics_publisher: Metrics publisher. Defaults to CloudWatchEMFPublisher.\n                          Pass None to explicitly disable metrics.\n        enable_metrics: Explicitly enable/disable metrics.\n        namespace: CloudWatch namespace (overrides env var)\n        service_name: Service name for dimension (overrides env var)\n        metrics_resolution: Default resolution, 1 or 60 seconds (default: 60)\n\n    Examples:\n        # Auto EMF with custom namespace\n        adapter = AwsApiGatewayAdapter(\n            app,\n            namespace=\"MyApp/API\",\n            service_name=\"user-service\"\n        )\n\n        # High-resolution metrics\n        adapter = AwsApiGatewayAdapter(\n            app,\n            namespace=\"MyApp/API\",\n            metrics_resolution=1\n        )\n\n        # Disable metrics\n        adapter = AwsApiGatewayAdapter(app, enable_metrics=False)\n    \"\"\"\n    self.app = app\n\n    # Determine if metrics should be enabled\n    metrics_enabled = self._should_enable_metrics(enable_metrics)\n\n    # Auto-configure publisher if not provided\n    publisher: Optional[MetricsPublisher]\n    if isinstance(metrics_publisher, _DefaultPublisher):\n        if metrics_enabled:\n            publisher = self._create_default_publisher(\n                namespace=namespace,\n                service_name=service_name,\n                resolution=metrics_resolution\n            )\n            self._configure_default_logging()\n        else:\n            publisher = None\n    else:\n        publisher = metrics_publisher\n\n    self.metrics_handler = MetricsHandler(app, publisher)\n\n    # Execute startup handlers during Lambda cold start\n    # This ensures database connections, API clients, etc. are initialized\n    # before the first request is processed\n    if hasattr(app, '_startup_handlers') and app._startup_handlers:\n        app.startup_sync()\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#restmachine_aws.AwsApiGatewayAdapter-functions","title":"Functions","text":""},{"location":"restmachine-aws/api/adapter/#restmachine_aws.AwsApiGatewayAdapter.handle_event","title":"handle_event","text":"<pre><code>handle_event(\n    event: Dict[str, Any], context: Optional[Any] = None\n) -&gt; Dict[str, Any]\n</code></pre> <p>Handle an AWS API Gateway event with metrics support.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Dict[str, Any]</code> <p>AWS API Gateway event dictionary</p> required <code>context</code> <code>Optional[Any]</code> <p>AWS Lambda context (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>AWS API Gateway response dictionary</p> Source code in <code>packages/restmachine-aws/src/restmachine_aws/adapter.py</code> <pre><code>def handle_event(self, event: Dict[str, Any], context: Optional[Any] = None) -&gt; Dict[str, Any]:\n    \"\"\"\n    Handle an AWS API Gateway event with metrics support.\n\n    Args:\n        event: AWS API Gateway event dictionary\n        context: AWS Lambda context (optional)\n\n    Returns:\n        AWS API Gateway response dictionary\n    \"\"\"\n    return cast(Dict[str, Any], self.metrics_handler.handle_request(\n        event,\n        context,\n        convert_fn=self.convert_to_request,\n        execute_fn=self.app.execute,\n        response_fn=self.convert_from_response\n    ))\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#restmachine_aws.AwsApiGatewayAdapter.convert_to_request","title":"convert_to_request","text":"<pre><code>convert_to_request(\n    event: Dict[str, Any], context: Optional[Any] = None\n) -&gt; Request\n</code></pre> <p>Convert AWS event to Request object.</p> <p>Automatically detects and handles: - API Gateway (v1, v2) events - Application Load Balancer (ALB) events - Lambda Function URL events</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Dict[str, Any]</code> <p>AWS event dictionary</p> required <code>context</code> <code>Optional[Any]</code> <p>AWS Lambda context (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>Request</code> <p>Request object</p> Source code in <code>packages/restmachine-aws/src/restmachine_aws/adapter.py</code> <pre><code>def convert_to_request(self, event: Dict[str, Any], context: Optional[Any] = None) -&gt; Request:\n    \"\"\"\n    Convert AWS event to Request object.\n\n    Automatically detects and handles:\n    - API Gateway (v1, v2) events\n    - Application Load Balancer (ALB) events\n    - Lambda Function URL events\n\n    Args:\n        event: AWS event dictionary\n        context: AWS Lambda context (optional)\n\n    Returns:\n        Request object\n    \"\"\"\n    # Detect event type and delegate to appropriate parser\n    if self._is_alb_event(event):\n        return self._parse_alb_event(event, context)\n    else:\n        return self._parse_apigw_event(event, context)\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#restmachine_aws.AwsApiGatewayAdapter.convert_from_response","title":"convert_from_response","text":"<pre><code>convert_from_response(\n    response: Response, event: Dict[str, Any], context: Optional[Any] = None\n) -&gt; Dict[str, Any]\n</code></pre> <p>Convert Response object to AWS API Gateway response format.</p> <p>Handles proper JSON serialization, header encoding, streaming bodies, and file paths. For streaming bodies and Path objects, reads the entire content since Lambda requires complete responses.</p> <p>Range Request Support: - Detects 206 Partial Content responses (response.is_range_response()) - Extracts only the requested byte range from Path, stream, or bytes body - Base64 encodes the range content for transmission</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Response from the app</p> required <code>event</code> <code>Dict[str, Any]</code> <p>Original AWS API Gateway event</p> required <code>context</code> <code>Optional[Any]</code> <p>AWS Lambda context (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>AWS API Gateway response dictionary</p> Source code in <code>packages/restmachine-aws/src/restmachine_aws/adapter.py</code> <pre><code>def convert_from_response(self, response: Response, event: Dict[str, Any], context: Optional[Any] = None) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert Response object to AWS API Gateway response format.\n\n    Handles proper JSON serialization, header encoding, streaming bodies, and file paths.\n    For streaming bodies and Path objects, reads the entire content since Lambda requires complete responses.\n\n    Range Request Support:\n    - Detects 206 Partial Content responses (response.is_range_response())\n    - Extracts only the requested byte range from Path, stream, or bytes body\n    - Base64 encodes the range content for transmission\n\n    Args:\n        response: Response from the app\n        event: Original AWS API Gateway event\n        context: AWS Lambda context (optional)\n\n    Returns:\n        AWS API Gateway response dictionary\n    \"\"\"\n    # Handle range responses specially\n    if response.is_range_response():\n        return self._convert_range_response(response)\n\n    # Convert body to string and track if we used base64 encoding\n    is_base64 = False\n\n    if response.body is None:\n        body_str = \"\"\n    elif isinstance(response.body, Path):\n        # Path object - read the file since Lambda requires complete response\n        path_obj = response.body\n        if path_obj.exists() and path_obj.is_file():\n            with path_obj.open('rb') as f:\n                body_bytes = f.read()\n            try:\n                body_str = body_bytes.decode('utf-8')\n            except UnicodeDecodeError:\n                # If not valid UTF-8, return as base64\n                import base64\n                body_str = base64.b64encode(body_bytes).decode('ascii')\n                is_base64 = True\n        else:\n            # File doesn't exist\n            body_str = \"\"\n    elif isinstance(response.body, io.IOBase):\n        # Streaming body - read the entire stream since Lambda requires complete response\n        body_bytes = response.body.read()\n        try:\n            body_str = body_bytes.decode('utf-8')\n        except (UnicodeDecodeError, AttributeError):\n            # If not valid UTF-8, return as base64\n            import base64\n            body_str = base64.b64encode(body_bytes).decode('ascii')\n            is_base64 = True\n    elif isinstance(response.body, bytes):\n        # Raw bytes - try to decode as UTF-8, otherwise base64\n        try:\n            body_str = response.body.decode('utf-8')\n        except UnicodeDecodeError:\n            import base64\n            body_str = base64.b64encode(response.body).decode('ascii')\n            is_base64 = True\n    elif isinstance(response.body, (dict, list)):\n        body_str = json.dumps(response.body)\n    elif isinstance(response.body, (str, int, float, bool)):\n        body_str = str(response.body)\n    else:\n        body_str = str(response.body)\n\n    # Build the API Gateway response\n    # Convert MultiValueHeaders to dict (first value for each header)\n    if response.headers:\n        if isinstance(response.headers, MultiValueHeaders):\n            headers_dict = response.headers.to_dict()\n        else:\n            headers_dict = dict(response.headers)\n    else:\n        headers_dict = {}\n\n    # Ensure Content-Type is set for JSON responses\n    if isinstance(response.body, (dict, list)) and \"content-type\" not in (\n        {k.lower(): k for k in headers_dict.keys()}\n    ):\n        headers_dict[\"Content-Type\"] = \"application/json\"\n\n    # Build and return the API Gateway response\n    api_response = {\n        \"statusCode\": response.status_code,\n        \"headers\": headers_dict,\n        \"body\": body_str,\n        \"isBase64Encoded\": is_base64\n    }\n\n    return api_response\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#overview","title":"Overview","text":"<p>The <code>AwsApiGatewayAdapter</code> converts AWS Lambda events into RestMachine requests and responses back into Lambda-compatible formats. It automatically detects and handles multiple event sources.</p>"},{"location":"restmachine-aws/api/adapter/#supported-event-sources","title":"Supported Event Sources","text":"<p>The adapter automatically detects and handles:</p> <ul> <li>API Gateway REST API (v1) - Payload format 1.0</li> <li>API Gateway HTTP API (v2) - Payload format 2.0</li> <li>Application Load Balancer (ALB) - ALB target integration</li> <li>Lambda Function URLs - Direct HTTPS endpoints (uses v2 format)</li> </ul> <p>Version detection is automatic based on the event structure.</p>"},{"location":"restmachine-aws/api/adapter/#basic-usage","title":"Basic Usage","text":"<pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\n\napp = RestApplication()\n\n@app.get(\"/hello/{name}\")\ndef hello(request):\n    name = request.path_params['name']\n    return {\"message\": f\"Hello, {name}!\"}\n\n# Create adapter\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    \"\"\"AWS Lambda handler function.\"\"\"\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#automatic-startup","title":"Automatic Startup","text":"<p>The adapter automatically runs startup handlers during Lambda cold start:</p> <pre><code>@app.on_startup\ndef database():\n    \"\"\"Runs once per Lambda container.\"\"\"\n    print(\"Opening database connection...\")\n    return create_db_connection()\n\n@app.get(\"/users/{user_id}\")\ndef get_user(database, request):\n    # Database connection is already initialized\n    user_id = request.path_params['user_id']\n    return database.get_user(user_id)\n</code></pre> <p>Startup handlers execute when the Lambda container initializes, not on every request. This ensures expensive operations (like opening database connections) only happen during cold starts.</p>"},{"location":"restmachine-aws/api/adapter/#event-format-detection","title":"Event Format Detection","text":""},{"location":"restmachine-aws/api/adapter/#api-gateway-v1-rest-api","title":"API Gateway v1 (REST API)","text":"<pre><code>{\n    \"httpMethod\": \"GET\",\n    \"path\": \"/users/123\",\n    \"headers\": {\"Accept\": \"application/json\"},\n    \"pathParameters\": {\"user_id\": \"123\"},\n    \"queryStringParameters\": {\"page\": \"1\"},\n    \"body\": null,\n    \"requestContext\": {\n        \"requestId\": \"abc123\",\n        \"authorizer\": {...}\n    }\n}\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#api-gateway-v2-http-api","title":"API Gateway v2 (HTTP API)","text":"<pre><code>{\n    \"version\": \"2.0\",\n    \"routeKey\": \"GET /users/{user_id}\",\n    \"rawPath\": \"/users/123\",\n    \"headers\": {\"accept\": \"application/json\"},\n    \"pathParameters\": {\"user_id\": \"123\"},\n    \"queryStringParameters\": {\"page\": \"1\"},\n    \"body\": null,\n    \"requestContext\": {\n        \"http\": {\n            \"method\": \"GET\",\n            \"path\": \"/users/123\"\n        }\n    }\n}\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#application-load-balancer-alb","title":"Application Load Balancer (ALB)","text":"<pre><code>{\n    \"httpMethod\": \"GET\",\n    \"path\": \"/users/123\",\n    \"headers\": {\"accept\": \"application/json\"},\n    \"queryStringParameters\": {\"page\": \"1\"},\n    \"body\": null,\n    \"requestContext\": {\n        \"elb\": {\n            \"targetGroupArn\": \"arn:aws:...\"\n        }\n    }\n}\n</code></pre> <p>The adapter automatically detects the format and extracts the correct fields.</p>"},{"location":"restmachine-aws/api/adapter/#header-handling","title":"Header Handling","text":"<p>Headers are normalized to lowercase for case-insensitive matching, following ASGI conventions:</p> <pre><code># API Gateway event\n{\n    \"headers\": {\n        \"Content-Type\": \"application/json\",\n        \"X-Custom-Header\": \"value\"\n    }\n}\n\n# Converted to\nrequest.headers = {\n    \"content-type\": \"application/json\",\n    \"x-custom-header\": \"value\"\n}\n</code></pre> <p>Access headers in your handlers:</p> <pre><code>@app.get(\"/api/data\")\ndef get_data(request):\n    content_type = request.headers.get(\"content-type\")\n    custom = request.headers.get(\"x-custom-header\")\n    return {\"content_type\": content_type, \"custom\": custom}\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#multi-value-headers","title":"Multi-Value Headers","text":"<p>The adapter properly handles multi-value headers (cookies, set-cookie, etc.):</p> <pre><code># API Gateway v1 with multiValueHeaders\n{\n    \"multiValueHeaders\": {\n        \"cookie\": [\"session=abc123\", \"tracking=xyz789\"]\n    }\n}\n\n# Converted to RestMachine request\nrequest.headers = MultiValueHeaders({\n    \"cookie\": [\"session=abc123\", \"tracking=xyz789\"]\n})\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#query-parameters","title":"Query Parameters","text":"<p>Query parameters are parsed and available as dictionaries:</p> <pre><code># Event\n{\n    \"queryStringParameters\": {\n        \"page\": \"2\",\n        \"limit\": \"10\"\n    }\n}\n\n# Access in handler\n@app.get(\"/users\")\ndef list_users(request):\n    page = int(request.query_params.get(\"page\", 1))\n    limit = int(request.query_params.get(\"limit\", 20))\n    return {\"page\": page, \"limit\": limit}\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#request-body","title":"Request Body","text":"<p>The adapter handles both plain text and base64-encoded bodies:</p> <pre><code># Plain text body\n{\n    \"body\": '{\"name\": \"Alice\", \"email\": \"alice@example.com\"}',\n    \"isBase64Encoded\": false\n}\n\n# Base64-encoded body (binary data)\n{\n    \"body\": \"iVBORw0KGgoAAAANSUhEUgAA...\",\n    \"isBase64Encoded\": true\n}\n\n# Access in handler\n@app.post(\"/users\")\ndef create_user(request):\n    import json\n    data = json.loads(request.body)\n    return {\"created\": data}, 201\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#response-conversion","title":"Response Conversion","text":"<p>RestMachine responses are automatically converted to Lambda-compatible formats:</p> <pre><code># RestMachine response\nResponse(\n    status_code=200,\n    body='{\"message\": \"Success\"}',\n    headers={\"Content-Type\": \"application/json\"}\n)\n\n# Converted to API Gateway v1 format\n{\n    \"statusCode\": 200,\n    \"body\": '{\"message\": \"Success\"}',\n    \"headers\": {\"Content-Type\": \"application/json\"},\n    \"multiValueHeaders\": {},\n    \"isBase64Encoded\": false\n}\n\n# Converted to API Gateway v2 format\n{\n    \"statusCode\": 200,\n    \"body\": '{\"message\": \"Success\"}',\n    \"headers\": {\"content-type\": \"application/json\"},\n    \"cookies\": [],\n    \"isBase64Encoded\": false\n}\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#error-handling","title":"Error Handling","text":"<p>The adapter handles errors gracefully:</p> <pre><code>@app.get(\"/users/{user_id}\")\ndef get_user(request):\n    user_id = request.path_params['user_id']\n    if not user_exists(user_id):\n        return {\"error\": \"User not found\"}, 404\n    return {\"id\": user_id, \"name\": \"Alice\"}\n\n# Returns proper Lambda error response\n{\n    \"statusCode\": 404,\n    \"body\": '{\"error\": \"User not found\"}',\n    \"headers\": {\"Content-Type\": \"application/json\"}\n}\n</code></pre>"},{"location":"restmachine-aws/api/adapter/#method-reference","title":"Method Reference","text":""},{"location":"restmachine-aws/api/adapter/#handle_eventevent-context","title":"<code>handle_event(event, context)</code>","text":"<p>Main entry point for Lambda handler.</p> <p>Parameters: - <code>event</code> (dict): AWS Lambda event dictionary - <code>context</code> (optional): AWS Lambda context object</p> <p>Returns: - dict: Lambda-compatible response dictionary</p> <p>Example: <pre><code>def lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre></p>"},{"location":"restmachine-aws/api/adapter/#convert_to_requestevent-context","title":"<code>convert_to_request(event, context)</code>","text":"<p>Convert AWS event to RestMachine Request object.</p> <p>Parameters: - <code>event</code> (dict): AWS Lambda event - <code>context</code> (optional): Lambda context</p> <p>Returns: - Request: RestMachine Request object</p>"},{"location":"restmachine-aws/api/adapter/#convert_from_responseresponse-event-context","title":"<code>convert_from_response(response, event, context)</code>","text":"<p>Convert RestMachine Response to Lambda response format.</p> <p>Parameters: - <code>response</code> (Response): RestMachine response - <code>event</code> (dict): Original AWS event (for format detection) - <code>context</code> (optional): Lambda context</p> <p>Returns: - dict: Lambda-compatible response</p>"},{"location":"restmachine-aws/api/adapter/#see-also","title":"See Also","text":"<ul> <li>Lambda Deployment Guide - Complete deployment guide</li> <li>Lambda Extensions - Shutdown handler support</li> <li>Lifecycle Handlers - Startup and shutdown patterns</li> </ul>"},{"location":"restmachine-aws/api/extension/","title":"Lambda Extension","text":""},{"location":"restmachine-aws/api/extension/#restmachine_aws.extension.ShutdownExtension","title":"ShutdownExtension","text":"<pre><code>ShutdownExtension(\n    handler_module: str = \"lambda_function\", app_name: str = \"app\"\n)\n</code></pre> <p>AWS Lambda Extension that executes shutdown handlers on container termination.</p> <p>This extension registers with the Lambda Runtime Extensions API, waits for SHUTDOWN events, and calls the RestMachine application's shutdown_sync() method.</p> <p>The extension runs as a separate process from your Lambda handler, monitoring the Lambda lifecycle and ensuring cleanup code runs before the container terminates.</p> Example <pre><code>from restmachine_aws.extension import ShutdownExtension\n\nextension = ShutdownExtension(\n    handler_module=\"lambda_function\",\n    app_name=\"app\"\n)\nextension.run()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>handler_module</code> <code>str</code> <p>Python module containing the Lambda handler (default: \"lambda_function\")</p> <code>'lambda_function'</code> <code>app_name</code> <code>str</code> <p>Name of the RestApplication variable in the handler module (default: \"app\")</p> <code>'app'</code> <p>Initialize the Lambda Extension.</p> <p>Parameters:</p> Name Type Description Default <code>handler_module</code> <code>str</code> <p>Module name where the RestApplication is defined</p> <code>'lambda_function'</code> <code>app_name</code> <code>str</code> <p>Variable name of the RestApplication instance</p> <code>'app'</code> Source code in <code>packages/restmachine-aws/src/restmachine_aws/extension.py</code> <pre><code>def __init__(self, handler_module: str = \"lambda_function\", app_name: str = \"app\"):\n    \"\"\"\n    Initialize the Lambda Extension.\n\n    Args:\n        handler_module: Module name where the RestApplication is defined\n        app_name: Variable name of the RestApplication instance\n    \"\"\"\n    self.handler_module = handler_module\n    self.app_name = app_name\n    self.extension_id: Optional[str] = None\n\n    # Get Lambda Runtime API endpoint from environment\n    self.runtime_api = os.environ.get(\"AWS_LAMBDA_RUNTIME_API\")\n    if not self.runtime_api:\n        raise RuntimeError(\n            \"AWS_LAMBDA_RUNTIME_API environment variable not set. \"\n            \"This extension must be run within an AWS Lambda environment.\"\n        )\n</code></pre>"},{"location":"restmachine-aws/api/extension/#restmachine_aws.extension.ShutdownExtension-functions","title":"Functions","text":""},{"location":"restmachine-aws/api/extension/#restmachine_aws.extension.ShutdownExtension.register","title":"register","text":"<pre><code>register() -&gt; str\n</code></pre> <p>Register this extension with the Lambda Runtime Extensions API.</p> <p>Sends a POST request to the Extensions API to register for SHUTDOWN events. The Lambda runtime will send a SHUTDOWN event when the container is about to terminate, allowing cleanup handlers to execute.</p> <p>Returns:</p> Type Description <code>str</code> <p>Extension ID assigned by the Lambda runtime</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If registration fails</p> Source code in <code>packages/restmachine-aws/src/restmachine_aws/extension.py</code> <pre><code>def register(self) -&gt; str:\n    \"\"\"\n    Register this extension with the Lambda Runtime Extensions API.\n\n    Sends a POST request to the Extensions API to register for SHUTDOWN events.\n    The Lambda runtime will send a SHUTDOWN event when the container is about\n    to terminate, allowing cleanup handlers to execute.\n\n    Returns:\n        Extension ID assigned by the Lambda runtime\n\n    Raises:\n        RuntimeError: If registration fails\n    \"\"\"\n    url = f\"http://{self.runtime_api}/2020-01-01/extension/register\"\n\n    payload = {\"events\": [\"SHUTDOWN\"]}\n    data = json.dumps(payload).encode(\"utf-8\")\n\n    req = request.Request(\n        url,\n        data=data,\n        headers={\n            \"Lambda-Extension-Name\": \"restmachine-shutdown\",\n            \"Content-Type\": \"application/json\",\n        },\n        method=\"POST\",\n    )\n\n    try:\n        # nosec B310: Lambda Extensions API is only accessible over localhost HTTP\n        with request.urlopen(req) as response:  # nosec B310\n            extension_id = response.headers.get(\"Lambda-Extension-Identifier\")\n            if not extension_id:\n                raise RuntimeError(\"Lambda runtime did not return an Extension ID\")\n            self.extension_id = extension_id\n            logger.info(f\"Extension registered with ID: {self.extension_id}\")\n            return self.extension_id\n    except Exception as e:\n        raise RuntimeError(f\"Failed to register extension: {e}\") from e\n</code></pre>"},{"location":"restmachine-aws/api/extension/#restmachine_aws.extension.ShutdownExtension.wait_for_event","title":"wait_for_event","text":"<pre><code>wait_for_event() -&gt; dict\n</code></pre> <p>Wait for the next lifecycle event from Lambda.</p> <p>This is a blocking call that waits for the Lambda runtime to send the next event. For SHUTDOWN-only extensions, this will block until the container is terminating.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Event dictionary containing eventType and other event details</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If event retrieval fails or extension is not registered</p> Source code in <code>packages/restmachine-aws/src/restmachine_aws/extension.py</code> <pre><code>def wait_for_event(self) -&gt; dict:\n    \"\"\"\n    Wait for the next lifecycle event from Lambda.\n\n    This is a blocking call that waits for the Lambda runtime to send the next\n    event. For SHUTDOWN-only extensions, this will block until the container\n    is terminating.\n\n    Returns:\n        Event dictionary containing eventType and other event details\n\n    Raises:\n        RuntimeError: If event retrieval fails or extension is not registered\n    \"\"\"\n    if not self.extension_id:\n        raise RuntimeError(\"Extension must be registered before waiting for events\")\n\n    url = f\"http://{self.runtime_api}/2020-01-01/extension/event/next\"\n\n    req = request.Request(\n        url,\n        headers={\"Lambda-Extension-Identifier\": self.extension_id},\n        method=\"GET\",\n    )\n\n    try:\n        # nosec B310: Lambda Extensions API is only accessible over localhost HTTP\n        with request.urlopen(req) as response:  # nosec B310\n            event = cast(dict[Any, Any], json.loads(response.read()))\n            return event\n    except Exception as e:\n        raise RuntimeError(f\"Failed to get next event: {e}\") from e\n</code></pre>"},{"location":"restmachine-aws/api/extension/#restmachine_aws.extension.ShutdownExtension.load_app","title":"load_app","text":"<pre><code>load_app() -&gt; Any\n</code></pre> <p>Load the RestMachine application from the handler module.</p> <p>Imports the handler module and retrieves the RestApplication instance. The Lambda task root is added to sys.path to ensure imports work correctly.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The RestMachine application instance</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the handler module or app variable cannot be found</p> Source code in <code>packages/restmachine-aws/src/restmachine_aws/extension.py</code> <pre><code>def load_app(self) -&gt; Any:\n    \"\"\"\n    Load the RestMachine application from the handler module.\n\n    Imports the handler module and retrieves the RestApplication instance.\n    The Lambda task root is added to sys.path to ensure imports work correctly.\n\n    Returns:\n        The RestMachine application instance\n\n    Raises:\n        ImportError: If the handler module or app variable cannot be found\n    \"\"\"\n    # Add Lambda task root to Python path\n    task_root = os.environ.get(\"LAMBDA_TASK_ROOT\", \".\")\n    if task_root not in sys.path:\n        sys.path.insert(0, task_root)\n\n    try:\n        # Import the handler module\n        handler_module = __import__(self.handler_module)\n        logger.info(f\"Imported module: {self.handler_module}\")\n\n        # Get the app instance\n        if not hasattr(handler_module, self.app_name):\n            raise AttributeError(\n                f\"Module '{self.handler_module}' has no attribute '{self.app_name}'. \"\n                f\"Available attributes: {dir(handler_module)}\"\n            )\n\n        app = getattr(handler_module, self.app_name)\n        logger.info(f\"Loaded app from {self.handler_module}.{self.app_name}\")\n        return app\n\n    except ImportError as e:\n        raise ImportError(\n            f\"Could not import handler module '{self.handler_module}': {e}\"\n        ) from e\n</code></pre>"},{"location":"restmachine-aws/api/extension/#restmachine_aws.extension.ShutdownExtension.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Main extension loop.</p> <p>Performs the following steps: 1. Register with Lambda Extensions API 2. Load the RestMachine application 3. Wait for lifecycle events 4. On SHUTDOWN event, call app.shutdown_sync()</p> <p>This method blocks until a SHUTDOWN event is received or an error occurs.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If any step in the extension lifecycle fails</p> Source code in <code>packages/restmachine-aws/src/restmachine_aws/extension.py</code> <pre><code>def run(self):\n    \"\"\"\n    Main extension loop.\n\n    Performs the following steps:\n    1. Register with Lambda Extensions API\n    2. Load the RestMachine application\n    3. Wait for lifecycle events\n    4. On SHUTDOWN event, call app.shutdown_sync()\n\n    This method blocks until a SHUTDOWN event is received or an error occurs.\n\n    Raises:\n        Exception: If any step in the extension lifecycle fails\n    \"\"\"\n    try:\n        # Step 1: Register extension\n        logger.info(\"Registering extension...\")\n        self.register()\n\n        # Step 2: Load application\n        logger.info(\"Loading application...\")\n        app = self.load_app()\n\n        # Verify app has shutdown_sync method\n        if not hasattr(app, \"shutdown_sync\"):\n            logger.warning(\n                f\"Application {self.app_name} does not have shutdown_sync() method. \"\n                \"No shutdown handlers will be called.\"\n            )\n            # Still wait for SHUTDOWN to prevent extension from exiting early\n            app = None\n\n        # Step 3: Wait for events\n        logger.info(\"Extension ready, waiting for events...\")\n        while True:\n            event = self.wait_for_event()\n            event_type = event.get(\"eventType\")\n\n            logger.info(f\"Received event: {event_type}\")\n\n            if event_type == \"SHUTDOWN\":\n                # Step 4: Execute shutdown handlers\n                if app and hasattr(app, \"shutdown_sync\"):\n                    logger.info(\"Executing shutdown handlers...\")\n                    try:\n                        app.shutdown_sync()\n                        logger.info(\"Shutdown handlers completed successfully\")\n                    except Exception as e:\n                        logger.error(f\"Error in shutdown handlers: {e}\", exc_info=True)\n                else:\n                    logger.info(\"No shutdown handlers to execute\")\n\n                # Exit after shutdown\n                logger.info(\"Extension shutting down\")\n                break\n\n    except Exception as e:\n        logger.error(f\"Extension error: {e}\", exc_info=True)\n        raise\n</code></pre>"},{"location":"restmachine-aws/api/extension/#overview","title":"Overview","text":"<p>The Lambda Extension enables shutdown handlers to run when your Lambda container terminates. This is essential for cleaning up resources like database connections, file handles, and pending operations.</p>"},{"location":"restmachine-aws/api/extension/#why-use-an-extension","title":"Why Use an Extension?","text":"<p>Lambda functions don't have a traditional shutdown phase - they're frozen after execution. The extension solves this by:</p> <ol> <li>Running as a separate process alongside your Lambda function</li> <li>Listening for SHUTDOWN signals from AWS</li> <li>Calling your <code>@app.on_shutdown</code> handlers before termination</li> </ol>"},{"location":"restmachine-aws/api/extension/#installation","title":"Installation","text":""},{"location":"restmachine-aws/api/extension/#1-create-extension-script","title":"1. Create Extension Script","text":"<p>Create <code>extensions/restmachine-shutdown</code> in your Lambda deployment package:</p> <pre><code>#!/usr/bin/env python3\nfrom restmachine_aws.extension import main\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"restmachine-aws/api/extension/#2-make-it-executable","title":"2. Make It Executable","text":"<pre><code>chmod +x extensions/restmachine-shutdown\n</code></pre>"},{"location":"restmachine-aws/api/extension/#3-deploy-with-lambda","title":"3. Deploy with Lambda","text":"<p>The extension is automatically discovered when included in your deployment package:</p> <pre><code>lambda_function/\n\u251c\u2500\u2500 lambda_function.py      # Your Lambda handler\n\u251c\u2500\u2500 extensions/\n\u2502   \u2514\u2500\u2500 restmachine-shutdown  # Extension (executable)\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"restmachine-aws/api/extension/#using-shutdown-handlers","title":"Using Shutdown Handlers","text":"<p>Define shutdown handlers in your application:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\n\napp = RestApplication()\n\n@app.on_startup\ndef database():\n    \"\"\"Open database connection on cold start.\"\"\"\n    print(\"Opening database connection...\")\n    return create_db_connection()\n\n@app.on_shutdown\ndef close_database(database):\n    \"\"\"Close database connection on shutdown.\"\"\"\n    print(\"Closing database connection...\")\n    database.close()\n    print(\"Database closed successfully\")\n\n# AWS Lambda adapter\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre> <p>When AWS terminates the Lambda container, the extension calls <code>close_database()</code> automatically.</p>"},{"location":"restmachine-aws/api/extension/#how-it-works","title":"How It Works","text":"sequenceDiagram     participant AWS as AWS Lambda     participant Ext as Extension     participant Handler as Lambda Handler     participant App as RestMachine      AWS-&gt;&gt;Ext: INIT     Ext-&gt;&gt;Ext: Register for SHUTDOWN     AWS-&gt;&gt;Handler: Cold Start     Handler-&gt;&gt;App: Run @app.on_startup      loop Requests         AWS-&gt;&gt;Handler: Invoke         Handler-&gt;&gt;App: Process request         App--&gt;&gt;Handler: Response         Handler--&gt;&gt;AWS: Return     end      AWS-&gt;&gt;Ext: SHUTDOWN signal     Ext-&gt;&gt;Handler: Call shutdown     Handler-&gt;&gt;App: Run @app.on_shutdown     App--&gt;&gt;Ext: Complete     Ext--&gt;&gt;AWS: Extension stopped"},{"location":"restmachine-aws/api/extension/#lifecycle-phases","title":"Lifecycle Phases","text":""},{"location":"restmachine-aws/api/extension/#1-initialization","title":"1. Initialization","text":"<p>When Lambda starts:</p> <pre><code># Extension registers with Lambda Runtime API\n# Declares interest in SHUTDOWN events\n</code></pre>"},{"location":"restmachine-aws/api/extension/#2-request-processing","title":"2. Request Processing","text":"<p>Your Lambda function handles requests normally. Shutdown handlers are not called between invocations.</p>"},{"location":"restmachine-aws/api/extension/#3-shutdown","title":"3. Shutdown","text":"<p>When AWS terminates the container:</p> <pre><code># Extension receives SHUTDOWN event\n# Extension imports your app and calls app.shutdown_sync()\n# Your @app.on_shutdown handlers execute\n# Extension reports completion to AWS\n</code></pre>"},{"location":"restmachine-aws/api/extension/#configuration","title":"Configuration","text":""},{"location":"restmachine-aws/api/extension/#environment-variables","title":"Environment Variables","text":"<p>Configure extension behavior:</p> <pre><code># SAM template.yaml\nEnvironment:\n  Variables:\n    RESTMACHINE_HANDLER_MODULE: \"lambda_function\"  # Module with your app\n    RESTMACHINE_APP_NAME: \"app\"                    # Variable name\n</code></pre> <p>Defaults: - <code>RESTMACHINE_HANDLER_MODULE</code>: <code>\"lambda_function\"</code> - <code>RESTMACHINE_APP_NAME</code>: <code>\"app\"</code></p>"},{"location":"restmachine-aws/api/extension/#custom-app-location","title":"Custom App Location","text":"<p>If your app is in a different module:</p> <pre><code># my_api/application.py\nfrom restmachine import RestApplication\n\nmy_app = RestApplication()\n\n@my_app.get(\"/hello\")\ndef hello():\n    return {\"message\": \"Hello\"}\n</code></pre> <p>Set environment variables:</p> <pre><code>Environment:\n  Variables:\n    RESTMACHINE_HANDLER_MODULE: \"my_api.application\"\n    RESTMACHINE_APP_NAME: \"my_app\"\n</code></pre>"},{"location":"restmachine-aws/api/extension/#resource-injection","title":"Resource Injection","text":"<p>Shutdown handlers support dependency injection:</p> <pre><code>@app.on_startup\ndef database():\n    return create_db_connection()\n\n@app.on_startup\ndef cache():\n    return redis.Redis()\n\n@app.on_shutdown\ndef cleanup(database, cache):\n    \"\"\"Both dependencies are injected automatically.\"\"\"\n    database.close()\n    cache.close()\n</code></pre>"},{"location":"restmachine-aws/api/extension/#example-database-connection-pool","title":"Example: Database Connection Pool","text":"<pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\nimport psycopg2.pool\n\napp = RestApplication()\n\n@app.on_startup\ndef db_pool():\n    \"\"\"Create connection pool on cold start.\"\"\"\n    print(\"Creating database pool...\")\n    return psycopg2.pool.SimpleConnectionPool(\n        minconn=1,\n        maxconn=10,\n        host=\"db.example.com\",\n        database=\"myapp\",\n        user=\"user\",\n        password=\"password\"\n    )\n\n@app.get('/users/{user_id}')\ndef get_user(db_pool, request):\n    \"\"\"Use connection from pool.\"\"\"\n    conn = db_pool.getconn()\n    try:\n        with conn.cursor() as cur:\n            cur.execute(\"SELECT * FROM users WHERE id = %s\",\n                       (request.path_params['user_id'],))\n            user = cur.fetchone()\n            return {\"user\": user}\n    finally:\n        db_pool.putconn(conn)\n\n@app.on_shutdown\ndef close_pool(db_pool):\n    \"\"\"Close all connections on shutdown.\"\"\"\n    print(\"Closing database pool...\")\n    db_pool.closeall()\n    print(\"All connections closed\")\n\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"restmachine-aws/api/extension/#monitoring","title":"Monitoring","text":""},{"location":"restmachine-aws/api/extension/#cloudwatch-logs","title":"CloudWatch Logs","text":"<p>Shutdown handlers write to CloudWatch:</p> <pre><code>[Extension] Shutdown signal received\n[Function] Closing database pool...\n[Function] All connections closed\n[Extension] Shutdown handlers completed successfully\n</code></pre>"},{"location":"restmachine-aws/api/extension/#testing-locally","title":"Testing Locally","text":"<p>Test shutdown without deploying:</p> <pre><code>from restmachine_aws import AwsApiGatewayAdapter\n\napp = RestApplication()\n\n# ... define handlers ...\n\nadapter = AwsApiGatewayAdapter(app)\n\n# Manually trigger shutdown for testing\nif hasattr(app, 'shutdown_sync'):\n    app.shutdown_sync()\n</code></pre>"},{"location":"restmachine-aws/api/extension/#limitations","title":"Limitations","text":"<ul> <li>5-Second Timeout: Extensions have limited time during shutdown</li> <li>No Guarantees: AWS may forcibly terminate if timeout exceeded</li> <li>Cold Start Only: Shutdown doesn't run between warm invocations</li> <li>No Return Values: Shutdown handlers shouldn't return data</li> </ul>"},{"location":"restmachine-aws/api/extension/#best-practices","title":"Best Practices","text":"<ol> <li>Keep Shutdown Fast - Close connections quickly, avoid complex cleanup</li> <li>Log Everything - Use logging to track shutdown execution</li> <li>Handle Failures - Use try/except to ensure shutdown completes</li> <li>Test Thoroughly - Test shutdown logic locally before deploying</li> </ol>"},{"location":"restmachine-aws/api/extension/#troubleshooting","title":"Troubleshooting","text":""},{"location":"restmachine-aws/api/extension/#shutdown-handlers-not-running","title":"Shutdown Handlers Not Running","text":"<ul> <li>Verify extension is included in deployment package</li> <li>Check <code>extensions/</code> directory exists in Lambda</li> <li>Review CloudWatch logs for extension errors</li> </ul>"},{"location":"restmachine-aws/api/extension/#timeout-errors","title":"Timeout Errors","text":"<ul> <li>Reduce cleanup operations</li> <li>Remove blocking I/O from shutdown handlers</li> </ul>"},{"location":"restmachine-aws/api/extension/#extension-causing-cold-start-delay","title":"Extension Causing Cold Start Delay","text":"<ul> <li>Extension adds ~50-100ms to cold start</li> <li>This is normal and acceptable for most use cases</li> </ul>"},{"location":"restmachine-aws/api/extension/#cli-tool","title":"CLI Tool","text":"<p>Generate extension script automatically:</p> <pre><code>python -m restmachine_aws create-extension\n</code></pre> <p>This creates <code>extensions/restmachine-shutdown</code> with proper permissions.</p>"},{"location":"restmachine-aws/api/extension/#see-also","title":"See Also","text":"<ul> <li>Lambda Deployment Guide - Complete deployment guide</li> <li>Lambda Extensions Guide - Detailed usage guide</li> <li>Lifecycle Handlers - General lifecycle patterns</li> </ul>"},{"location":"restmachine-aws/guides/lambda-deployment/","title":"Deploying to AWS Lambda","text":"<p>Deploy RestMachine applications to AWS Lambda for serverless, scalable REST APIs. RestMachine provides seamless integration with API Gateway, Application Load Balancer (ALB), and Lambda Function URLs.</p>"},{"location":"restmachine-aws/guides/lambda-deployment/#installation","title":"Installation","text":"<p>Install RestMachine with AWS support:</p> <pre><code>pip install 'restmachine[aws]'\n</code></pre> <p>Or install separately:</p> <pre><code>pip install restmachine restmachine-aws\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#quick-start","title":"Quick Start","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#basic-lambda-handler","title":"Basic Lambda Handler","text":"<p>Create a Lambda handler in <code>lambda_function.py</code>:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\n\n# Create application\napp = RestApplication()\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"Hello from Lambda!\"}\n\n@app.get(\"/users/{user_id}\")\ndef get_user(path_params):\n    user_id = path_params['user_id']\n    return {\"id\": user_id, \"name\": f\"User {user_id}\"}\n\n# Create Lambda handler\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    \"\"\"AWS Lambda handler function.\"\"\"\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#deploy-with-aws-sam","title":"Deploy with AWS SAM","text":"<p>template.yaml:</p> <pre><code>AWSTemplateFormatVersion: '2010-09-09'\nTransform: AWS::Serverless-2016-10-31\n\nResources:\n  RestMachineApi:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      Handler: lambda_function.lambda_handler\n      Runtime: python3.11\n      Timeout: 30\n      MemorySize: 512\n      Events:\n        ApiEvent:\n          Type: HttpApi\n          Properties:\n            Path: /{proxy+}\n            Method: ANY\n</code></pre> <p>requirements.txt:</p> <pre><code>restmachine[aws]\n</code></pre> <p>Deploy:</p> <pre><code>sam build\nsam deploy --guided\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#api-gateway-integration","title":"API Gateway Integration","text":"<p>RestMachine supports all API Gateway event formats automatically.</p>"},{"location":"restmachine-aws/guides/lambda-deployment/#http-api-v2-recommended","title":"HTTP API (v2) - Recommended","text":"<p>Modern, cost-effective API Gateway with payload format 2.0:</p> <pre><code># SAM template\nEvents:\n  HttpApi:\n    Type: HttpApi  # HTTP API (v2)\n    Properties:\n      Path: /{proxy+}\n      Method: ANY\n</code></pre> <p>Event structure:</p> <pre><code>{\n    \"version\": \"2.0\",\n    \"routeKey\": \"GET /users/{user_id}\",\n    \"rawPath\": \"/users/123\",\n    \"headers\": {\"accept\": \"application/json\"},\n    \"pathParameters\": {\"user_id\": \"123\"},\n    \"requestContext\": {\n        \"http\": {\n            \"method\": \"GET\",\n            \"path\": \"/users/123\"\n        }\n    }\n}\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#rest-api-v1","title":"REST API (v1)","text":"<p>Traditional API Gateway with payload format 1.0:</p> <pre><code># SAM template\nEvents:\n  RestApi:\n    Type: Api  # REST API (v1)\n    Properties:\n      Path: /{proxy+}\n      Method: ANY\n</code></pre> <p>Event structure:</p> <pre><code>{\n    \"httpMethod\": \"GET\",\n    \"path\": \"/users/123\",\n    \"headers\": {\"Accept\": \"application/json\"},\n    \"pathParameters\": {\"user_id\": \"123\"},\n    \"requestContext\": {\n        \"requestId\": \"...\"\n    }\n}\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#lambda-function-urls","title":"Lambda Function URLs","text":"<p>Direct HTTPS endpoint for your Lambda function:</p> <pre><code># SAM template\nFunctionUrlConfig:\n  AuthType: NONE  # or AWS_IAM\n</code></pre> <p>Function URL uses HTTP API (v2) format automatically.</p>"},{"location":"restmachine-aws/guides/lambda-deployment/#application-load-balancer-alb","title":"Application Load Balancer (ALB)","text":"<p>Integrate with Application Load Balancer:</p> <pre><code># SAM template (manually configure ALB target group)\n</code></pre> <p>ALB events are detected automatically:</p> <pre><code>{\n    \"requestContext\": {\n        \"elb\": {  # ALB indicator\n            \"targetGroupArn\": \"...\"\n        }\n    },\n    \"httpMethod\": \"GET\",\n    \"path\": \"/users/123\",\n    # ...\n}\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#deployment-methods","title":"Deployment Methods","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#aws-sam-serverless-application-model","title":"AWS SAM (Serverless Application Model)","text":"<p>Full example with dependencies:</p> <pre><code># template.yaml\nAWSTemplateFormatVersion: '2010-09-09'\nTransform: AWS::Serverless-2016-10-31\n\nGlobals:\n  Function:\n    Timeout: 30\n    MemorySize: 512\n    Runtime: python3.11\n    Environment:\n      Variables:\n        LOG_LEVEL: INFO\n\nResources:\n  MyApi:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      Handler: lambda_function.lambda_handler\n      Layers:\n        - !Ref DependenciesLayer\n      Events:\n        HttpApi:\n          Type: HttpApi\n          Properties:\n            Path: /{proxy+}\n            Method: ANY\n\n  DependenciesLayer:\n    Type: AWS::Serverless::LayerVersion\n    Properties:\n      LayerName: restmachine-dependencies\n      ContentUri: dependencies/\n      CompatibleRuntimes:\n        - python3.11\n    Metadata:\n      BuildMethod: python3.11\n</code></pre> <p>Build and deploy:</p> <pre><code># Build\nsam build\n\n# Deploy\nsam deploy --guided\n\n# Test locally\nsam local start-api\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#serverless-framework","title":"Serverless Framework","text":"<p>serverless.yml:</p> <pre><code>service: restmachine-api\n\nprovider:\n  name: aws\n  runtime: python3.11\n  stage: ${opt:stage, 'dev'}\n  region: us-east-1\n\nfunctions:\n  api:\n    handler: lambda_function.lambda_handler\n    events:\n      - httpApi:\n          path: /{proxy+}\n          method: ANY\n    environment:\n      LOG_LEVEL: INFO\n\nplugins:\n  - serverless-python-requirements\n\ncustom:\n  pythonRequirements:\n    dockerizePip: true\n</code></pre> <p>Deploy:</p> <pre><code>serverless deploy --stage prod\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#aws-cdk-python","title":"AWS CDK (Python)","text":"<pre><code>from aws_cdk import (\n    Stack,\n    aws_lambda as lambda_,\n    aws_apigatewayv2 as apigw,\n)\nfrom constructs import Construct\n\nclass RestMachineStack(Stack):\n    def __init__(self, scope: Construct, id: str, **kwargs):\n        super().__init__(scope, id, **kwargs)\n\n        # Lambda function\n        handler = lambda_.Function(\n            self, \"RestMachineFunction\",\n            runtime=lambda_.Runtime.PYTHON_3_11,\n            code=lambda_.Code.from_asset(\"lambda\"),\n            handler=\"lambda_function.lambda_handler\",\n            timeout=Duration.seconds(30),\n            memory_size=512,\n        )\n\n        # HTTP API\n        api = apigw.HttpApi(\n            self, \"RestMachineApi\",\n            default_integration=apigw_integrations.HttpLambdaIntegration(\n                \"Integration\",\n                handler\n            )\n        )\n</code></pre> <p>Deploy:</p> <pre><code>cdk deploy\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#manual-deployment-zip","title":"Manual Deployment (ZIP)","text":"<p>Create deployment package:</p> <pre><code># Install dependencies\npip install -r requirements.txt -t package/\n\n# Copy application code\ncp lambda_function.py package/\n\n# Create ZIP\ncd package &amp;&amp; zip -r ../lambda.zip . &amp;&amp; cd ..\n\n# Deploy\naws lambda create-function \\\n  --function-name restmachine-api \\\n  --runtime python3.11 \\\n  --role arn:aws:iam::ACCOUNT:role/lambda-role \\\n  --handler lambda_function.lambda_handler \\\n  --zip-file fileb://lambda.zip \\\n  --timeout 30 \\\n  --memory-size 512\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#startup-handlers","title":"Startup Handlers","text":"<p>Startup handlers run once per Lambda cold start:</p> <pre><code>app = RestApplication()\n\n@app.on_startup\ndef database():\n    \"\"\"Initialize database connection (runs once per cold start).\"\"\"\n    import boto3\n    dynamodb = boto3.resource('dynamodb')\n    table = dynamodb.Table('users')\n    return table\n\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: str, database):\n    \"\"\"Use database connection from startup handler.\"\"\"\n    response = database.get_item(Key={'id': user_id})\n    return response.get('Item', {})\n</code></pre> <p>Cold starts: Startup handlers run once when Lambda initializes a new container.</p> <p>Warm invocations: Subsequent requests reuse the same startup handler results.</p>"},{"location":"restmachine-aws/guides/lambda-deployment/#shutdown-handlers","title":"Shutdown Handlers","text":"<p>Shutdown handlers clean up resources when the Lambda container terminates.</p>"},{"location":"restmachine-aws/guides/lambda-deployment/#option-1-lambda-extension-recommended","title":"Option 1: Lambda Extension (Recommended)","text":"<p>Use the RestMachine Lambda Extension for automatic shutdown:</p> <p>extensions/restmachine-shutdown:</p> <pre><code>#!/usr/bin/env python3\nfrom restmachine_aws.extension import main\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Make it executable:</p> <pre><code>chmod +x extensions/restmachine-shutdown\n</code></pre> <p>SAM template:</p> <pre><code>MyApi:\n  Type: AWS::Serverless::Function\n  Properties:\n    CodeUri: .\n    Handler: lambda_function.lambda_handler\n    # Extension is automatically included from extensions/\n</code></pre> <p>The extension monitors Lambda lifecycle and calls shutdown handlers on container termination.</p>"},{"location":"restmachine-aws/guides/lambda-deployment/#option-2-manual-shutdown","title":"Option 2: Manual Shutdown","text":"<p>For simple cleanup, use context:</p> <pre><code>@app.on_shutdown\ndef close_connections(database):\n    \"\"\"Called when Lambda container terminates.\"\"\"\n    database.close()\n\n# The AwsApiGatewayAdapter automatically runs startup handlers\n# Extensions handle shutdown automatically\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#database-integration","title":"Database Integration","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#dynamodb","title":"DynamoDB","text":"<pre><code>import boto3\n\napp = RestApplication()\n\n@app.on_startup\ndef dynamodb():\n    \"\"\"Initialize DynamoDB client.\"\"\"\n    return boto3.resource('dynamodb').Table('MyTable')\n\n@app.get(\"/items/{item_id}\")\ndef get_item(item_id: str, dynamodb):\n    response = dynamodb.get_item(Key={'id': item_id})\n    return response.get('Item', {})\n\n@app.post(\"/items\")\ndef create_item(json_body: dict, dynamodb):\n    dynamodb.put_item(Item=json_body)\n    return json_body, 201\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#rds-with-secret-manager","title":"RDS with Secret Manager","text":"<pre><code>import boto3\nimport json\nimport psycopg2\n\n@app.on_startup\ndef database():\n    \"\"\"Get RDS credentials and connect.\"\"\"\n    # Get secret\n    secrets = boto3.client('secretsmanager')\n    secret = secrets.get_secret_value(SecretId='rds-credentials')\n    creds = json.loads(secret['SecretString'])\n\n    # Connect to RDS\n    conn = psycopg2.connect(\n        host=creds['host'],\n        database=creds['database'],\n        user=creds['username'],\n        password=creds['password']\n    )\n    return conn\n\n@app.on_shutdown\ndef close_database(database):\n    \"\"\"Close connection on shutdown.\"\"\"\n    database.close()\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#environment-configuration","title":"Environment Configuration","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#using-environment-variables","title":"Using Environment Variables","text":"<pre><code>import os\n\napp = RestApplication()\n\n# Get config from environment\nTABLE_NAME = os.getenv('TABLE_NAME', 'default-table')\nLOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')\n\n@app.on_startup\ndef dynamodb():\n    import boto3\n    return boto3.resource('dynamodb').Table(TABLE_NAME)\n</code></pre> <p>SAM template:</p> <pre><code>Environment:\n  Variables:\n    TABLE_NAME: !Ref MyDynamoDBTable\n    LOG_LEVEL: INFO\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#using-aws-systems-manager-parameter-store","title":"Using AWS Systems Manager Parameter Store","text":"<pre><code>import boto3\n\n@app.on_startup\ndef config():\n    \"\"\"Load configuration from Parameter Store.\"\"\"\n    ssm = boto3.client('ssm')\n    params = ssm.get_parameters_by_path(\n        Path='/myapp/',\n        Recursive=True,\n        WithDecryption=True\n    )\n    return {p['Name']: p['Value'] for p in params['Parameters']}\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#local-testing","title":"Local Testing","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#sam-local","title":"SAM Local","text":"<p>Test locally with SAM CLI:</p> <pre><code># Start local API\nsam local start-api\n\n# Test specific endpoint\ncurl http://localhost:3000/users/123\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#direct-invocation","title":"Direct Invocation","text":"<p>Test the handler directly:</p> <pre><code># test_lambda.py\nfrom lambda_function import lambda_handler\n\ndef test_get_user():\n    event = {\n        \"version\": \"2.0\",\n        \"routeKey\": \"GET /users/{user_id}\",\n        \"rawPath\": \"/users/123\",\n        \"headers\": {\"accept\": \"application/json\"},\n        \"pathParameters\": {\"user_id\": \"123\"},\n        \"requestContext\": {\n            \"http\": {\"method\": \"GET\", \"path\": \"/users/123\"}\n        }\n    }\n\n    response = lambda_handler(event, None)\n\n    assert response['statusCode'] == 200\n    import json\n    body = json.loads(response['body'])\n    assert body['id'] == '123'\n</code></pre> <p>Run tests:</p> <pre><code>pytest test_lambda.py\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#complete-production-example","title":"Complete Production Example","text":"<pre><code># lambda_function.py\nimport os\nimport logging\nimport boto3\nfrom restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\n\n# Configure logging\nlogger = logging.getLogger()\nlogger.setLevel(os.getenv('LOG_LEVEL', 'INFO'))\n\n# Create application\napp = RestApplication()\n\n@app.on_startup\ndef dynamodb():\n    \"\"\"Initialize DynamoDB client (runs once per cold start).\"\"\"\n    table_name = os.getenv('TABLE_NAME', 'users')\n    logger.info(f\"Connecting to DynamoDB table: {table_name}\")\n    return boto3.resource('dynamodb').Table(table_name)\n\n@app.on_shutdown\ndef cleanup(dynamodb):\n    \"\"\"Cleanup on Lambda container termination.\"\"\"\n    logger.info(\"Shutting down Lambda container\")\n    # DynamoDB client doesn't need explicit cleanup\n    # but you can close other connections here\n\n@app.get(\"/health\")\ndef health():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"healthy\"}\n\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: str, dynamodb):\n    \"\"\"Get user from DynamoDB.\"\"\"\n    try:\n        response = dynamodb.get_item(Key={'id': user_id})\n        item = response.get('Item')\n        if not item:\n            return {\"error\": \"User not found\"}, 404\n        return item\n    except Exception as e:\n        logger.error(f\"Error getting user: {e}\")\n        return {\"error\": \"Internal server error\"}, 500\n\n@app.post(\"/users\")\ndef create_user(json_body: dict, dynamodb):\n    \"\"\"Create user in DynamoDB.\"\"\"\n    try:\n        # Validate required fields\n        if 'id' not in json_body or 'name' not in json_body:\n            return {\"error\": \"Missing required fields\"}, 400\n\n        dynamodb.put_item(Item=json_body)\n        return json_body, 201\n    except Exception as e:\n        logger.error(f\"Error creating user: {e}\")\n        return {\"error\": \"Internal server error\"}, 500\n\n@app.put(\"/users/{user_id}\")\ndef update_user(user_id: str, json_body: dict, dynamodb):\n    \"\"\"Update user in DynamoDB.\"\"\"\n    try:\n        # Check if user exists\n        response = dynamodb.get_item(Key={'id': user_id})\n        if 'Item' not in response:\n            return {\"error\": \"User not found\"}, 404\n\n        # Update user\n        json_body['id'] = user_id\n        dynamodb.put_item(Item=json_body)\n        return json_body\n    except Exception as e:\n        logger.error(f\"Error updating user: {e}\")\n        return {\"error\": \"Internal server error\"}, 500\n\n@app.delete(\"/users/{user_id}\")\ndef delete_user(user_id: str, dynamodb):\n    \"\"\"Delete user from DynamoDB.\"\"\"\n    try:\n        dynamodb.delete_item(Key={'id': user_id})\n        return \"\", 204\n    except Exception as e:\n        logger.error(f\"Error deleting user: {e}\")\n        return {\"error\": \"Internal server error\"}, 500\n\n# Create adapter and handler\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    \"\"\"AWS Lambda handler function.\"\"\"\n    return adapter.handle_event(event, context)\n</code></pre> <p>SAM template for production:</p> <pre><code>AWSTemplateFormatVersion: '2010-09-09'\nTransform: AWS::Serverless-2016-10-31\n\nParameters:\n  Environment:\n    Type: String\n    Default: dev\n    AllowedValues: [dev, staging, prod]\n\nGlobals:\n  Function:\n    Timeout: 30\n    MemorySize: 512\n    Runtime: python3.11\n    Environment:\n      Variables:\n        LOG_LEVEL: !If [IsProd, WARNING, INFO]\n\nConditions:\n  IsProd: !Equals [!Ref Environment, prod]\n\nResources:\n  UsersTable:\n    Type: AWS::DynamoDB::Table\n    Properties:\n      TableName: !Sub users-${Environment}\n      BillingMode: PAY_PER_REQUEST\n      AttributeDefinitions:\n        - AttributeName: id\n          AttributeType: S\n      KeySchema:\n        - AttributeName: id\n          KeyType: HASH\n\n  ApiFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: .\n      Handler: lambda_function.lambda_handler\n      Environment:\n        Variables:\n          TABLE_NAME: !Ref UsersTable\n      Policies:\n        - DynamoDBCrudPolicy:\n            TableName: !Ref UsersTable\n      Events:\n        HttpApi:\n          Type: HttpApi\n          Properties:\n            Path: /{proxy+}\n            Method: ANY\n\nOutputs:\n  ApiUrl:\n    Description: API Gateway endpoint URL\n    Value: !Sub 'https://${ServerlessHttpApi}.execute-api.${AWS::Region}.amazonaws.com'\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#performance-optimization","title":"Performance Optimization","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#lambda-configuration","title":"Lambda Configuration","text":"<p>Memory: More memory = more CPU:</p> <pre><code>MemorySize: 1024  # MB (128-10240)\nTimeout: 30       # seconds (1-900)\n</code></pre> <p>Provisioned Concurrency for consistent performance:</p> <pre><code>ProvisionedConcurrencyConfig:\n  ProvisionedConcurrentExecutions: 5\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#cold-start-optimization","title":"Cold Start Optimization","text":"<ol> <li>Use startup handlers to initialize connections once</li> <li>Package only what you need - smaller packages load faster</li> <li>Use Lambda Layers for dependencies</li> <li>Keep functions warm with scheduled pings (dev only)</li> </ol>"},{"location":"restmachine-aws/guides/lambda-deployment/#reuse-connections","title":"Reuse Connections","text":"<pre><code># Good - reuse connection across invocations\n@app.on_startup\ndef database():\n    return boto3.resource('dynamodb')\n\n# Bad - creates new connection each request\n@app.get(\"/users\")\ndef get_users():\n    db = boto3.resource('dynamodb')  # Don't do this!\n    # ...\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#best-practices","title":"Best Practices","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#1-use-environment-variables","title":"1. Use Environment Variables","text":"<pre><code>TABLE_NAME = os.getenv('TABLE_NAME')\nLOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#2-implement-health-checks","title":"2. Implement Health Checks","text":"<pre><code>@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\", \"version\": \"1.0.0\"}\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#3-log-structured-data","title":"3. Log Structured Data","text":"<pre><code>import json\nlogger.info(json.dumps({\n    \"event\": \"user_created\",\n    \"user_id\": user_id,\n    \"timestamp\": datetime.now().isoformat()\n}))\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<pre><code>@app.get(\"/users/{user_id}\")\ndef get_user(user_id: str, dynamodb):\n    try:\n        response = dynamodb.get_item(Key={'id': user_id})\n        return response.get('Item', {})\n    except Exception as e:\n        logger.error(f\"Error: {e}\", exc_info=True)\n        return {\"error\": \"Internal server error\"}, 500\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#5-use-iam-for-permissions","title":"5. Use IAM for Permissions","text":"<p>Grant least-privilege permissions:</p> <pre><code>Policies:\n  - DynamoDBCrudPolicy:\n      TableName: !Ref MyTable\n  - Statement:\n      - Effect: Allow\n        Action: secretsmanager:GetSecretValue\n        Resource: !Ref MySecret\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#monitoring","title":"Monitoring","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#cloudwatch-logs","title":"CloudWatch Logs","text":"<p>Logs are automatically sent to CloudWatch:</p> <pre><code>import logging\nlogger = logging.getLogger()\nlogger.info(\"Processing request\")\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#cloudwatch-metrics","title":"CloudWatch Metrics","text":"<p>Track Lambda metrics: - Invocations - Duration - Errors - Throttles - Cold starts</p>"},{"location":"restmachine-aws/guides/lambda-deployment/#x-ray-tracing","title":"X-Ray Tracing","text":"<p>Enable tracing in SAM:</p> <pre><code>Tracing: Active\n</code></pre> <p>Add instrumentation:</p> <pre><code>from aws_xray_sdk.core import xray_recorder\nfrom aws_xray_sdk.core import patch_all\n\npatch_all()\n\n@app.get(\"/users/{user_id}\")\n@xray_recorder.capture('get_user')\ndef get_user(user_id: str, dynamodb):\n    # Traced automatically\n    pass\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"restmachine-aws/guides/lambda-deployment/#cold-start-issues","title":"Cold Start Issues","text":"<p>Check initialization time:</p> <pre><code>import time\nstart = time.time()\n\n@app.on_startup\ndef database():\n    # Log initialization time\n    init_time = time.time() - start\n    logger.info(f\"Initialized in {init_time:.2f}s\")\n    return boto3.resource('dynamodb')\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#timeout-errors","title":"Timeout Errors","text":"<p>Increase timeout or optimize code:</p> <pre><code>Timeout: 60  # Increase from 30\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#permission-errors","title":"Permission Errors","text":"<p>Check IAM role has required permissions:</p> <pre><code>aws lambda get-function --function-name my-function\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-deployment/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Uvicorn deployment for local development</li> <li>Explore Hypercorn deployment for HTTP/2 support</li> <li>Read about Lifecycle Handlers for advanced startup/shutdown patterns</li> </ul>"},{"location":"restmachine-aws/guides/lambda-extensions/","title":"Lambda Extensions","text":"<p>AWS Lambda Extensions allow you to run code during Lambda lifecycle events, including shutdown. RestMachine provides a Lambda Extension to support <code>@app.on_shutdown</code> handlers in serverless environments.</p>"},{"location":"restmachine-aws/guides/lambda-extensions/#why-lambda-extensions","title":"Why Lambda Extensions?","text":"<p>Lambda functions don't have a traditional shutdown phase - they're frozen after execution. This makes it difficult to clean up resources like:</p> <ul> <li>Database connections</li> <li>File handles</li> <li>Cache flush</li> <li>Metrics reporting</li> </ul> <p>The RestMachine Lambda Extension solves this by:</p> <ol> <li>Running as a separate process alongside your Lambda function</li> <li>Listening for shutdown signals from AWS</li> <li>Calling your <code>@app.on_shutdown</code> handlers before termination</li> </ol>"},{"location":"restmachine-aws/guides/lambda-extensions/#installation","title":"Installation","text":""},{"location":"restmachine-aws/guides/lambda-extensions/#1-generate-the-extension","title":"1. Generate the Extension","text":"<p>RestMachine includes a CLI tool to generate the extension:</p> <pre><code>python -m restmachine_aws create-extension\n</code></pre> <p>This creates <code>extensions/restmachine-shutdown</code> in your project directory.</p>"},{"location":"restmachine-aws/guides/lambda-extensions/#2-include-in-deployment-package","title":"2. Include in Deployment Package","text":"<p>Add the extension to your Lambda deployment package:</p> <pre><code># Create deployment structure\nmkdir -p extensions\npython -m restmachine_aws create-extension\n\n# Package Lambda function with extension\nzip -r lambda_function.zip lambda_handler.py extensions/\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#3-deploy-to-lambda","title":"3. Deploy to Lambda","text":"<p>The extension is automatically discovered by AWS Lambda:</p> <pre><code>aws lambda update-function-code \\\n  --function-name my-function \\\n  --zip-file fileb://lambda_function.zip\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#using-shutdown-handlers","title":"Using Shutdown Handlers","text":"<p>Define shutdown handlers in your application:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\n\napp = RestApplication()\n\n# Startup handler (runs on cold start)\n@app.on_startup\ndef database():\n    print(\"Opening database connection...\")\n    return create_db_connection()\n\n# Route that uses the database\n@app.get('/users')\ndef list_users(database):\n    return database.query(\"SELECT * FROM users\")\n\n# Shutdown handler (runs when Lambda shuts down)\n@app.on_shutdown\ndef close_database(database):\n    print(\"Closing database connection...\")\n    database.close()\n    print(\"Database closed successfully\")\n\n# AWS Lambda adapter\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#how-it-works","title":"How It Works","text":"sequenceDiagram     participant AWS as AWS Lambda     participant Ext as Extension Process     participant Func as Function Handler     participant App as RestMachine App      AWS-&gt;&gt;Ext: INIT     Ext-&gt;&gt;Ext: Start listening for shutdown     AWS-&gt;&gt;Func: Cold Start     Func-&gt;&gt;App: Run @app.on_startup     App--&gt;&gt;Func: Return dependencies      loop Request Processing         AWS-&gt;&gt;Func: Invoke         Func-&gt;&gt;App: Handle request         App--&gt;&gt;Func: Response         Func--&gt;&gt;AWS: Return     end      AWS-&gt;&gt;Ext: SHUTDOWN signal     Ext-&gt;&gt;Func: Trigger shutdown via API     Func-&gt;&gt;App: Run @app.on_shutdown     App--&gt;&gt;Func: Complete     Func--&gt;&gt;Ext: Shutdown complete     Ext--&gt;&gt;AWS: Extension stopped"},{"location":"restmachine-aws/guides/lambda-extensions/#extension-lifecycle","title":"Extension Lifecycle","text":""},{"location":"restmachine-aws/guides/lambda-extensions/#1-initialization-phase","title":"1. Initialization Phase","text":"<pre><code># Extension registers with Lambda Runtime API\nPOST /runtime/init/error\n# Extension declares shutdown handler\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#2-request-processing","title":"2. Request Processing","text":"<p>Your Lambda function handles requests normally. Shutdown handlers are not called between invocations.</p>"},{"location":"restmachine-aws/guides/lambda-extensions/#3-shutdown-phase","title":"3. Shutdown Phase","text":"<p>When AWS decides to shut down the Lambda environment:</p> <pre><code># Extension receives SHUTDOWN event\n# Extension calls shutdown endpoint: POST http://localhost:PORT/shutdown\n# Your @app.on_shutdown handlers execute\n# Extension reports completion\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#configuration","title":"Configuration","text":""},{"location":"restmachine-aws/guides/lambda-extensions/#environment-variables","title":"Environment Variables","text":"<p>Configure the extension behavior:</p> <pre><code># In your Lambda configuration\nEnvironment:\n  RESTMACHINE_EXTENSION_PORT: \"8080\"  # Port for shutdown API (default: 8080)\n  RESTMACHINE_EXTENSION_TIMEOUT: \"5\"  # Shutdown timeout in seconds (default: 5)\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#dependency-injection","title":"Dependency Injection","text":"<p>Shutdown handlers support dependency injection, allowing you to inject startup dependencies:</p> <pre><code>@app.on_startup\ndef database():\n    return {\"connection\": create_connection()}\n\n@app.on_startup\ndef cache():\n    return {\"client\": redis.Redis()}\n\n@app.on_shutdown\ndef cleanup(database, cache):\n    # Both dependencies injected!\n    database[\"connection\"].close()\n    cache[\"client\"].close()\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#example-database-connection-pool","title":"Example: Database Connection Pool","text":"<p>Complete example with connection pooling:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\nimport psycopg2\nfrom psycopg2 import pool\n\napp = RestApplication()\n\n@app.on_startup\ndef db_pool():\n    \"\"\"Create connection pool on cold start.\"\"\"\n    print(\"Creating database connection pool...\")\n    return psycopg2.pool.SimpleConnectionPool(\n        minconn=1,\n        maxconn=10,\n        host=\"mydb.example.com\",\n        database=\"myapp\",\n        user=\"user\",\n        password=\"password\"\n    )\n\n@app.get('/users/{user_id}')\ndef get_user(db_pool, request):\n    \"\"\"Use connection from pool.\"\"\"\n    conn = db_pool.getconn()\n    try:\n        with conn.cursor() as cur:\n            cur.execute(\"SELECT * FROM users WHERE id = %s\",\n                       (request.path_params['user_id'],))\n            user = cur.fetchone()\n            return {\"user\": user}\n    finally:\n        db_pool.putconn(conn)\n\n@app.on_shutdown\ndef close_db_pool(db_pool):\n    \"\"\"Close all connections on shutdown.\"\"\"\n    print(\"Closing database connection pool...\")\n    db_pool.closeall()\n    print(\"All database connections closed\")\n\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#monitoring-debugging","title":"Monitoring &amp; Debugging","text":""},{"location":"restmachine-aws/guides/lambda-extensions/#cloudwatch-logs","title":"CloudWatch Logs","text":"<p>Shutdown handlers write to CloudWatch Logs:</p> <pre><code>[Extension] Shutdown signal received\n[Function] Closing database connection pool...\n[Function] All database connections closed\n[Extension] Shutdown handlers completed successfully\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#testing-locally","title":"Testing Locally","text":"<p>Test shutdown handlers without deploying:</p> <pre><code># Simulate startup\nfrom restmachine_aws import AwsApiGatewayAdapter\n\napp = RestApplication()\n# ... define handlers ...\n\nadapter = AwsApiGatewayAdapter(app)\n\n# Manually trigger shutdown\nadapter._execute_shutdown_handlers()\n</code></pre>"},{"location":"restmachine-aws/guides/lambda-extensions/#limitations","title":"Limitations","text":"<ol> <li>5-Second Timeout: Extensions have limited time during shutdown</li> <li>No Guarantees: AWS may forcibly terminate if timeout exceeded</li> <li>Cold Start Only: Shutdown doesn't run between warm invocations</li> <li>No Return Values: Shutdown handlers shouldn't return data</li> </ol>"},{"location":"restmachine-aws/guides/lambda-extensions/#best-practices","title":"Best Practices","text":"<ol> <li>Keep Shutdown Fast: Close connections quickly, don't perform complex cleanup</li> <li>Log Everything: Use print/logging to track shutdown execution</li> <li>Handle Failures: Use try/except to ensure shutdown completes even if one handler fails</li> <li>Test Thoroughly: Test shutdown logic locally before deploying</li> </ol>"},{"location":"restmachine-aws/guides/lambda-extensions/#troubleshooting","title":"Troubleshooting","text":"Shutdown handlers not running <ul> <li>Verify extension is included in deployment package</li> <li>Check <code>extensions/</code> directory exists in Lambda</li> <li>Review CloudWatch logs for extension errors</li> </ul> Timeout errors during shutdown <ul> <li>Reduce cleanup operations</li> <li>Increase <code>RESTMACHINE_EXTENSION_TIMEOUT</code></li> <li>Remove blocking I/O from shutdown handlers</li> </ul> Extension causing cold start delay <ul> <li>Extension adds ~50-100ms to cold start</li> <li>This is normal and acceptable for most use cases</li> <li>Consider if you really need shutdown handlers</li> </ul>"},{"location":"restmachine-aws/guides/lambda-extensions/#see-also","title":"See Also","text":"<ul> <li>Startup &amp; Shutdown Handlers - General lifecycle documentation</li> <li>AWS Lambda Deployment - Lambda deployment guide</li> <li>Dependency Injection - DI patterns</li> </ul>"},{"location":"restmachine-aws/guides/metrics/","title":"CloudWatch Metrics (EMF)","text":"<p>RestMachine AWS automatically publishes metrics to CloudWatch using Embedded Metric Format (EMF). This provides zero-latency metric publishing without additional API calls.</p>"},{"location":"restmachine-aws/guides/metrics/#overview","title":"Overview","text":"<p>When using <code>AwsApiGatewayAdapter</code>, metrics are:</p> <ul> <li>Automatically enabled when running in AWS Lambda</li> <li>Published via CloudWatch Logs using EMF format</li> <li>Zero API calls - metrics extracted from log JSON</li> <li>No additional IAM permissions needed (uses existing Lambda log permissions)</li> </ul>"},{"location":"restmachine-aws/guides/metrics/#quick-start","title":"Quick Start","text":""},{"location":"restmachine-aws/guides/metrics/#auto-configuration","title":"Auto-Configuration","text":"<p>The simplest setup - just create the adapter:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\n\napp = RestApplication()\n\n# Metrics automatically configured for CloudWatch EMF\nadapter = AwsApiGatewayAdapter(app)\n\n@app.get(\"/users/{id}\")\ndef get_user(id: str, metrics):\n    metrics.add_metric(\"users.fetched\", 1, unit=\"Count\")\n    return {\"user\": id}\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre> <p>That's it! Metrics will appear in CloudWatch Logs and CloudWatch Metrics.</p>"},{"location":"restmachine-aws/guides/metrics/#how-it-works","title":"How It Works","text":"<ol> <li>Automatic Detection: Adapter detects AWS Lambda environment</li> <li>EMF Configuration: Automatically configures CloudWatch EMF publisher</li> <li>Log Publishing: Metrics logged as JSON to stdout</li> <li>CloudWatch Extraction: CloudWatch Logs extracts metrics from EMF JSON</li> <li>Metrics Available: Metrics appear in CloudWatch Metrics (usually within 1-2 minutes)</li> </ol>"},{"location":"restmachine-aws/guides/metrics/#configuration","title":"Configuration","text":""},{"location":"restmachine-aws/guides/metrics/#custom-namespace","title":"Custom Namespace","text":"<p>Organize metrics in CloudWatch namespaces:</p> <pre><code>adapter = AwsApiGatewayAdapter(\n    app,\n    namespace=\"MyApp/Production\"\n)\n</code></pre> <p>Default: <code>RestMachine</code></p>"},{"location":"restmachine-aws/guides/metrics/#service-name-dimension","title":"Service Name Dimension","text":"<p>Add a service dimension to all metrics:</p> <pre><code>adapter = AwsApiGatewayAdapter(\n    app,\n    namespace=\"MyApp/Production\",\n    service_name=\"user-api\"\n)\n</code></pre> <p>Default: AWS Lambda function name (from <code>AWS_LAMBDA_FUNCTION_NAME</code>)</p>"},{"location":"restmachine-aws/guides/metrics/#high-resolution-metrics","title":"High-Resolution Metrics","text":"<p>Enable 1-second granularity (default is 60 seconds):</p> <pre><code>adapter = AwsApiGatewayAdapter(\n    app,\n    metrics_resolution=1  # 1-second resolution\n)\n</code></pre> <p>\u26a0\ufe0f High-resolution metrics cost more in CloudWatch.</p>"},{"location":"restmachine-aws/guides/metrics/#environment-variables","title":"Environment Variables","text":"<p>Configure via environment variables (useful for different environments):</p> Variable Description Default <code>RESTMACHINE_METRICS_ENABLED</code> Enable/disable metrics <code>true</code> <code>RESTMACHINE_METRICS_NAMESPACE</code> CloudWatch namespace <code>RestMachine</code> <code>RESTMACHINE_SERVICE_NAME</code> Service name dimension Lambda function name <code>RESTMACHINE_METRICS_RESOLUTION</code> Resolution (1 or 60 seconds) <code>60</code> <p>Example Lambda environment variables:</p> <pre><code>RESTMACHINE_METRICS_NAMESPACE=MyApp/Production\nRESTMACHINE_SERVICE_NAME=user-api\nRESTMACHINE_METRICS_RESOLUTION=1\n</code></pre> <p>Priority order: 1. Constructor parameters (highest) 2. Environment variables 3. Defaults (lowest)</p>"},{"location":"restmachine-aws/guides/metrics/#disabling-metrics","title":"Disabling Metrics","text":"<pre><code># Via parameter\nadapter = AwsApiGatewayAdapter(app, enable_metrics=False)\n\n# Via environment variable\n# RESTMACHINE_METRICS_ENABLED=false\n</code></pre>"},{"location":"restmachine-aws/guides/metrics/#built-in-metrics","title":"Built-in Metrics","text":"<p>Every request automatically includes these metrics:</p> Metric Description Unit <code>adapter.total_time</code> Total request time including conversion Milliseconds <code>adapter.event_to_request</code> Time to convert API Gateway event to Request Milliseconds <code>application.execute</code> Time in application/state machine Milliseconds <code>adapter.response_conversion</code> Time to convert Response to API Gateway format Milliseconds <code>errors</code> Count of errors (only when errors occur) Count"},{"location":"restmachine-aws/guides/metrics/#default-dimensions","title":"Default Dimensions","text":"<p>All metrics include:</p> <ul> <li><code>method</code> - HTTP method (GET, POST, etc.)</li> <li><code>path</code> - Request path</li> <li><code>service</code> - Service name (if configured)</li> </ul>"},{"location":"restmachine-aws/guides/metrics/#metadata-non-dimensions","title":"Metadata (Non-dimensions)","text":"<p>High-cardinality fields included as metadata:</p> <ul> <li><code>status_code</code> - HTTP response status</li> <li><code>error</code> - Error message (when error occurs)</li> <li><code>error_type</code> - Error class name (when error occurs)</li> </ul>"},{"location":"restmachine-aws/guides/metrics/#cloudwatch-emf-format","title":"CloudWatch EMF Format","text":"<p>Metrics are logged as JSON in EMF format:</p> <pre><code>{\n  \"_aws\": {\n    \"Timestamp\": 1634567890000,\n    \"CloudWatchMetrics\": [{\n      \"Namespace\": \"MyApp/Production\",\n      \"Dimensions\": [[\"method\", \"path\", \"service\"]],\n      \"Metrics\": [\n        {\"Name\": \"users.fetched\", \"Unit\": \"Count\"},\n        {\"Name\": \"adapter.total_time\", \"Unit\": \"Milliseconds\"}\n      ]\n    }]\n  },\n  \"method\": \"GET\",\n  \"path\": \"/users/123\",\n  \"service\": \"user-api\",\n  \"users.fetched\": 1,\n  \"adapter.total_time\": 45.2,\n  \"status_code\": 200,\n  \"request_id\": \"abc-123\"\n}\n</code></pre> <p>This JSON: - Appears in CloudWatch Logs (searchable, debuggable) - Automatically creates CloudWatch Metrics - No PutMetricData API calls needed - Works within existing Lambda log permissions</p>"},{"location":"restmachine-aws/guides/metrics/#viewing-metrics-in-cloudwatch","title":"Viewing Metrics in CloudWatch","text":""},{"location":"restmachine-aws/guides/metrics/#cloudwatch-logs","title":"CloudWatch Logs","text":"<ol> <li>Open CloudWatch Logs</li> <li>Navigate to your Lambda function's log group</li> <li>Search for EMF JSON (contains <code>\"_aws\"</code>)</li> <li>View full request context and metrics</li> </ol>"},{"location":"restmachine-aws/guides/metrics/#cloudwatch-metrics","title":"CloudWatch Metrics","text":"<ol> <li>Open CloudWatch Metrics</li> <li>Select \"Custom Namespaces\" or your namespace (e.g., \"MyApp/Production\")</li> <li>Browse by dimensions (method, path, service)</li> <li>Create dashboards and alarms</li> </ol> <p>Metrics appear within 1-2 minutes of being logged.</p>"},{"location":"restmachine-aws/guides/metrics/#custom-metrics","title":"Custom Metrics","text":"<p>See the Core Metrics Guide for: - Adding custom metrics - Using timers - Dimensions vs metadata - Best practices - Metric units</p>"},{"location":"restmachine-aws/guides/metrics/#advanced-topics","title":"Advanced Topics","text":""},{"location":"restmachine-aws/guides/metrics/#automatic-logging-configuration","title":"Automatic Logging Configuration","text":"<p>The adapter automatically configures logging:</p> <ul> <li>Logger: <code>restmachine.metrics.emf</code></li> <li>Level: <code>METRICS</code> (25, between INFO and WARNING)</li> <li>Handler: <code>StreamHandler</code> (stdout)</li> </ul> <p>To control logging manually:</p> <pre><code>import logging\nfrom restmachine.metrics import METRICS\n\n# Disable metrics output\nlogging.getLogger(\"restmachine.metrics.emf\").setLevel(logging.WARNING)\n\n# Enable debug logging\nlogging.getLogger(\"restmachine.metrics.emf\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"restmachine-aws/guides/metrics/#cloudwatch-limits","title":"CloudWatch Limits","text":"<ul> <li>Max 100 metrics per EMF object: Automatically chunked</li> <li>Max 30 dimensions: Automatically truncated if exceeded</li> <li>Use metadata for high-cardinality: Request IDs, user IDs, etc.</li> </ul>"},{"location":"restmachine-aws/guides/metrics/#cost-optimization","title":"Cost Optimization","text":"<ol> <li>Standard resolution (60s) instead of high-resolution (1s)</li> <li>Selective metrics - don't track everything</li> <li>Appropriate dimensions - avoid high cardinality</li> <li>Disable in dev/test via environment variable</li> </ol> <pre><code># Development environment\nRESTMACHINE_METRICS_ENABLED=false\n</code></pre>"},{"location":"restmachine-aws/guides/metrics/#multi-region-deployments","title":"Multi-Region Deployments","text":"<p>Add region dimension for multi-region visibility:</p> <pre><code>import os\n\n@app.get(\"/data\")\ndef get_data(metrics):\n    region = os.environ.get(\"AWS_REGION\", \"unknown\")\n    metrics.add_dimension(\"region\", region)\n\n    # Your logic here\n    return data\n</code></pre>"},{"location":"restmachine-aws/guides/metrics/#troubleshooting","title":"Troubleshooting","text":""},{"location":"restmachine-aws/guides/metrics/#metrics-not-appearing-in-cloudwatch","title":"Metrics not appearing in CloudWatch","text":"<ol> <li> <p>Check CloudWatch Logs - Verify EMF JSON is being logged    <pre><code>aws logs tail /aws/lambda/your-function --follow\n</code></pre></p> </li> <li> <p>Check namespace - Ensure you're looking in the correct namespace</p> </li> <li> <p>Wait 1-2 minutes - Metrics aren't instant</p> </li> <li> <p>Check IAM permissions - Lambda needs CloudWatch Logs permissions (usually automatic)</p> </li> </ol>"},{"location":"restmachine-aws/guides/metrics/#emf-json-not-in-logs","title":"EMF JSON not in logs","text":"<ol> <li> <p>Check logging level:    <pre><code>logging.getLogger(\"restmachine.metrics.emf\").setLevel(METRICS)\n</code></pre></p> </li> <li> <p>Check metrics are enabled:    <pre><code>assert adapter.metrics_handler.publisher is not None\n</code></pre></p> </li> <li> <p>Check environment variable:    <pre><code>echo $RESTMACHINE_METRICS_ENABLED  # Should be 'true' or unset\n</code></pre></p> </li> </ol>"},{"location":"restmachine-aws/guides/metrics/#dimension-limit-errors","title":"Dimension limit errors","text":"<pre><code># Too many dimensions\nmetrics.add_dimension(\"user_id\", user_id)  # High cardinality!\n\n# Use metadata instead\nmetrics.add_metadata(\"user_id\", user_id)  # \u2705 Correct\n</code></pre>"},{"location":"restmachine-aws/guides/metrics/#performance-concerns","title":"Performance concerns","text":"<ul> <li>Minimal overhead: ~0.1-0.5ms per request</li> <li>Non-blocking: Metrics published after response</li> <li>Disable in dev: Use environment variable</li> </ul>"},{"location":"restmachine-aws/guides/metrics/#examples","title":"Examples","text":""},{"location":"restmachine-aws/guides/metrics/#e-commerce-api","title":"E-commerce API","text":"<pre><code>@app.post(\"/orders\")\ndef create_order(order_data, metrics):\n    metrics.add_dimension(\"order_type\", order_data.type)\n    metrics.add_dimension(\"payment_method\", order_data.payment)\n\n    metrics.start_timer(\"order.validation\")\n    validate(order_data)\n    metrics.stop_timer(\"order.validation\")\n\n    metrics.start_timer(\"order.creation\")\n    order = db.create_order(order_data)\n    metrics.stop_timer(\"order.creation\")\n\n    metrics.add_metric(\"orders.created\", 1, unit=\"Count\")\n    metrics.add_metric(\"order.total\", order.total, unit=\"NoUnit\")\n\n    # High cardinality - use metadata\n    metrics.add_metadata(\"order_id\", order.id)\n    metrics.add_metadata(\"customer_id\", order.customer_id)\n\n    return order\n</code></pre>"},{"location":"restmachine-aws/guides/metrics/#api-with-external-calls","title":"API with External Calls","text":"<pre><code>@app.get(\"/data\")\ndef fetch_data(metrics):\n    metrics.start_timer(\"external.api.call\")\n\n    try:\n        response = external_api.fetch()\n        metrics.add_metric(\"external.api.success\", 1, unit=\"Count\")\n    except Exception as e:\n        metrics.add_metric(\"external.api.errors\", 1, unit=\"Count\")\n        metrics.add_metadata(\"error\", str(e))\n        raise\n    finally:\n        metrics.stop_timer(\"external.api.call\")\n\n    return response\n</code></pre>"},{"location":"restmachine-aws/guides/metrics/#related-documentation","title":"Related Documentation","text":"<ul> <li>Core Metrics Guide - Platform-agnostic features</li> <li>Lambda Deployment - Deploying to Lambda</li> <li>Adapter API Reference - AwsApiGatewayAdapter details</li> </ul>"},{"location":"restmachine-web/","title":"RestMachine Web","text":"<p>Web extensions for RestMachine, providing static file serving, template rendering, and other web-focused features.</p>"},{"location":"restmachine-web/#features","title":"Features","text":"<ul> <li>Static File Serving: Serve static files from local filesystem or S3</li> <li>Template Rendering: Built-in support for Jinja2 templates</li> <li>Form Handling: Process HTML forms with validation</li> <li>Session Management: HTTP session support</li> </ul>"},{"location":"restmachine-web/#quick-links","title":"Quick Links","text":"<ul> <li>Static Files Guide</li> <li>Template Rendering Guide</li> <li>API Reference</li> </ul>"},{"location":"restmachine-web/api/static-router/","title":"StaticRouter","text":""},{"location":"restmachine-web/api/static-router/#restmachine_web.StaticRouter","title":"StaticRouter","text":"<pre><code>StaticRouter(\n    serve: str, index_file: str = \"index.html\", retry_with_index: bool = False\n)\n</code></pre> <p>               Bases: <code>Router</code></p> <p>Router for serving static files from a local directory or S3 bucket.</p> <p>This router provides a simple way to mount a directory of static files to a RestMachine application. It includes security features like path traversal protection and supports serving index files for directories.</p> <p>Supports both local filesystem and S3: - Local: serve=\"./public\" - S3: serve=\"s3://bucket-name/optional-prefix/\"</p> <p>Only supports GET requests - all other methods return 405 Method Not Allowed.</p> Example <pre><code>from restmachine import RestApplication\nfrom restmachine_web import StaticRouter\n\napp = RestApplication()\n\n# Local filesystem\nstatic_router = StaticRouter(serve=\"./public\")\napp.mount(\"/static\", static_router)\n\n# S3 bucket\ns3_router = StaticRouter(\n    serve=\"s3://my-bucket/assets/\",\n    retry_with_index=True\n)\napp.mount(\"/assets\", s3_router)\n</code></pre> <p>Initialize the static file router.</p> <p>Parameters:</p> Name Type Description Default <code>serve</code> <code>str</code> <p>Path to the directory containing static files   Can be local path or S3 URI (s3://bucket-name/prefix/)</p> required <code>index_file</code> <code>str</code> <p>Name of the index file to serve for directory requests        (default: \"index.html\")</p> <code>'index.html'</code> <code>retry_with_index</code> <code>bool</code> <p>If True and initial S3 GetObject fails, retry with             index file appended (treats path as directory)</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If local directory doesn't exist or is not a directory</p> <code>ImportError</code> <p>If S3 path is used but boto3 is not installed</p> Source code in <code>packages/restmachine-web/src/restmachine_web/static_router.py</code> <pre><code>def __init__(\n    self,\n    serve: str,\n    index_file: str = \"index.html\",\n    retry_with_index: bool = False\n):\n    \"\"\"Initialize the static file router.\n\n    Args:\n        serve: Path to the directory containing static files\n              Can be local path or S3 URI (s3://bucket-name/prefix/)\n        index_file: Name of the index file to serve for directory requests\n                   (default: \"index.html\")\n        retry_with_index: If True and initial S3 GetObject fails, retry with\n                        index file appended (treats path as directory)\n\n    Raises:\n        ValueError: If local directory doesn't exist or is not a directory\n        ImportError: If S3 path is used but boto3 is not installed\n    \"\"\"\n    super().__init__()\n\n    self.index_file = index_file\n    self.retry_with_index = retry_with_index\n\n    # Detect if this is an S3 path\n    if serve.startswith(\"s3://\"):\n        self.is_s3 = True\n        self._parse_s3_path(serve)\n    else:\n        self.is_s3 = False\n        self.directory = PathType(serve).resolve()\n\n        if not self.directory.exists():\n            raise ValueError(f\"Directory does not exist: {serve}\")\n        if not self.directory.is_dir():\n            raise ValueError(f\"Path is not a directory: {serve}\")\n\n    # Register the wildcard GET route\n    self._register_routes()\n</code></pre>"},{"location":"restmachine-web/api/static-router/#restmachine_web.StaticRouter-functions","title":"Functions","text":""},{"location":"restmachine-web/api/static-router/#overview","title":"Overview","text":"<p><code>StaticRouter</code> is a specialized router for serving static files from local filesystem or S3 buckets. It inherits from <code>restmachine.Router</code> and provides secure, convenient static file serving with automatic MIME type detection and path traversal protection.</p>"},{"location":"restmachine-web/api/static-router/#class-signature","title":"Class Signature","text":"<pre><code>class StaticRouter(Router):\n    def __init__(\n        self,\n        serve: str,\n        index_file: str = \"index.html\",\n        retry_with_index: bool = False\n    )\n</code></pre>"},{"location":"restmachine-web/api/static-router/#parameters","title":"Parameters","text":""},{"location":"restmachine-web/api/static-router/#serve-required","title":"<code>serve</code> (required)","text":"<p>Path to serve files from. Can be:</p> <ul> <li>Local path: <code>\"./public\"</code>, <code>\"/var/www/html\"</code>, <code>\"static/\"</code></li> <li>S3 URI: <code>\"s3://bucket-name/prefix/\"</code></li> </ul> <pre><code># Local filesystem\nStaticRouter(serve=\"./public\")\nStaticRouter(serve=\"/var/www/static\")\n\n# S3 bucket\nStaticRouter(serve=\"s3://my-bucket/assets/\")\nStaticRouter(serve=\"s3://website-bucket/\")\n</code></pre>"},{"location":"restmachine-web/api/static-router/#index_file-optional","title":"<code>index_file</code> (optional)","text":"<p>Default: <code>\"index.html\"</code></p> <p>Name of the index file to serve for directory requests.</p> <pre><code># Serve index.html for directories\nStaticRouter(serve=\"./public\", index_file=\"index.html\")\n\n# Custom index file\nStaticRouter(serve=\"./public\", index_file=\"default.htm\")\n</code></pre> <p>When a directory path is requested (e.g., <code>/static/docs/</code>), the router will serve <code>index_file</code> from that directory (<code>./public/docs/index.html</code>).</p>"},{"location":"restmachine-web/api/static-router/#retry_with_index-optional","title":"<code>retry_with_index</code> (optional)","text":"<p>Default: <code>False</code></p> <p>For S3 paths only. If <code>True</code> and the initial S3 GetObject fails, retry by appending the index file name.</p> <pre><code>StaticRouter(\n    serve=\"s3://my-bucket/site/\",\n    retry_with_index=True\n)\n\n# GET /about \u2192 tries:\n#   1. s3://my-bucket/site/about\n#   2. s3://my-bucket/site/about/index.html\n</code></pre> <p>Useful for static websites where paths like <code>/about</code> should serve <code>/about/index.html</code>.</p>"},{"location":"restmachine-web/api/static-router/#attributes","title":"Attributes","text":""},{"location":"restmachine-web/api/static-router/#directory-pathtype-local-only","title":"<code>directory</code> (PathType, local only)","text":"<p>Resolved absolute path to the local directory being served.</p> <pre><code>router = StaticRouter(serve=\"./public\")\nprint(router.directory)  # /home/user/project/public\n</code></pre>"},{"location":"restmachine-web/api/static-router/#is_s3-bool","title":"<code>is_s3</code> (bool)","text":"<p>Whether this router serves from S3 or local filesystem.</p> <pre><code>local = StaticRouter(serve=\"./public\")\nprint(local.is_s3)  # False\n\ns3 = StaticRouter(serve=\"s3://bucket/\")\nprint(s3.is_s3)  # True\n</code></pre>"},{"location":"restmachine-web/api/static-router/#s3_bucket-str-s3-only","title":"<code>s3_bucket</code> (str, S3 only)","text":"<p>S3 bucket name.</p> <pre><code>router = StaticRouter(serve=\"s3://my-bucket/assets/\")\nprint(router.s3_bucket)  # \"my-bucket\"\n</code></pre>"},{"location":"restmachine-web/api/static-router/#s3_prefix-str-s3-only","title":"<code>s3_prefix</code> (str, S3 only)","text":"<p>S3 key prefix (path within bucket).</p> <pre><code>router = StaticRouter(serve=\"s3://my-bucket/assets/css/\")\nprint(router.s3_prefix)  # \"assets/css/\"\n</code></pre>"},{"location":"restmachine-web/api/static-router/#methods","title":"Methods","text":""},{"location":"restmachine-web/api/static-router/#_serve_filepath-str-response","title":"<code>_serve_file(path: str) -&gt; Response</code>","text":"<p>Internal method that serves a file from the configured location.</p> <p>Parameters: - <code>path</code> (str): Requested file path (relative to serve location)</p> <p>Returns: - <code>Response</code>: RestMachine response with file contents</p> <p>Behavior: - Normalizes and validates the path - Prevents directory traversal attacks - Detects MIME type from file extension - Returns 404 if file not found - Returns 500 on read errors</p>"},{"location":"restmachine-web/api/static-router/#http-methods","title":"HTTP Methods","text":""},{"location":"restmachine-web/api/static-router/#allowed-get","title":"Allowed: GET","text":"<p>Only GET requests are handled. Static files are read-only.</p> <pre><code>GET /static/style.css     # \u2713 Returns file\nHEAD /static/style.css    # \u2713 Returns headers only\n</code></pre>"},{"location":"restmachine-web/api/static-router/#not-allowed-post-put-delete-patch","title":"Not Allowed: POST, PUT, DELETE, PATCH","text":"<p>All modification methods return <code>405 Method Not Allowed</code>.</p> <pre><code>POST /static/file.txt     # \u2717 405\nPUT /static/file.txt      # \u2717 405\nDELETE /static/file.txt   # \u2717 405\nPATCH /static/file.txt    # \u2717 405\n</code></pre>"},{"location":"restmachine-web/api/static-router/#response-headers","title":"Response Headers","text":""},{"location":"restmachine-web/api/static-router/#content-type","title":"Content-Type","text":"<p>Automatically detected from file extension:</p> Extension Content-Type <code>.html</code> <code>text/html</code> <code>.css</code> <code>text/css</code> <code>.js</code> <code>application/javascript</code> <code>.json</code> <code>application/json</code> <code>.png</code> <code>image/png</code> <code>.jpg</code>, <code>.jpeg</code> <code>image/jpeg</code> <code>.svg</code> <code>image/svg+xml</code> <code>.pdf</code> <code>application/pdf</code> <code>.txt</code> <code>text/plain</code> (unknown) <code>application/octet-stream</code>"},{"location":"restmachine-web/api/static-router/#content-length","title":"Content-Length","text":"<p>Set automatically based on file size.</p>"},{"location":"restmachine-web/api/static-router/#security-features","title":"Security Features","text":""},{"location":"restmachine-web/api/static-router/#path-traversal-prevention","title":"Path Traversal Prevention","text":"<p>Requested paths are normalized and validated to prevent directory traversal:</p> <pre><code># These are blocked (return 404):\nGET /../../../etc/passwd\nGET /..%2F..%2Fetc%2Fpasswd\nGET /./../../secret.key\n</code></pre> <p>The router ensures all served files are within the configured <code>serve</code> directory.</p>"},{"location":"restmachine-web/api/static-router/#path-normalization","title":"Path Normalization","text":"<p>Multiple slashes and relative path components are normalized:</p> <pre><code># All normalize to: /css/style.css\nGET //css//style.css\nGET /./css/./style.css\nGET /css/../css/style.css\n</code></pre>"},{"location":"restmachine-web/api/static-router/#error-responses","title":"Error Responses","text":""},{"location":"restmachine-web/api/static-router/#404-not-found","title":"404 Not Found","text":"<p>Returned when: - File doesn't exist - Directory requested without index file - Path traversal detected</p> <pre><code># File doesn't exist\nGET /static/nonexistent.txt  # 404\n\n# Directory without index.html\nGET /static/docs/  # 404 if docs/index.html doesn't exist\n\n# Invalid path\nGET /static/../../../etc/passwd  # 404\n</code></pre>"},{"location":"restmachine-web/api/static-router/#403-forbidden","title":"403 Forbidden","text":"<p>Returned for S3 access denied errors:</p> <pre><code># S3 object exists but no permission\nGET /static/protected.pdf  # 403 if S3 returns AccessDenied\n</code></pre>"},{"location":"restmachine-web/api/static-router/#405-method-not-allowed","title":"405 Method Not Allowed","text":"<p>Returned for non-GET requests:</p> <pre><code>POST /static/file.txt    # 405\nDELETE /static/file.txt  # 405\n</code></pre>"},{"location":"restmachine-web/api/static-router/#500-internal-server-error","title":"500 Internal Server Error","text":"<p>Returned for: - S3 service errors - File read errors - Other unexpected errors</p>"},{"location":"restmachine-web/api/static-router/#usage-examples","title":"Usage Examples","text":""},{"location":"restmachine-web/api/static-router/#basic-local-files","title":"Basic Local Files","text":"<pre><code>from restmachine import RestApplication\nfrom restmachine_web import StaticRouter\n\napp = RestApplication()\n\nstatic = StaticRouter(serve=\"./public\")\napp.mount(\"/static\", static)\n\n# Serves:\n# GET /static/index.html \u2192 ./public/index.html\n# GET /static/css/app.css \u2192 ./public/css/app.css\n</code></pre>"},{"location":"restmachine-web/api/static-router/#s3-with-prefix","title":"S3 with Prefix","text":"<pre><code>static = StaticRouter(serve=\"s3://my-bucket/assets/v1/\")\napp.mount(\"/assets\", static)\n\n# Serves:\n# GET /assets/logo.png \u2192 s3://my-bucket/assets/v1/logo.png\n# GET /assets/js/app.js \u2192 s3://my-bucket/assets/v1/js/app.js\n</code></pre>"},{"location":"restmachine-web/api/static-router/#multiple-mounts","title":"Multiple Mounts","text":"<pre><code># Frontend app\nfrontend = StaticRouter(serve=\"./frontend/build\")\napp.mount(\"/app\", frontend)\n\n# Documentation\ndocs = StaticRouter(serve=\"./docs/html\")\napp.mount(\"/docs\", docs)\n\n# User uploads (S3)\nuploads = StaticRouter(serve=\"s3://bucket/uploads/\")\napp.mount(\"/uploads\", uploads)\n</code></pre>"},{"location":"restmachine-web/api/static-router/#custom-index-file","title":"Custom Index File","text":"<pre><code>static = StaticRouter(\n    serve=\"./public\",\n    index_file=\"home.html\"  # Serve home.html instead of index.html\n)\napp.mount(\"/\", static)\n\n# GET / \u2192 ./public/home.html\n# GET /about/ \u2192 ./public/about/home.html\n</code></pre>"},{"location":"restmachine-web/api/static-router/#s3-static-website","title":"S3 Static Website","text":"<pre><code>static = StaticRouter(\n    serve=\"s3://my-site/\",\n    index_file=\"index.html\",\n    retry_with_index=True  # Try path + index.html on failure\n)\napp.mount(\"/\", static)\n\n# GET /about \u2192 tries:\n#   1. s3://my-site/about (fails)\n#   2. s3://my-site/about/index.html (succeeds)\n</code></pre>"},{"location":"restmachine-web/api/static-router/#installation","title":"Installation","text":"<p>Local filesystem only:</p> <pre><code>pip install restmachine-web\n</code></pre> <p>With S3 support:</p> <pre><code>pip install restmachine-web[s3]\n</code></pre> <p>This installs <code>boto3</code> for S3 access.</p>"},{"location":"restmachine-web/api/static-router/#see-also","title":"See Also","text":"<ul> <li>Static Files Guide - Usage guide and examples</li> <li>Router (Core) - Base router class</li> <li>Application.mount() - Mounting routers</li> </ul>"},{"location":"restmachine-web/api/template-renderer/","title":"Template Rendering","text":"<p>RestMachine Web doesn't provide a built-in template renderer class. Instead, it works seamlessly with popular Python template engines like Jinja2.</p>"},{"location":"restmachine-web/api/template-renderer/#using-jinja2","title":"Using Jinja2","text":"<p>The recommended approach is to use Jinja2 directly with RestMachine's dependency injection:</p> <pre><code>from restmachine import RestApplication\nfrom jinja2 import Environment, FileSystemLoader\nimport os\n\napp = RestApplication()\n\n# Configure Jinja2 as a dependency\ntemplate_dir = os.path.join(os.path.dirname(__file__), 'templates')\njinja_env = Environment(\n    loader=FileSystemLoader(template_dir),\n    autoescape=True\n)\n\n@app.dependency()\ndef templates():\n    \"\"\"Provide Jinja2 environment to handlers.\"\"\"\n    return jinja_env\n\n@app.get('/page/{name}')\ndef render_page(request, templates):\n    \"\"\"Render a template.\"\"\"\n    template = templates.get_template('page.html')\n    name = request.path_params['name']\n\n    html = template.render(name=name)\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre>"},{"location":"restmachine-web/api/template-renderer/#template-helper-pattern","title":"Template Helper Pattern","text":"<p>For cleaner code, create a rendering helper:</p> <pre><code>@app.dependency()\ndef render_template(templates):\n    \"\"\"Helper for rendering templates.\"\"\"\n    def render(template_name: str, **context):\n        template = templates.get_template(template_name)\n        return template.render(**context)\n    return render\n\n@app.get('/users')\ndef list_users(database, render_template):\n    \"\"\"Render users list.\"\"\"\n    users = database.get_users()\n    html = render_template('users.html', users=users)\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre>"},{"location":"restmachine-web/api/template-renderer/#why-no-built-in-renderer","title":"Why No Built-in Renderer?","text":"<p>RestMachine follows the principle of \"batteries not included\" for template rendering:</p> <ol> <li>Flexibility - Use any template engine (Jinja2, Mako, Chameleon, etc.)</li> <li>Simplicity - No abstraction layer to learn</li> <li>Control - Direct access to all template engine features</li> <li>Zero dependencies - Don't pay for what you don't use</li> </ol>"},{"location":"restmachine-web/api/template-renderer/#other-template-engines","title":"Other Template Engines","text":""},{"location":"restmachine-web/api/template-renderer/#mako","title":"Mako","text":"<pre><code>from mako.template import Template\nfrom mako.lookup import TemplateLookup\n\n@app.dependency()\ndef templates():\n    return TemplateLookup(directories=['./templates'])\n\n@app.get('/page')\ndef render_page(templates):\n    template = templates.get_template('page.html')\n    html = template.render(title=\"My Page\")\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre>"},{"location":"restmachine-web/api/template-renderer/#chameleon","title":"Chameleon","text":"<pre><code>from chameleon import PageTemplateLoader\n\n@app.dependency()\ndef templates():\n    return PageTemplateLoader('./templates')\n\n@app.get('/page')\ndef render_page(templates):\n    template = templates['page.pt']\n    html = template(title=\"My Page\")\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre>"},{"location":"restmachine-web/api/template-renderer/#content-negotiation-with-templates","title":"Content Negotiation with Templates","text":"<p>Serve both JSON and HTML from the same handler:</p> <pre><code>from restmachine import Request\n\n@app.get('/users')\ndef list_users(request: Request, database, render_template):\n    \"\"\"Serve JSON or HTML based on Accept header.\"\"\"\n    users = database.get_users()\n\n    # Check Accept header\n    accept = request.headers.get('accept', '')\n\n    if 'text/html' in accept:\n        # Render HTML template\n        html = render_template('users.html', users=users)\n        return html, 200, {'Content-Type': 'text/html'}\n    else:\n        # Return JSON\n        return {\"users\": users}\n</code></pre> <p>Or use content negotiation with renderers:</p> <pre><code>@app.content_renderer(\"text/html\")\ndef render_html(data, request):\n    \"\"\"Render any data as HTML.\"\"\"\n    # Get template name from route or data\n    template_name = data.get('_template', 'default.html')\n    template = jinja_env.get_template(template_name)\n    return template.render(**data)\n\n@app.get('/users')\ndef list_users(database):\n    \"\"\"Returns dict - rendered as JSON or HTML based on Accept.\"\"\"\n    users = database.get_users()\n    return {\n        \"_template\": \"users.html\",  # For HTML renderer\n        \"users\": users\n    }\n</code></pre>"},{"location":"restmachine-web/api/template-renderer/#combining-with-static-files","title":"Combining with Static Files","text":"<p>Serve both templates and static assets:</p> <pre><code>from restmachine_web import StaticRouter\n\napp = RestApplication()\n\n# Static files (CSS, JS, images)\nstatic = StaticRouter(serve=\"./public\")\napp.mount(\"/static\", static)\n\n# Templates\n@app.dependency()\ndef templates():\n    return jinja_env\n\n@app.get('/')\ndef home(render_template):\n    return render_template('home.html'), 200, {'Content-Type': 'text/html'}\n</code></pre> <p>Template (<code>templates/home.html</code>):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"/static/css/style.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Welcome&lt;/h1&gt;\n    &lt;script src=\"/static/js/app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"restmachine-web/api/template-renderer/#see-also","title":"See Also","text":"<ul> <li>Template Rendering Guide - Complete guide with examples</li> <li>Template Rendering (Main Docs) - Detailed patterns and best practices</li> <li>Static Files Guide - Serving CSS, JS, and images</li> <li>Content Negotiation - Serve multiple formats from one endpoint</li> </ul>"},{"location":"restmachine-web/guides/static-files/","title":"Serving Static Files","text":"<p>RestMachine Web provides easy static file serving from local filesystem or S3, with built-in security and performance features.</p>"},{"location":"restmachine-web/guides/static-files/#installation","title":"Installation","text":"<pre><code>pip install restmachine-web\n</code></pre> <p>For S3 support:</p> <pre><code>pip install restmachine-web[s3]\n</code></pre>"},{"location":"restmachine-web/guides/static-files/#quick-start","title":"Quick Start","text":""},{"location":"restmachine-web/guides/static-files/#local-files","title":"Local Files","text":"<p>Serve files from a local directory:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine_web import StaticRouter\n\napp = RestApplication()\n\n# Mount static files at /static\nstatic = StaticRouter(serve=\"./public\")\napp.mount(\"/static\", static)\n</code></pre> <p>Directory structure:</p> <pre><code>public/\n\u251c\u2500\u2500 css/\n\u2502   \u2514\u2500\u2500 style.css\n\u251c\u2500\u2500 js/\n\u2502   \u2514\u2500\u2500 app.js\n\u251c\u2500\u2500 images/\n\u2502   \u2514\u2500\u2500 logo.png\n\u2514\u2500\u2500 index.html\n</code></pre> <p>Access files:</p> <ul> <li><code>GET /static/index.html</code> \u2192 <code>public/index.html</code></li> <li><code>GET /static/css/style.css</code> \u2192 <code>public/css/style.css</code></li> <li><code>GET /static/images/logo.png</code> \u2192 <code>public/images/logo.png</code></li> </ul>"},{"location":"restmachine-web/guides/static-files/#s3-files","title":"S3 Files","text":"<p>Serve files from an S3 bucket:</p> <pre><code>from restmachine_web import StaticRouter\n\n# S3 bucket with optional prefix\ns3_static = StaticRouter(serve=\"s3://my-bucket/assets/\")\napp.mount(\"/assets\", s3_static)\n</code></pre> <p>Access files:</p> <ul> <li><code>GET /assets/style.css</code> \u2192 <code>s3://my-bucket/assets/style.css</code></li> <li><code>GET /assets/js/app.js</code> \u2192 <code>s3://my-bucket/assets/js/app.js</code></li> </ul>"},{"location":"restmachine-web/guides/static-files/#configuration","title":"Configuration","text":""},{"location":"restmachine-web/guides/static-files/#index-files","title":"Index Files","text":"<p>Serve <code>index.html</code> for directory requests:</p> <pre><code>static = StaticRouter(\n    serve=\"./public\",\n    index_file=\"index.html\"  # Default\n)\n\n# GET /static/ \u2192 public/index.html\n# GET /static/docs/ \u2192 public/docs/index.html\n</code></pre>"},{"location":"restmachine-web/guides/static-files/#s3-with-index-retry","title":"S3 with Index Retry","text":"<p>Automatically append index file for S3 requests:</p> <pre><code>s3_static = StaticRouter(\n    serve=\"s3://my-bucket/site/\",\n    index_file=\"index.html\",\n    retry_with_index=True  # Try path + index.html if initial request fails\n)\n\n# GET /assets/docs \u2192 tries docs, then docs/index.html\n</code></pre> <p>This is useful for static websites hosted on S3.</p>"},{"location":"restmachine-web/guides/static-files/#security-features","title":"Security Features","text":""},{"location":"restmachine-web/guides/static-files/#path-traversal-protection","title":"Path Traversal Protection","text":"<p>The router prevents directory traversal attacks:</p> <pre><code># These requests are blocked:\nGET /static/../../../etc/passwd  # Returns 404\nGET /static/..%2F..%2Fetc%2Fpasswd  # Returns 404\n</code></pre> <p>Requested paths are normalized and validated to ensure they stay within the served directory.</p>"},{"location":"restmachine-web/guides/static-files/#method-restrictions","title":"Method Restrictions","text":"<p>Only <code>GET</code> requests are allowed. All other methods return <code>405 Method Not Allowed</code>:</p> <pre><code>GET /static/file.txt     # \u2713 Allowed\nPOST /static/file.txt    # \u2717 405 Method Not Allowed\nDELETE /static/file.txt  # \u2717 405 Method Not Allowed\n</code></pre>"},{"location":"restmachine-web/guides/static-files/#content-types","title":"Content Types","text":"<p>Content-Type headers are set automatically based on file extension:</p> <pre><code># Automatic MIME type detection\nGET /static/style.css    # Content-Type: text/css\nGET /static/app.js       # Content-Type: application/javascript\nGET /static/image.png    # Content-Type: image/png\nGET /static/data.json    # Content-Type: application/json\nGET /static/page.html    # Content-Type: text/html\n</code></pre>"},{"location":"restmachine-web/guides/static-files/#complete-example","title":"Complete Example","text":""},{"location":"restmachine-web/guides/static-files/#local-static-files","title":"Local Static Files","text":"<pre><code>from restmachine import RestApplication, ASGIAdapter\nfrom restmachine_web import StaticRouter\n\napp = RestApplication()\n\n# API routes\n@app.get(\"/api/hello\")\ndef hello():\n    return {\"message\": \"Hello from API\"}\n\n# Static files\nstatic = StaticRouter(serve=\"./public\", index_file=\"index.html\")\napp.mount(\"/static\", static)\n\n# Serve with ASGI\nasgi_app = ASGIAdapter(app)\n</code></pre> <p>Directory structure:</p> <pre><code>project/\n\u251c\u2500\u2500 app.py\n\u2514\u2500\u2500 public/\n    \u251c\u2500\u2500 index.html\n    \u251c\u2500\u2500 about.html\n    \u251c\u2500\u2500 css/\n    \u2502   \u2514\u2500\u2500 style.css\n    \u2514\u2500\u2500 js/\n        \u2514\u2500\u2500 app.js\n</code></pre> <p>Run:</p> <pre><code>uvicorn app:asgi_app --reload\n</code></pre> <p>Access:</p> <ul> <li><code>http://localhost:8000/api/hello</code> \u2192 API response</li> <li><code>http://localhost:8000/static/</code> \u2192 public/index.html</li> <li><code>http://localhost:8000/static/about.html</code> \u2192 public/about.html</li> <li><code>http://localhost:8000/static/css/style.css</code> \u2192 public/css/style.css</li> </ul>"},{"location":"restmachine-web/guides/static-files/#s3-static-site","title":"S3 Static Site","text":"<pre><code>from restmachine import RestApplication\nfrom restmachine_aws import AwsApiGatewayAdapter\nfrom restmachine_web import StaticRouter\n\napp = RestApplication()\n\n# API routes\n@app.get(\"/api/status\")\ndef status():\n    return {\"status\": \"ok\"}\n\n# S3 static files\nstatic = StaticRouter(\n    serve=\"s3://my-static-site/\",\n    index_file=\"index.html\",\n    retry_with_index=True\n)\napp.mount(\"/\", static)  # Serve at root\n\n# AWS Lambda adapter\nadapter = AwsApiGatewayAdapter(app)\n\ndef lambda_handler(event, context):\n    return adapter.handle_event(event, context)\n</code></pre> <p>This serves a static site from S3 via Lambda:</p> <ul> <li><code>GET /</code> \u2192 S3: <code>index.html</code></li> <li><code>GET /about</code> \u2192 S3: <code>about/index.html</code> (with retry_with_index)</li> <li><code>GET /css/style.css</code> \u2192 S3: <code>css/style.css</code></li> <li><code>GET /api/status</code> \u2192 API handler (not static)</li> </ul>"},{"location":"restmachine-web/guides/static-files/#multiple-static-mounts","title":"Multiple Static Mounts","text":"<p>Serve different directories at different paths:</p> <pre><code>from restmachine_web import StaticRouter\n\n# Frontend assets\nfrontend = StaticRouter(serve=\"./frontend/dist\")\napp.mount(\"/app\", frontend)\n\n# Admin panel\nadmin = StaticRouter(serve=\"./admin/build\")\napp.mount(\"/admin\", admin)\n\n# User uploads (from S3)\nuploads = StaticRouter(serve=\"s3://my-bucket/uploads/\")\napp.mount(\"/uploads\", uploads)\n</code></pre> <p>Access:</p> <ul> <li><code>/app/</code> \u2192 ./frontend/dist/</li> <li><code>/admin/</code> \u2192 ./admin/build/</li> <li><code>/uploads/</code> \u2192 s3://my-bucket/uploads/</li> </ul>"},{"location":"restmachine-web/guides/static-files/#error-handling","title":"Error Handling","text":""},{"location":"restmachine-web/guides/static-files/#file-not-found","title":"File Not Found","text":"<p>Returns <code>404 Not Found</code>:</p> <pre><code>GET /static/nonexistent.txt  # 404 Not Found\n</code></pre>"},{"location":"restmachine-web/guides/static-files/#directory-without-index","title":"Directory Without Index","text":"<p>If directory is requested but <code>index.html</code> doesn't exist:</p> <pre><code>GET /static/somedir/  # 404 if somedir/index.html doesn't exist\n</code></pre>"},{"location":"restmachine-web/guides/static-files/#s3-errors","title":"S3 Errors","text":"<p>S3 errors are converted to appropriate HTTP status codes:</p> <pre><code># NoSuchKey \u2192 404 Not Found\n# AccessDenied \u2192 403 Forbidden\n# Other errors \u2192 500 Internal Server Error\n</code></pre>"},{"location":"restmachine-web/guides/static-files/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use Absolute Paths - Specify full paths to avoid confusion    <pre><code>import os\nstatic_dir = os.path.join(os.path.dirname(__file__), \"public\")\nstatic = StaticRouter(serve=static_dir)\n</code></pre></p> </li> <li> <p>Separate Static from Dynamic - Keep static files in a dedicated directory    <pre><code>project/\n\u251c\u2500\u2500 src/          # Python code\n\u2514\u2500\u2500 public/       # Static files\n</code></pre></p> </li> <li> <p>Use CDN for Production - For high-traffic sites, use CloudFront or similar    <pre><code># Development\nstatic = StaticRouter(serve=\"./public\")\n\n# Production - use CDN, minimal static serving\n</code></pre></p> </li> <li> <p>Cache Headers - Add caching for better performance    <pre><code># Future enhancement: cache-control headers\n</code></pre></p> </li> </ol>"},{"location":"restmachine-web/guides/static-files/#performance-considerations","title":"Performance Considerations","text":""},{"location":"restmachine-web/guides/static-files/#local-files_1","title":"Local Files","text":"<ul> <li>Files are read on each request</li> <li>Consider using a reverse proxy (nginx) for high-traffic static files</li> <li>Use <code>StaticRouter</code> for convenience, not high-performance static serving</li> </ul>"},{"location":"restmachine-web/guides/static-files/#s3-files_1","title":"S3 Files","text":"<ul> <li>Each request makes an S3 API call</li> <li>Consider CloudFront CDN for better performance and cost</li> <li>Use for serverless deployments where local filesystem isn't available</li> </ul>"},{"location":"restmachine-web/guides/static-files/#see-also","title":"See Also","text":"<ul> <li>StaticRouter API - Complete API reference</li> <li>Template Rendering - Combine with dynamic templates</li> <li>AWS Lambda Deployment - Deploy with Lambda</li> </ul>"},{"location":"restmachine-web/guides/templates/","title":"Template Rendering","text":"<p>RestMachine Web works seamlessly with template engines like Jinja2 for rendering HTML, XML, and other text-based formats.</p>"},{"location":"restmachine-web/guides/templates/#quick-start","title":"Quick Start","text":"<p>Install Jinja2:</p> <pre><code>pip install jinja2\n</code></pre> <p>Basic template rendering:</p> <pre><code>from restmachine import RestApplication\nfrom jinja2 import Environment, FileSystemLoader\nimport os\n\napp = RestApplication()\n\n# Configure Jinja2\ntemplate_dir = os.path.join(os.path.dirname(__file__), 'templates')\njinja_env = Environment(\n    loader=FileSystemLoader(template_dir),\n    autoescape=True\n)\n\n@app.dependency()\ndef templates():\n    \"\"\"Provide Jinja2 environment.\"\"\"\n    return jinja_env\n\n@app.get('/hello/{name}')\ndef hello_html(request, templates):\n    \"\"\"Render HTML template.\"\"\"\n    template = templates.get_template('hello.html')\n    name = request.path_params['name']\n\n    html = template.render(name=name)\n\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre> <p>Template file (<code>templates/hello.html</code>):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Hello {{ name }}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"restmachine-web/guides/templates/#complete-guide","title":"Complete Guide","text":"<p>For comprehensive template rendering documentation, including:</p> <ul> <li>Helper dependencies for cleaner code</li> <li>Full HTML page rendering</li> <li>Template inheritance</li> <li>Custom filters and functions</li> <li>Error handling</li> <li>Best practices</li> </ul> <p>See the Template Rendering guide in the main documentation.</p>"},{"location":"restmachine-web/guides/templates/#combining-templates-with-static-files","title":"Combining Templates with Static Files","text":"<p>Serve both static files and rendered templates:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine_web import StaticRouter\nfrom jinja2 import Environment, FileSystemLoader\nimport os\n\napp = RestApplication()\n\n# Static files (CSS, JS, images)\nstatic = StaticRouter(serve=\"./public\")\napp.mount(\"/static\", static)\n\n# Templates\ntemplate_dir = os.path.join(os.path.dirname(__file__), 'templates')\njinja_env = Environment(\n    loader=FileSystemLoader(template_dir),\n    autoescape=True\n)\n\n@app.dependency()\ndef templates():\n    return jinja_env\n\n@app.get('/')\ndef home(templates):\n    \"\"\"Render home page.\"\"\"\n    template = templates.get_template('home.html')\n    html = template.render(\n        title=\"Home\",\n        message=\"Welcome to RestMachine\"\n    )\n    return html, 200, {'Content-Type': 'text/html'}\n\n@app.get('/about')\ndef about(templates):\n    \"\"\"Render about page.\"\"\"\n    template = templates.get_template('about.html')\n    html = template.render(title=\"About\")\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre> <p>Template with static assets (<code>templates/home.html</code>):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{{ title }}&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"/static/css/style.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;{{ message }}&lt;/h1&gt;\n    &lt;script src=\"/static/js/app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Directory structure:</p> <pre><code>project/\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 templates/\n\u2502   \u251c\u2500\u2500 home.html\n\u2502   \u2514\u2500\u2500 about.html\n\u2514\u2500\u2500 public/\n    \u251c\u2500\u2500 css/\n    \u2502   \u2514\u2500\u2500 style.css\n    \u2514\u2500\u2500 js/\n        \u2514\u2500\u2500 app.js\n</code></pre>"},{"location":"restmachine-web/guides/templates/#template-helper","title":"Template Helper","text":"<p>Create a reusable template helper:</p> <pre><code>@app.dependency()\ndef render_template(templates):\n    \"\"\"Helper for rendering templates with default context.\"\"\"\n    def render(template_name: str, **context):\n        template = templates.get_template(template_name)\n        # Add common context variables\n        context.setdefault('site_name', 'My Site')\n        context.setdefault('year', 2025)\n        return template.render(**context)\n    return render\n\n@app.get('/users')\ndef list_users(database, render_template):\n    \"\"\"Render users list.\"\"\"\n    users = database.get_users()\n    html = render_template('users.html', users=users)\n    return html, 200, {'Content-Type': 'text/html'}\n</code></pre>"},{"location":"restmachine-web/guides/templates/#api-html-pages","title":"API + HTML Pages","text":"<p>Serve both API and HTML from the same application:</p> <pre><code>from restmachine import RestApplication\nfrom restmachine_web import StaticRouter\n\napp = RestApplication()\n\n# API routes (JSON)\n@app.get('/api/users')\ndef api_users(database):\n    \"\"\"JSON API endpoint.\"\"\"\n    users = database.get_users()\n    return {\"users\": users}\n\n@app.get('/api/users/{user_id}')\ndef api_user(user_id: str, database):\n    \"\"\"Get single user as JSON.\"\"\"\n    user = database.get_user(user_id)\n    return user or ({\"error\": \"Not found\"}, 404)\n\n# HTML routes\n@app.get('/users')\ndef html_users(database, render_template):\n    \"\"\"HTML page listing users.\"\"\"\n    users = database.get_users()\n    html = render_template('users.html', users=users)\n    return html, 200, {'Content-Type': 'text/html'}\n\n@app.get('/users/{user_id}')\ndef html_user(user_id: str, database, render_template):\n    \"\"\"HTML page for single user.\"\"\"\n    user = database.get_user(user_id)\n    if not user:\n        return render_template('404.html'), 404\n\n    html = render_template('user.html', user=user)\n    return html, 200, {'Content-Type': 'text/html'}\n\n# Static files\nstatic = StaticRouter(serve=\"./public\")\napp.mount(\"/static\", static)\n</code></pre> <p>Access:</p> <ul> <li><code>/api/users</code> \u2192 JSON response</li> <li><code>/users</code> \u2192 HTML page</li> <li><code>/api/users/123</code> \u2192 JSON response</li> <li><code>/users/123</code> \u2192 HTML page</li> <li><code>/static/css/style.css</code> \u2192 Static file</li> </ul>"},{"location":"restmachine-web/guides/templates/#see-also","title":"See Also","text":"<ul> <li>Template Rendering (Main Docs) - Complete template guide</li> <li>Static Files - Serving static assets</li> <li>Content Negotiation - Serve JSON and HTML from the same endpoint</li> </ul>"}]}